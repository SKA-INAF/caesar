/*----- PROTECTED REGION ID(SFinder.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        SFinder.cpp
//
// description : C++ source for the SFinder class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SFinder are implemented in this file.
//
// project :     Source finder worker
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SFinder.h>
#include <SFinderClass.h>

//ROOT headers
#include <TFile.h>

#include <json/json.h>
#include <json/reader.h>

//Caesar headers
#include <Img.h>
#include <BkgData.h>
#include <Contour.h>
#include <Logger.h>
#include <Serializer.h>
using namespace Caesar;

//## Standard headers
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <ctime>
#include <stdexcept>
#include <unistd.h>
#include <getopt.h>
#include <math.h>
#include <time.h>

#include <map>
#include <vector>
#include <thread>
#include <memory>
#include <functional>
#include <chrono>
#include <regex>
#include <exception>

using namespace std;

/*----- PROTECTED REGION END -----*/	//	SFinder.cpp

/**
 *  SFinder class description:
 *    Device server for source finding.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name    |  Method name
//================================================================
//  State           |  Inherited (no method)
//  Status          |  Inherited (no method)
//  ExtractSources  |  extract_sources
//  Configure       |  configure
//  RegisterMe      |  register_me
//  Free            |  free
//  Reserve         |  reserve
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  useLocalBkg               |  Tango::DevBoolean	Scalar
//  use2ndPassInLocalBkg      |  Tango::DevBoolean	Scalar
//  skipNegativePixels        |  Tango::DevBoolean	Scalar
//  skipOutliersInLocalBkg    |  Tango::DevBoolean	Scalar
//  localBkgMethod            |  Tango::DevShort	Scalar
//  bkgEstimator              |  Tango::DevShort	Scalar
//  useBeamInfoInBkg          |  Tango::DevBoolean	Scalar
//  localBkgBoxSizeX          |  Tango::DevFloat	Scalar
//  localBkgBoxSizeY          |  Tango::DevFloat	Scalar
//  localBkgGridStepSizeX     |  Tango::DevFloat	Scalar
//  localBkgGridStepSizeY     |  Tango::DevFloat	Scalar
//  seedThr                   |  Tango::DevFloat	Scalar
//  mergeThr                  |  Tango::DevFloat	Scalar
//  minNPix                   |  Tango::DevLong	Scalar
//  mergeBelowSeed            |  Tango::DevBoolean	Scalar
//  searchNegativeExcess      |  Tango::DevBoolean	Scalar
//  nestedBlobThrFactor       |  Tango::DevFloat	Scalar
//  searchCompactSources      |  Tango::DevBoolean	Scalar
//  selectCompactSources      |  Tango::DevBoolean	Scalar
//  useCircRatioCut           |  Tango::DevBoolean	Scalar
//  psCircRatioThr            |  Tango::DevFloat	Scalar
//  useElongCut               |  Tango::DevBoolean	Scalar
//  psElongThr                |  Tango::DevFloat	Scalar
//  useEllipseAreaRatioCut    |  Tango::DevBoolean	Scalar
//  psEllipseAreaRatioMinThr  |  Tango::DevFloat	Scalar
//  psEllipseAreaRatioMaxThr  |  Tango::DevFloat	Scalar
//  useMaxNPixCut             |  Tango::DevBoolean	Scalar
//  psMaxNPix                 |  Tango::DevLong	Scalar
//  useBoundingBoxCut         |  Tango::DevBoolean	Scalar
//  minBoundingBoxThr         |  Tango::DevFloat	Scalar
//  sourceData                |  Tango::DevString	Scalar
//  runProgress               |  Tango::DevString	Spectrum  ( max = 10)
//  encodedSourceData         |  Tango::DevUChar	Spectrum  ( max = 10000000)
//================================================================

namespace SFinder_ns
{
/*----- PROTECTED REGION ID(SFinder::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SFinder::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SFinder::SFinder()
 *	Description : Constructors for a Tango device
 *                implementing the classSFinder
 */
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SFinder::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_1
}
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(SFinder::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_2
}
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(SFinder::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SFinder::delete_device()
{
	DEBUG_STREAM << "SFinder::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::delete_device) ENABLED START -----*/
	

	// Release the task
	if (this->m_WorkerTaskMgr) {
		//Ask the task to quit
	  this->m_WorkerTaskMgr->exit();
    //- !!!!! never try to <delete> a yat4tango::DeviceTask, cause
    //- it commits suicide upon return of its main function !!!!!!
	  this->m_WorkerTaskMgr = 0;
	}


	//	Delete device allocated objects
	if (m_WorkerThread) {
		DEBUG_LOG("Shutting down worker thread...");
		m_WorkerThread->Stop();
		delete m_WorkerThread;
		m_WorkerThread = 0;
	}

	//Delete broker group	
	if(m_brokerGroup){
		DEBUG_LOG("Deleting broker group...");
		delete m_brokerGroup;
		m_brokerGroup= 0;
	}

	//## Delete mutex
	if(m_mutex) {
  	DEBUG_LOG("Deleting mutex...");
    delete m_mutex;
    m_mutex= 0;
  }
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::delete_device
	delete[] attr_sourceData_read;
	delete[] attr_runProgress_read;
	delete[] attr_encodedSourceData_read;
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SFinder::init_device()
{
	DEBUG_STREAM << "SFinder::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_sourceData_read = new Tango::DevString[1];
	attr_runProgress_read = new Tango::DevString[10];
	attr_encodedSourceData_read = new Tango::DevUChar[10000000];
	/*----- PROTECTED REGION ID(SFinder::init_device) ENABLED START -----*/
	
	//	Initialize device
	//## Init mutex
	DEBUG_LOG("Init mutex...");
  m_mutex= 0;
  m_mutex = new omni_mutex();

	//## Set change state event
	try {
		DEBUG_LOG("Set change event for State attribute of device "<<device_name<<"...");
		set_change_event ("State", true, true);
	}
	catch(Tango::DevFailed& e){
		WARN_LOG("Failed to set change event on State attribute");
	}

	//## Set change state event
	try {
		DEBUG_LOG("Set change event for sourceData attribute of device "<<device_name<<"...");
		set_change_event ("sourceData", true, true);
	}
	catch(Tango::DevFailed& e){
		WARN_LOG("Failed to set change event on sourceData attribute");
	}


	//## Init state
	DEBUG_LOG("Worker "<<device_name<<" started...");
	UpdateState(Tango::ON,"Worker " + device_name + " started");
	
	//## Init default attr values
	LoadDefaultConfig();

	//## Init the worker thread
  DEBUG_LOG("Init worker thread for device "<<device_name<<"...");
  //m_StopThreadFlag= false;
	m_WorkerThread= 0;
  m_WorkerThread = new SFinderThread(this);

	//## Init the worker task 
	m_WorkerTaskMgr = 0;

	try {
		//Task configuration
    yat::Task::Config cfg;
		cfg.enable_timeout_msg= true;
		cfg.timeout_msg_period_ms= 3000;
		cfg.enable_periodic_msg= false;
		cfg.periodic_msg_period_ms= 10000;
		//cfg.lock_msg_handling= ...
		//cfg.lo_wm= ...;//Message queue low water mark. 
		//cfg.hi_wm= ...;//Message queue high water mark. 
		cfg.throw_on_post_tmo= true;

		//Allocate the task
		DEBUG_LOG("Init worker task mgr...");
    m_WorkerTaskMgr = new (std::nothrow) SFinderTask(cfg,this);
	  if (!m_WorkerTaskMgr){
    	throw std::bad_alloc();
		}

    //Start the task
    DEBUG_LOG("Starting task ...");
    m_WorkerTaskMgr->go();
  }
	catch (const Tango::DevFailed& e) {
		Tango::Except::print_exception(e);
  	ERROR_LOG("Exception while creating task!");
    set_state (Tango::FAULT);
  }
  catch (const std::exception& e) {
  	ERROR_LOG("C++ exception while initializing task (err="<<e.what()<<")");
    set_state (Tango::FAULT);
  }  
  catch (...) {
  	ERROR_LOG("Unknown exception while initializing task!");
    set_state (Tango::FAULT);
  }


	//## Init broker group
	DEBUG_LOG("Init broker group...");
	m_brokerGroup= 0;
	if(InitBrokerGroup()<0){
		WARN_LOG("Initialization of broker group failed, retry later...");
	}
  
	/*----- PROTECTED REGION END -----*/	//	SFinder::init_device
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void SFinder::get_device_property()
{
	/*----- PROTECTED REGION ID(SFinder::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("useLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("use2ndPassInLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("skipNegativePixels_default"));
	dev_prop.push_back(Tango::DbDatum("skipOutliersInLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgMethod_default"));
	dev_prop.push_back(Tango::DbDatum("bkgEstimator_default"));
	dev_prop.push_back(Tango::DbDatum("useBeamInfoInBkg_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgBoxSizeX_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgBoxSizeY_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgGridStepSizeX_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgGridStepSizeY_default"));
	dev_prop.push_back(Tango::DbDatum("seedThr_default"));
	dev_prop.push_back(Tango::DbDatum("mergeThr_default"));
	dev_prop.push_back(Tango::DbDatum("minNPix_default"));
	dev_prop.push_back(Tango::DbDatum("mergeBelowSeed_default"));
	dev_prop.push_back(Tango::DbDatum("searchNegativeExcess_default"));
	dev_prop.push_back(Tango::DbDatum("searchNestedSources_default"));
	dev_prop.push_back(Tango::DbDatum("nestedBlobThrFactor_default"));
	dev_prop.push_back(Tango::DbDatum("searchCompactSources_default"));
	dev_prop.push_back(Tango::DbDatum("selectCompactSources_default"));
	dev_prop.push_back(Tango::DbDatum("useCircRatioCut_default"));
	dev_prop.push_back(Tango::DbDatum("psCircRatioThr_default"));
	dev_prop.push_back(Tango::DbDatum("useElongCut_default"));
	dev_prop.push_back(Tango::DbDatum("psElongThr_default"));
	dev_prop.push_back(Tango::DbDatum("useEllipseAreaRatioCut_default"));
	dev_prop.push_back(Tango::DbDatum("psEllipseAreaRatioMinThr_default"));
	dev_prop.push_back(Tango::DbDatum("psEllipseAreaRatioMaxThr_default"));
	dev_prop.push_back(Tango::DbDatum("useMaxNPixCut_default"));
	dev_prop.push_back(Tango::DbDatum("psMaxNPix_default"));
	dev_prop.push_back(Tango::DbDatum("useBoundingBoxCut_default"));
	dev_prop.push_back(Tango::DbDatum("minBoundingBoxThr_default"));
	dev_prop.push_back(Tango::DbDatum("brokerList"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SFinderClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SFinderClass	*ds_class =
			(static_cast<SFinderClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize useLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useLocalBkg_default;
		else {
			//	Try to initialize useLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useLocalBkg_default;
		}
		//	And try to extract useLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useLocalBkg_default;

		//	Try to initialize use2ndPassInLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  use2ndPassInLocalBkg_default;
		else {
			//	Try to initialize use2ndPassInLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  use2ndPassInLocalBkg_default;
		}
		//	And try to extract use2ndPassInLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  use2ndPassInLocalBkg_default;

		//	Try to initialize skipNegativePixels_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skipNegativePixels_default;
		else {
			//	Try to initialize skipNegativePixels_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skipNegativePixels_default;
		}
		//	And try to extract skipNegativePixels_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skipNegativePixels_default;

		//	Try to initialize skipOutliersInLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skipOutliersInLocalBkg_default;
		else {
			//	Try to initialize skipOutliersInLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skipOutliersInLocalBkg_default;
		}
		//	And try to extract skipOutliersInLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skipOutliersInLocalBkg_default;

		//	Try to initialize localBkgMethod_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgMethod_default;
		else {
			//	Try to initialize localBkgMethod_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgMethod_default;
		}
		//	And try to extract localBkgMethod_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgMethod_default;

		//	Try to initialize bkgEstimator_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  bkgEstimator_default;
		else {
			//	Try to initialize bkgEstimator_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  bkgEstimator_default;
		}
		//	And try to extract bkgEstimator_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  bkgEstimator_default;

		//	Try to initialize useBeamInfoInBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useBeamInfoInBkg_default;
		else {
			//	Try to initialize useBeamInfoInBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useBeamInfoInBkg_default;
		}
		//	And try to extract useBeamInfoInBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useBeamInfoInBkg_default;

		//	Try to initialize localBkgBoxSizeX_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgBoxSizeX_default;
		else {
			//	Try to initialize localBkgBoxSizeX_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgBoxSizeX_default;
		}
		//	And try to extract localBkgBoxSizeX_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgBoxSizeX_default;

		//	Try to initialize localBkgBoxSizeY_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgBoxSizeY_default;
		else {
			//	Try to initialize localBkgBoxSizeY_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgBoxSizeY_default;
		}
		//	And try to extract localBkgBoxSizeY_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgBoxSizeY_default;

		//	Try to initialize localBkgGridStepSizeX_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgGridStepSizeX_default;
		else {
			//	Try to initialize localBkgGridStepSizeX_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgGridStepSizeX_default;
		}
		//	And try to extract localBkgGridStepSizeX_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgGridStepSizeX_default;

		//	Try to initialize localBkgGridStepSizeY_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgGridStepSizeY_default;
		else {
			//	Try to initialize localBkgGridStepSizeY_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgGridStepSizeY_default;
		}
		//	And try to extract localBkgGridStepSizeY_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgGridStepSizeY_default;

		//	Try to initialize seedThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  seedThr_default;
		else {
			//	Try to initialize seedThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  seedThr_default;
		}
		//	And try to extract seedThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  seedThr_default;

		//	Try to initialize mergeThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  mergeThr_default;
		else {
			//	Try to initialize mergeThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  mergeThr_default;
		}
		//	And try to extract mergeThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mergeThr_default;

		//	Try to initialize minNPix_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  minNPix_default;
		else {
			//	Try to initialize minNPix_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  minNPix_default;
		}
		//	And try to extract minNPix_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  minNPix_default;

		//	Try to initialize mergeBelowSeed_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  mergeBelowSeed_default;
		else {
			//	Try to initialize mergeBelowSeed_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  mergeBelowSeed_default;
		}
		//	And try to extract mergeBelowSeed_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mergeBelowSeed_default;

		//	Try to initialize searchNegativeExcess_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchNegativeExcess_default;
		else {
			//	Try to initialize searchNegativeExcess_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchNegativeExcess_default;
		}
		//	And try to extract searchNegativeExcess_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchNegativeExcess_default;

		//	Try to initialize searchNestedSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchNestedSources_default;
		else {
			//	Try to initialize searchNestedSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchNestedSources_default;
		}
		//	And try to extract searchNestedSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchNestedSources_default;

		//	Try to initialize nestedBlobThrFactor_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  nestedBlobThrFactor_default;
		else {
			//	Try to initialize nestedBlobThrFactor_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  nestedBlobThrFactor_default;
		}
		//	And try to extract nestedBlobThrFactor_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  nestedBlobThrFactor_default;

		//	Try to initialize searchCompactSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchCompactSources_default;
		else {
			//	Try to initialize searchCompactSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchCompactSources_default;
		}
		//	And try to extract searchCompactSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchCompactSources_default;

		//	Try to initialize selectCompactSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  selectCompactSources_default;
		else {
			//	Try to initialize selectCompactSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  selectCompactSources_default;
		}
		//	And try to extract selectCompactSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  selectCompactSources_default;

		//	Try to initialize useCircRatioCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useCircRatioCut_default;
		else {
			//	Try to initialize useCircRatioCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useCircRatioCut_default;
		}
		//	And try to extract useCircRatioCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useCircRatioCut_default;

		//	Try to initialize psCircRatioThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psCircRatioThr_default;
		else {
			//	Try to initialize psCircRatioThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psCircRatioThr_default;
		}
		//	And try to extract psCircRatioThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psCircRatioThr_default;

		//	Try to initialize useElongCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useElongCut_default;
		else {
			//	Try to initialize useElongCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useElongCut_default;
		}
		//	And try to extract useElongCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useElongCut_default;

		//	Try to initialize psElongThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psElongThr_default;
		else {
			//	Try to initialize psElongThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psElongThr_default;
		}
		//	And try to extract psElongThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psElongThr_default;

		//	Try to initialize useEllipseAreaRatioCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useEllipseAreaRatioCut_default;
		else {
			//	Try to initialize useEllipseAreaRatioCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useEllipseAreaRatioCut_default;
		}
		//	And try to extract useEllipseAreaRatioCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useEllipseAreaRatioCut_default;

		//	Try to initialize psEllipseAreaRatioMinThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psEllipseAreaRatioMinThr_default;
		else {
			//	Try to initialize psEllipseAreaRatioMinThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psEllipseAreaRatioMinThr_default;
		}
		//	And try to extract psEllipseAreaRatioMinThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psEllipseAreaRatioMinThr_default;

		//	Try to initialize psEllipseAreaRatioMaxThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psEllipseAreaRatioMaxThr_default;
		else {
			//	Try to initialize psEllipseAreaRatioMaxThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psEllipseAreaRatioMaxThr_default;
		}
		//	And try to extract psEllipseAreaRatioMaxThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psEllipseAreaRatioMaxThr_default;

		//	Try to initialize useMaxNPixCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useMaxNPixCut_default;
		else {
			//	Try to initialize useMaxNPixCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useMaxNPixCut_default;
		}
		//	And try to extract useMaxNPixCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useMaxNPixCut_default;

		//	Try to initialize psMaxNPix_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psMaxNPix_default;
		else {
			//	Try to initialize psMaxNPix_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psMaxNPix_default;
		}
		//	And try to extract psMaxNPix_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psMaxNPix_default;

		//	Try to initialize useBoundingBoxCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useBoundingBoxCut_default;
		else {
			//	Try to initialize useBoundingBoxCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useBoundingBoxCut_default;
		}
		//	And try to extract useBoundingBoxCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useBoundingBoxCut_default;

		//	Try to initialize minBoundingBoxThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  minBoundingBoxThr_default;
		else {
			//	Try to initialize minBoundingBoxThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  minBoundingBoxThr_default;
		}
		//	And try to extract minBoundingBoxThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  minBoundingBoxThr_default;

		//	Try to initialize brokerList from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  brokerList;
		else {
			//	Try to initialize brokerList from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  brokerList;
		}
		//	And try to extract brokerList value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  brokerList;

	}

	/*----- PROTECTED REGION ID(SFinder::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SFinder::always_executed_hook()
{
	DEBUG_STREAM << "SFinder::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SFinder::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SFinder::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : SFinder::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void SFinder::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SFinder::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute useLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useLocalBkg_read);
	//attr.set_value(&attr_useLocalBkg_write);
	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute useLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_useLocalBkg_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute use2ndPassInLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_use2ndPassInLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_use2ndPassInLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_use2ndPassInLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_use2ndPassInLocalBkg_read);
	//attr.set_value(&attr_use2ndPassInLocalBkg_write);
	
	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_use2ndPassInLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute use2ndPassInLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_use2ndPassInLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_use2ndPassInLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_use2ndPassInLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_use2ndPassInLocalBkg_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_use2ndPassInLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute skipNegativePixels related method
 *	Description: Flag to skip/keep negative pixels when computing the image stats
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_skipNegativePixels(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_skipNegativePixels(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_skipNegativePixels) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_skipNegativePixels_read);
	//attr.set_value(&attr_skipNegativePixels_write);
	
	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_skipNegativePixels
}
//--------------------------------------------------------
/**
 *	Write attribute skipNegativePixels related method
 *	Description: Flag to skip/keep negative pixels when computing the image stats
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_skipNegativePixels(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_skipNegativePixels(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_skipNegativePixels) ENABLED START -----*/
	attr.get_write_value(attr_skipNegativePixels_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_skipNegativePixels
}
//--------------------------------------------------------
/**
 *	Read attribute skipOutliersInLocalBkg related method
 *	Description: Flag to enable/disable skipping outliers in local bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_skipOutliersInLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_skipOutliersInLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_skipOutliersInLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_skipOutliersInLocalBkg_read);
	//attr.set_value(&attr_skipOutliersInLocalBkg_write);
	
	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_skipOutliersInLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute skipOutliersInLocalBkg related method
 *	Description: Flag to enable/disable skipping outliers in local bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_skipOutliersInLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_skipOutliersInLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_skipOutliersInLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_skipOutliersInLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_skipOutliersInLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgMethod related method
 *	Description: Method used to compute local bkg (1=Grid, 2=Superpixel)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgMethod(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgMethod(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgMethod) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgMethod_read);
	//attr.set_value(&attr_localBkgMethod_write);
	
	Tango::DevShort* w_val= new Tango::DevShort;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgMethod
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgMethod related method
 *	Description: Method used to compute local bkg (1=Grid, 2=Superpixel)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgMethod(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgMethod(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgMethod) ENABLED START -----*/
	attr.get_write_value(attr_localBkgMethod_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgMethod
}
//--------------------------------------------------------
/**
 *	Read attribute bkgEstimator related method
 *	Description: Estimator to be used to compute bkg 
 *               (1=mean, 2=median, 3=biweight, 4=clipped median)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_bkgEstimator(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_bkgEstimator(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_bkgEstimator) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_bkgEstimator_read);
	//attr.set_value(&attr_bkgEstimator_write);
	
	Tango::DevShort* w_val= new Tango::DevShort;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_bkgEstimator
}
//--------------------------------------------------------
/**
 *	Write attribute bkgEstimator related method
 *	Description: Estimator to be used to compute bkg 
 *               (1=mean, 2=median, 3=biweight, 4=clipped median)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_bkgEstimator(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_bkgEstimator(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_bkgEstimator) ENABLED START -----*/
	attr.get_write_value(attr_bkgEstimator_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_bkgEstimator
}
//--------------------------------------------------------
/**
 *	Read attribute useBeamInfoInBkg related method
 *	Description: Use beam information in bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useBeamInfoInBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useBeamInfoInBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useBeamInfoInBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useBeamInfoInBkg_read);
	//attr.set_value(&attr_useBeamInfoInBkg_write);

	Tango::DevBoolean* w_val= new Tango::DevBoolean;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useBeamInfoInBkg
}
//--------------------------------------------------------
/**
 *	Write attribute useBeamInfoInBkg related method
 *	Description: Use beam information in bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useBeamInfoInBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useBeamInfoInBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useBeamInfoInBkg) ENABLED START -----*/
	attr.get_write_value(attr_useBeamInfoInBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useBeamInfoInBkg
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgBoxSizeX related method
 *	Description: Box size X used for local bkg computation. If beam information is used, this corresponds to 
 *               a multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgBoxSizeX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgBoxSizeX(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgBoxSizeX) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgBoxSizeX_read);
	//attr.set_value(&attr_localBkgBoxSizeX_write);
	
	Tango::DevFloat* w_val= new Tango::DevFloat;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgBoxSizeX
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgBoxSizeX related method
 *	Description: Box size X used for local bkg computation. If beam information is used, this corresponds to 
 *               a multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgBoxSizeX(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgBoxSizeX(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgBoxSizeX) ENABLED START -----*/
	attr.get_write_value(attr_localBkgBoxSizeX_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgBoxSizeX
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgBoxSizeY related method
 *	Description: Box size Y used for local bkg computation. If beam information is used, this corresponds to a
 *               multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgBoxSizeY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgBoxSizeY(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgBoxSizeY) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgBoxSizeY_read);
	//attr.set_value(&attr_localBkgBoxSizeY_write);
	
	Tango::DevFloat* w_val= new Tango::DevFloat;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgBoxSizeY
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgBoxSizeY related method
 *	Description: Box size Y used for local bkg computation. If beam information is used, this corresponds to a
 *               multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgBoxSizeY(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgBoxSizeY(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgBoxSizeY) ENABLED START -----*/
	attr.get_write_value(attr_localBkgBoxSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgBoxSizeY
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgGridStepSizeX related method
 *	Description: Grid step size X used in local bkg computation. This corresponds to a fraction of the box 
 *               size X (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgGridStepSizeX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgGridStepSizeX(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgGridStepSizeX) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgGridStepSizeX_read);
	//attr.set_value(&attr_localBkgGridStepSizeX_write);
	
	Tango::DevFloat* w_val= new Tango::DevFloat;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgGridStepSizeX
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgGridStepSizeX related method
 *	Description: Grid step size X used in local bkg computation. This corresponds to a fraction of the box 
 *               size X (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgGridStepSizeX(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgGridStepSizeX(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgGridStepSizeX) ENABLED START -----*/
	attr.get_write_value(attr_localBkgGridStepSizeX_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgGridStepSizeX
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgGridStepSizeY related method
 *	Description: Grid step size Y used in local bkg computation. This corresponds to a fraction of the box size Y 
 *               (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgGridStepSizeY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgGridStepSizeY(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgGridStepSizeY) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgGridStepSizeY_read);
	//attr.set_value(&attr_localBkgGridStepSizeY_write);
	Tango::DevFloat* w_val= new Tango::DevFloat;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgGridStepSizeY
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgGridStepSizeY related method
 *	Description: Grid step size Y used in local bkg computation. This corresponds to a fraction of the box size Y 
 *               (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgGridStepSizeY(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgGridStepSizeY(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgGridStepSizeY) ENABLED START -----*/
	attr.get_write_value(attr_localBkgGridStepSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgGridStepSizeY
}
//--------------------------------------------------------
/**
 *	Read attribute seedThr related method
 *	Description: Seed threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_seedThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_seedThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_seedThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_seedThr_read);
	//attr.set_value(&attr_seedThr_write);
	Tango::DevFloat* w_val= new Tango::DevFloat;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_seedThr
}
//--------------------------------------------------------
/**
 *	Write attribute seedThr related method
 *	Description: Seed threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_seedThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_seedThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_seedThr) ENABLED START -----*/
	attr.get_write_value(attr_seedThr_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_seedThr
}
//--------------------------------------------------------
/**
 *	Read attribute mergeThr related method
 *	Description: Merge threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_mergeThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_mergeThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_mergeThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_mergeThr_read);
	//attr.set_value(&attr_mergeThr_write);
	Tango::DevFloat* w_val= new Tango::DevFloat;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_mergeThr
}
//--------------------------------------------------------
/**
 *	Write attribute mergeThr related method
 *	Description: Merge threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_mergeThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_mergeThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_mergeThr) ENABLED START -----*/
	attr.get_write_value(attr_mergeThr_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_mergeThr
}
//--------------------------------------------------------
/**
 *	Read attribute minNPix related method
 *	Description: Minimum number of pixels in source fnding (blob size in flood-fill).
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_minNPix(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_minNPix(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_minNPix) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_minNPix_read);
	//attr.set_value(&attr_minNPix_write);
	
	Tango::DevLong* w_val= new Tango::DevLong;
	std::string attr_name= attr.get_assoc_name();
	get_device_attr()->get_w_attr_by_name(attr_name.c_str()).get_write_value(*w_val);
	attr.set_value(w_val,1,0,true);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_minNPix
}
//--------------------------------------------------------
/**
 *	Write attribute minNPix related method
 *	Description: Minimum number of pixels in source fnding (blob size in flood-fill).
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_minNPix(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_minNPix(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_minNPix) ENABLED START -----*/
	attr.get_write_value(attr_minNPix_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_minNPix
}
//--------------------------------------------------------
/**
 *	Read attribute mergeBelowSeed related method
 *	Description: Flag value to aggregate only pixels below seed threshold in flood-fill
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_mergeBelowSeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_mergeBelowSeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_mergeBelowSeed) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_mergeBelowSeed_read);
	attr.set_value(&attr_mergeBelowSeed_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_mergeBelowSeed
}
//--------------------------------------------------------
/**
 *	Write attribute mergeBelowSeed related method
 *	Description: Flag value to aggregate only pixels below seed threshold in flood-fill
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_mergeBelowSeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_mergeBelowSeed(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_mergeBelowSeed) ENABLED START -----*/
	attr.get_write_value(attr_mergeBelowSeed_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_mergeBelowSeed
}
//--------------------------------------------------------
/**
 *	Read attribute searchNegativeExcess related method
 *	Description: Flag to search negative excess together with positive in compact source search
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_searchNegativeExcess(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_searchNegativeExcess(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_searchNegativeExcess) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_searchNegativeExcess_read);
	attr.set_value(&attr_searchNegativeExcess_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_searchNegativeExcess
}
//--------------------------------------------------------
/**
 *	Write attribute searchNegativeExcess related method
 *	Description: Flag to search negative excess together with positive in compact source search
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_searchNegativeExcess(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_searchNegativeExcess(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_searchNegativeExcess) ENABLED START -----*/
	attr.get_write_value(attr_searchNegativeExcess_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_searchNegativeExcess
}
//--------------------------------------------------------
/**
 *	Read attribute nestedBlobThrFactor related method
 *	Description: Threshold (in multiple of curvature RMS) to be used to detect nested blobs
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_nestedBlobThrFactor(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_nestedBlobThrFactor(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_nestedBlobThrFactor) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_nestedBlobThrFactor_read);
	attr.set_value(&attr_nestedBlobThrFactor_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_nestedBlobThrFactor
}
//--------------------------------------------------------
/**
 *	Write attribute nestedBlobThrFactor related method
 *	Description: Threshold (in multiple of curvature RMS) to be used to detect nested blobs
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_nestedBlobThrFactor(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_nestedBlobThrFactor(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_nestedBlobThrFactor) ENABLED START -----*/
	attr.get_write_value(attr_nestedBlobThrFactor_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_nestedBlobThrFactor
}
//--------------------------------------------------------
/**
 *	Read attribute searchCompactSources related method
 *	Description: Flag to enable/disable search of compact sources
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_searchCompactSources(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_searchCompactSources(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_searchCompactSources) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_searchCompactSources_read);
	attr.set_value(&attr_searchCompactSources_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_searchCompactSources
}
//--------------------------------------------------------
/**
 *	Write attribute searchCompactSources related method
 *	Description: Flag to enable/disable search of compact sources
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_searchCompactSources(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_searchCompactSources(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_searchCompactSources) ENABLED START -----*/
	attr.get_write_value(attr_searchCompactSources_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_searchCompactSources
}
//--------------------------------------------------------
/**
 *	Read attribute selectCompactSources related method
 *	Description: Flag to enable/disable selection of compact sources according to defined cuts
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_selectCompactSources(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_selectCompactSources(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_selectCompactSources) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_selectCompactSources_read);
	attr.set_value(&attr_selectCompactSources_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_selectCompactSources
}
//--------------------------------------------------------
/**
 *	Write attribute selectCompactSources related method
 *	Description: Flag to enable/disable selection of compact sources according to defined cuts
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_selectCompactSources(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_selectCompactSources(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_selectCompactSources) ENABLED START -----*/
	attr.get_write_value(attr_selectCompactSources_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_selectCompactSources
}
//--------------------------------------------------------
/**
 *	Read attribute useCircRatioCut related method
 *	Description: Use cut on circularity ratio in source selection
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useCircRatioCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useCircRatioCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useCircRatioCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useCircRatioCut_read);
	attr.set_value(&attr_useCircRatioCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useCircRatioCut
}
//--------------------------------------------------------
/**
 *	Write attribute useCircRatioCut related method
 *	Description: Use cut on circularity ratio in source selection
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useCircRatioCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useCircRatioCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useCircRatioCut) ENABLED START -----*/
	attr.get_write_value(attr_useCircRatioCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useCircRatioCut
}
//--------------------------------------------------------
/**
 *	Read attribute psCircRatioThr related method
 *	Description: Point-source circularity ratio cut. 
 *               Source is not selected as point-like if circratio<cut (circ ratio
 *               is =1 for a circle).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psCircRatioThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psCircRatioThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psCircRatioThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psCircRatioThr_read);
	attr.set_value(&attr_psCircRatioThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psCircRatioThr
}
//--------------------------------------------------------
/**
 *	Write attribute psCircRatioThr related method
 *	Description: Point-source circularity ratio cut. 
 *               Source is not selected as point-like if circratio<cut (circ ratio
 *               is =1 for a circle).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psCircRatioThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psCircRatioThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psCircRatioThr) ENABLED START -----*/
	attr.get_write_value(attr_psCircRatioThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psCircRatioThr
}
//--------------------------------------------------------
/**
 *	Read attribute useElongCut related method
 *	Description: Flag to enable/disable elongation point-like source cut.
 *               Source is not selected as point-source if elong>cut (Elong=0 
 *               for circle/square).
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useElongCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useElongCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useElongCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useElongCut_read);
	attr.set_value(&attr_useElongCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useElongCut
}
//--------------------------------------------------------
/**
 *	Write attribute useElongCut related method
 *	Description: Flag to enable/disable elongation point-like source cut.
 *               Source is not selected as point-source if elong>cut (Elong=0 
 *               for circle/square).
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useElongCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useElongCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useElongCut) ENABLED START -----*/
	attr.get_write_value(attr_useElongCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useElongCut
}
//--------------------------------------------------------
/**
 *	Read attribute psElongThr related method
 *	Description: Elongation point-like source cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psElongThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psElongThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psElongThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psElongThr_read);
	attr.set_value(&attr_psElongThr_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psElongThr
}
//--------------------------------------------------------
/**
 *	Write attribute psElongThr related method
 *	Description: Elongation point-like source cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psElongThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psElongThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psElongThr) ENABLED START -----*/
	attr.get_write_value(attr_psElongThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psElongThr
}
//--------------------------------------------------------
/**
 *	Read attribute useEllipseAreaRatioCut related method
 *	Description:  Flag to enable/disable ellipse area ratio cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useEllipseAreaRatioCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useEllipseAreaRatioCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useEllipseAreaRatioCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useEllipseAreaRatioCut_read);
	attr.set_value(&attr_useEllipseAreaRatioCut_write);	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useEllipseAreaRatioCut
}
//--------------------------------------------------------
/**
 *	Write attribute useEllipseAreaRatioCut related method
 *	Description:  Flag to enable/disable ellipse area ratio cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useEllipseAreaRatioCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useEllipseAreaRatioCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useEllipseAreaRatioCut) ENABLED START -----*/
	attr.get_write_value(attr_useEllipseAreaRatioCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useEllipseAreaRatioCut
}
//--------------------------------------------------------
/**
 *	Read attribute psEllipseAreaRatioMinThr related method
 *	Description: Min Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psEllipseAreaRatioMinThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psEllipseAreaRatioMinThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psEllipseAreaRatioMinThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psEllipseAreaRatioMinThr_read);
	attr.set_value(&attr_psEllipseAreaRatioMinThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psEllipseAreaRatioMinThr
}
//--------------------------------------------------------
/**
 *	Write attribute psEllipseAreaRatioMinThr related method
 *	Description: Min Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psEllipseAreaRatioMinThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psEllipseAreaRatioMinThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psEllipseAreaRatioMinThr) ENABLED START -----*/
	attr.get_write_value(attr_psEllipseAreaRatioMinThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psEllipseAreaRatioMinThr
}
//--------------------------------------------------------
/**
 *	Read attribute psEllipseAreaRatioMaxThr related method
 *	Description: Max Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psEllipseAreaRatioMaxThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psEllipseAreaRatioMaxThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psEllipseAreaRatioMaxThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psEllipseAreaRatioMaxThr_read);
	attr.set_value(&attr_psEllipseAreaRatioMaxThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psEllipseAreaRatioMaxThr
}
//--------------------------------------------------------
/**
 *	Write attribute psEllipseAreaRatioMaxThr related method
 *	Description: Max Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psEllipseAreaRatioMaxThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psEllipseAreaRatioMaxThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psEllipseAreaRatioMaxThr) ENABLED START -----*/
	attr.get_write_value(attr_psEllipseAreaRatioMaxThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psEllipseAreaRatioMaxThr
}
//--------------------------------------------------------
/**
 *	Read attribute useMaxNPixCut related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useMaxNPixCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useMaxNPixCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useMaxNPixCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useMaxNPixCut_read);
	attr.set_value(&attr_useMaxNPixCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useMaxNPixCut
}
//--------------------------------------------------------
/**
 *	Write attribute useMaxNPixCut related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useMaxNPixCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useMaxNPixCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useMaxNPixCut) ENABLED START -----*/
	attr.get_write_value(attr_useMaxNPixCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useMaxNPixCut
}
//--------------------------------------------------------
/**
 *	Read attribute psMaxNPix related method
 *	Description: Maximum number of pixels to select point-like sources
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psMaxNPix(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psMaxNPix(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psMaxNPix) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psMaxNPix_read);
	attr.set_value(&attr_psMaxNPix_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psMaxNPix
}
//--------------------------------------------------------
/**
 *	Write attribute psMaxNPix related method
 *	Description: Maximum number of pixels to select point-like sources
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psMaxNPix(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psMaxNPix(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psMaxNPix) ENABLED START -----*/
	attr.get_write_value(attr_psMaxNPix_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psMaxNPix
}
//--------------------------------------------------------
/**
 *	Read attribute useBoundingBoxCut related method
 *	Description: Flag to enable/disable bounding box cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useBoundingBoxCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useBoundingBoxCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useBoundingBoxCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useBoundingBoxCut_read);
	attr.set_value(&attr_useBoundingBoxCut_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useBoundingBoxCut
}
//--------------------------------------------------------
/**
 *	Write attribute useBoundingBoxCut related method
 *	Description: Flag to enable/disable bounding box cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useBoundingBoxCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useBoundingBoxCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useBoundingBoxCut) ENABLED START -----*/
	attr.get_write_value(attr_useBoundingBoxCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useBoundingBoxCut
}
//--------------------------------------------------------
/**
 *	Read attribute minBoundingBoxThr related method
 *	Description: Minimum default bounding box cut (source tagged as bad if below this threshold)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_minBoundingBoxThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_minBoundingBoxThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_minBoundingBoxThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_minBoundingBoxThr_read);
	attr.set_value(&attr_minBoundingBoxThr_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_minBoundingBoxThr
}
//--------------------------------------------------------
/**
 *	Write attribute minBoundingBoxThr related method
 *	Description: Minimum default bounding box cut (source tagged as bad if below this threshold)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_minBoundingBoxThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_minBoundingBoxThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_minBoundingBoxThr) ENABLED START -----*/
	attr.get_write_value(attr_minBoundingBoxThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_minBoundingBoxThr
}
//--------------------------------------------------------
/**
 *	Read attribute sourceData related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_sourceData(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_sourceData(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_sourceData) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_sourceData_read);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_sourceData
}
//--------------------------------------------------------
/**
 *	Read attribute runProgress related method
 *	Description: Run progress info
 *               [0]: run id
 *               [1]: status (RUNNING, COMPLETED, ABORTED, FAILED)
 *               [2]: progress fraction (0-100%)
 *               [3]: log info (INIT, READ_IMAGE, BKG, COMPACT_SOURCE, EXT_SOURCE)
 *               [4]: timestamp
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 10
 */
//--------------------------------------------------------
void SFinder::read_runProgress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_runProgress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_runProgress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_runProgress_read, 10);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_runProgress
}
//--------------------------------------------------------
/**
 *	Read attribute encodedSourceData related method
 *	Description: 
 *
 *	Data type:	Tango::DevUChar
 *	Attr type:	Spectrum max = 10000000
 */
//--------------------------------------------------------
void SFinder::read_encodedSourceData(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_encodedSourceData(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_encodedSourceData) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_encodedSourceData_read, 10000000);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_encodedSourceData
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinder::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SFinder::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Read pipe compactSourcesPipe related method
 *	Description: Compact source pipe blob
 */
//--------------------------------------------------------
void SFinder::read_compactSourcesPipe(Tango::Pipe &pipe)
{
	DEBUG_STREAM << "SFinder::read_compactSourcesPipe(Tango::Pipe &pipe) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_compactSourcesPipe) ENABLED START -----*/
	
	//	Add your own code here
	try {	
		pipe.set_root_blob_name("compactSourcesPipeBlob");
		std::vector<std::string> blob_names {"compactSourcesPipeBlob"};
		pipe.set_data_elt_names(blob_names);
		
		DEBUG_LOG("Before pipe set");
		pipe<<m_compactSourcesPipeBlob;
		DEBUG_LOG("After pipe set");
		
	}//close try block
	catch(const Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		ERROR_LOG("Tango exception occurred while setting pipe!");
	}
	catch(std::exception &e){
		ERROR_LOG("Runtime exception occurred (e="<<e.what()<<") while setting pipe!");
	}
	catch(...){
		ERROR_LOG("Unknown exception occurred while setting pipe!");
	}
	

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_compactSourcesPipe
}
//--------------------------------------------------------
/**
 *	Command ExtractSources related method
 *	Description: Find sources in map using the configuration passed 
 *               as argument.
 *
 *	@param argin String arg
 *               [0]: filename (mandatory)
 *               [1]: run guid (mandatory)
 *               [2]: task list (mandatory)
 *               [2]: configuration string  (optional)
 *	@returns Long arg
 *           [0]: ack code
 *           
 *           String arg
 *           [0]: err description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SFinder::extract_sources(const Tango::DevVarStringArray *argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SFinder::ExtractSources()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::extract_sources) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	//Validate args
	long int nArgs= argin->length();
	if(nArgs<3){
		WARN_LOG("Missing arguments!");
		ack= -1;
		reply= "Missing arguments!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	//Check filename arg
	if(strcmp((*argin)[0],"")==0){
		WARN_LOG("Empty filename argument given!");
		ack= -1;
		reply= "Invalid filename argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string inputFileName= std::string((*argin)[0]); 

	//Check run id arg
	if(strcmp((*argin)[1],"")==0){
		WARN_LOG("Empty run id argument given!");
		ack= -1;
		reply= "Invalid run id argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string runId= std::string((*argin)[1]);

	//Check tasks arg
	if(strcmp((*argin)[2],"")==0){
		WARN_LOG("Empty task list argument given!");
		ack= -1;
		reply= "Invalid task list argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string tasks= std::string((*argin)[2]);

	std::vector<WorkerTask*> workerTasks;
	if(Serializer::JsonStringToWorkerTasks(workerTasks,tasks)<0){
		WARN_LOG("Failed to encode tasks!");
		ack= -1;
		reply= "Failed to encode tasks!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	INFO_LOG("# "<<workerTasks.size()<<" tasks requested...");

	//Check config arg
	std::string config= "";
	bool applyConfig= false;
	if(nArgs>3){
		if(strcmp((*argin)[3],"")==0){
			WARN_LOG("Empty config argument given!");
			ack= -1;
			reply= "Invalid config argument given (empty string)!";
			argout->lvalue[0]= ack;
			argout->svalue[0] = CORBA::string_dup(reply.c_str());
			return argout;
		}
		else{
			config= std::string((*argin)[3]);
			applyConfig= true;
		}
	}
	else{
		WARN_LOG("Empty config argument given, running on current config!");
	}

	INFO_LOG("filename: "<<inputFileName);
	INFO_LOG("runId: "<<runId);
	INFO_LOG("tasks: "<<tasks);
	INFO_LOG("config: "<<config);


	//## Apply config?
	if(applyConfig){
		if(ApplyConfig(config)<0){
			WARN_LOG("Configuration failed!");
			ack= -1;
			reply= "Configuration failed!";
			argout->lvalue[0]= ack;
			argout->svalue[0] = CORBA::string_dup(reply.c_str());

			//Free resource for use
			UpdateState(Tango::ON,"Configuration failed, free resource");
			
			return argout;
		}
	}

	//## Start the worker thread
	/*
	if(!m_WorkerThread){
		WARN_LOG("Null ptr to worker thread!");
		ack= -1;
		reply= "Null ptr to worker thread!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());

		//Free resource for use
		UpdateState(Tango::ON,"Configuration failed, free resource");
			
		return argout;
	}
	m_WorkerThread->Start(workerTasks);
	*/

	try {
		m_WorkerTaskMgr->Start(workerTasks,1000);
	}
	catch(const Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		ERROR_LOG("Exception while starting source finder task!");
		ack= -1;
		reply= "Failed to start source finder task!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());

		//Free resource for use
		UpdateState(Tango::ON,"Source finder task start failed, free resource");
			
		return argout;
	}
	catch(...){
		ERROR_LOG("Unknown exception while starting source finder task!");
		ack= -1;
		reply= "Failed to start source finder task!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());

		//Free resource for use
		UpdateState(Tango::ON,"Source finder task start failed, free resource");
			
		return argout;
	}


	//Return reply
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());
	

	/*----- PROTECTED REGION END -----*/	//	SFinder::extract_sources
	return argout;
}
//--------------------------------------------------------
/**
 *	Command Configure related method
 *	Description: 
 *
 *	@param argin Configuration string
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SFinder::configure(Tango::DevString argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SFinder::Configure()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::configure) ENABLED START -----*/
	
	//	Add your own code
	//Init reply data
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	//Check config arg
	if(strcmp(argin,"")==0){
		WARN_LOG("Empty config argument given!");
		ack= -1;
		reply= "Invalid config argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string config= std::string(argin); 

	//Apply configuration (INIT state set internally)
	if(ApplyConfig(config)<0){
		WARN_LOG("Configuration failed!");
		ack= -1;
		reply= "Configuration failed!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	
	//Return reply
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::configure
	return argout;
}
//--------------------------------------------------------
/**
 *	Command RegisterMe related method
 *	Description: Register worker in brokers
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SFinder::register_me()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SFinder::RegisterMe()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::register_me) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	//Init broker group if not done
	if(!m_brokerGroup && InitBrokerGroup()<0){
		WARN_LOG("Failed to initialize broker group, cannot register worker!");
		ack= -1;
		reply= "Failed to initialize broker group, cannot register worker!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	//Register worker in brokers	
	Tango::GroupCmdReplyList cmd_reply;
	bool last_mode = Tango::GroupReply::enable_exception(true);
	
	try {
		Tango::DeviceData dd;
		dd << device_name;
		
		cmd_reply = m_brokerGroup->command_inout("RegisterWorker", dd);
	}//close try
	catch(Tango::DevFailed& e){
		WARN_LOG("Failed to initialize broker group, cannot register worker!");
		ack= -1;
		reply= "Failed to initialize broker group, cannot register worker!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	if (cmd_reply.has_failed()){
		WARN_LOG("At least one error occurred while registering this worker in the brokers, processing the responses...");
	}

	//Process responses in the list
	bool hasFailed= false; 
	int nErrors= 0;
	for (unsigned int k=0;k<cmd_reply.size();k++){
				
		try {
			//Extract the data from the k-th reply
			const Tango::DevVarLongStringArray* out;
			cmd_reply[k] >> out;

			//Check ack code
			if(out->svalue.length()<=0 || out->lvalue.length()<=0){
				throw std::runtime_error("Empty response vector");
			}			
			Tango::DevLong ack_code= (out->lvalue)[0];
			std::string msg_info= std::string(out->svalue[0]);
			if(ack_code!=0){
				throw std::runtime_error(msg_info);
			}

		}//close try block
		catch (const Tango::DevFailed& e) {
			nErrors++;
			ERROR_LOG("Exception while getting response data from "<<k<<" group device "<<cmd_reply[k].dev_name()<<", printing errors...");		
			for (unsigned int err = 0; err < e.errors.length(); err++) {
				ERROR_LOG("Error: " << e.errors[err].desc.in());
			}
			hasFailed= true;
		}
		catch (const std::exception& e) {
			nErrors++;
			ERROR_LOG("C++ exception while getting response data from "<<k<<" group device "<<cmd_reply[k].dev_name()<<" (err="<<e.what()<<")");		
			hasFailed= true;
		}
		catch (...) {
			nErrors++;
			ERROR_LOG("Unknown exception while getting response data from "<<k<<" group device "<<cmd_reply[k].dev_name());		
			hasFailed= true;
		}

	}//end loop replies	

	if(hasFailed){
		ack= -1;
		std::stringstream errMsg;
		errMsg<<nErrors<<" occurred on group responses";
		reply= errMsg.str();
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	//Return reply
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());

	/*----- PROTECTED REGION END -----*/	//	SFinder::register_me
	return argout;
}
//--------------------------------------------------------
/**
 *	Command Free related method
 *	Description: Free worker (aborting all running tasks)
 *
 */
//--------------------------------------------------------
void SFinder::free()
{
	DEBUG_STREAM << "SFinder::Free()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::free) ENABLED START -----*/
	
	//	Add your own code
	//Free resource for use
	m_WorkerThread->Stop();
	UpdateState(Tango::ON,"Force free resource");

	return;

	
	/*----- PROTECTED REGION END -----*/	//	SFinder::free
}
//--------------------------------------------------------
/**
 *	Command Reserve related method
 *	Description: Reserve resource
 *
 */
//--------------------------------------------------------
void SFinder::reserve()
{
	DEBUG_STREAM << "SFinder::Reserve()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::reserve) ENABLED START -----*/
	
	//	Add your own code
	UpdateState(Tango::INIT,"Reserve worker");
	
	return;

	/*----- PROTECTED REGION END -----*/	//	SFinder::reserve
}
//--------------------------------------------------------
/**
 *	Method      : SFinder::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinder::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(SFinder::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::add_dynamic_commands
}

/*----- PROTECTED REGION ID(SFinder::namespace_ending) ENABLED START -----*/



int SFinder::InitBrokerGroup(){

	//Clear existing group
	if(m_brokerGroup){
		delete m_brokerGroup;
		m_brokerGroup= 0;
	}
	
	//Create a group
	try {
		m_brokerGroup = new Tango::Group("brokers");
		for(unsigned int i=0;i<brokerList.size();i++){
			m_brokerGroup->add(brokerList[i]);
		}//end loop brokers
	
	}//close try block
	catch(Tango::DevFailed& e){
		ERROR_LOG("Failed to create the broker group!");
		return -1;
	}

	return 0;

}//close InitBrokerGroup()


int SFinder::LoadDefaultConfig(){
	
	//Set default values in attributes (to be called in init_device method)
	//They will be overwritten after init_device completes with memorized DB values (if any)
	
	*attr_sourceData_read= CORBA::string_dup("");

	//--> Bkg options
	attr_useLocalBkg_write= useLocalBkg_default;
	attr_use2ndPassInLocalBkg_write= use2ndPassInLocalBkg_default;
	attr_skipOutliersInLocalBkg_write= skipOutliersInLocalBkg_default;
	attr_skipNegativePixels_write= skipNegativePixels_default;
	attr_localBkgMethod_write= localBkgMethod_default;
	attr_bkgEstimator_write= bkgEstimator_default;
	attr_useBeamInfoInBkg_write= useBeamInfoInBkg_default;
	attr_localBkgBoxSizeX_write= localBkgBoxSizeX_default;
	attr_localBkgBoxSizeY_write= localBkgBoxSizeY_default;
	attr_localBkgGridStepSizeX_write= localBkgGridStepSizeX_default;
	attr_localBkgGridStepSizeY_write= localBkgGridStepSizeY_default;

	//--> Source finding options
	attr_searchCompactSources_write= searchCompactSources_default;
	attr_seedThr_write= seedThr_default;
	attr_mergeThr_write= mergeThr_default;
	attr_minNPix_write= minNPix_default;
	attr_mergeBelowSeed_write= mergeBelowSeed_default;
	attr_searchNegativeExcess_write= searchNegativeExcess_default;

	//--> Nested source search
	attr_searchNestedSources_write= searchNestedSources_default;
	attr_nestedBlobThrFactor_write= nestedBlobThrFactor_default;

	//--> Source selection
	attr_selectCompactSources_write= selectCompactSources_default;
	attr_useCircRatioCut_write= useCircRatioCut_default;
	attr_psCircRatioThr_write= psCircRatioThr_default;
	attr_useElongCut_write= useElongCut_default;
	attr_psElongThr_write= psElongThr_default;
	attr_useEllipseAreaRatioCut_write= useEllipseAreaRatioCut_default;
	attr_psEllipseAreaRatioMinThr_write= psEllipseAreaRatioMinThr_default;
	attr_psEllipseAreaRatioMaxThr_write= psEllipseAreaRatioMaxThr_default;
	attr_useMaxNPixCut_write= useMaxNPixCut_default;
	attr_psMaxNPix_write= psMaxNPix_default;
	attr_useBoundingBoxCut_write= useBoundingBoxCut_default;
	attr_minBoundingBoxThr_write= minBoundingBoxThr_default;

	return 0;

}//close LoadDefaultConfig()


int SFinder::ApplyConfig(std::string& config){

	if(config=="") return -1;
	
	//## Set INIT state
	UpdateState(Tango::INIT,"Configuring options...");
	
	//## Parse config json options
	Json::Reader reader;
	Json::Value root;
  if(!reader.parse(config, root)) {
		ERROR_LOG("Failed to parse config JSON ("<<reader.getFormattedErrorMessages()<<")");
		UpdateState(get_prev_state(),"Configuration completed");
		return -1;
	}
	
	//## Check top json
	if(root.isNull() || root.empty()){
		ERROR_LOG("Failed to parse config JSON (null or empty)!");
		UpdateState(get_prev_state(),"Configuration completed");
		return -1;
	}

	//Get option array 
	Json::Value optionList= root["options"];
	if(optionList.isNull() || optionList.empty() || !optionList.isArray() ){
		ERROR_LOG("Failed to parse config JSON option list (null/empty or not an array)!");
		UpdateState(get_prev_state(),"Configuration completed");
		return -1;
	}
	
	//## Loop over options
	unsigned int nOptions= optionList.size();
	int nConfiguredAttrs= 0;
	for(unsigned int i=0;i<nOptions;i++){
		if(SetAttrFromConfig(optionList[i])<0){
			continue;
		}
		nConfiguredAttrs++;
	}//end loop options

	INFO_LOG("#"<<nConfiguredAttrs<<" attribute configured...");

	//## Reset previous state (e.g. ON if a Configuration task was issued, or RUNNING if the config task was issued by the FindSource command)
	UpdateState(get_prev_state(),"Configuration completed");

	return 0;

}//close ApplyConfig()

int SFinder::UpdateState(Tango::DevState state,const std::string statusMsg){

	//Check input state
	if(state!=Tango::INIT && state!=Tango::RUNNING && state!=Tango::ON){
		WARN_LOG("Invalid state given (state="<<state<<")");
		return -1;
	}
	
	//Set state
	set_state(state);	
	set_status(statusMsg.c_str()); 
	try{
		DEBUG_LOG("Pushing change event for device "<<device_name<<"...");
		push_change_event	("State");
	}
	catch(Tango::DevFailed& e){
		WARN_LOG("Failed to push change event on State attribute");
		return -1;
	}

	return 0;
	
}//close UpdateState()


int SFinder::SetAttrFromConfig(Json::Value& optionObj){

	Json::Value optionNameObj= optionObj["name"];
	Json::Value optionValueObj= optionObj["value"];
	if(optionNameObj.isNull() || optionValueObj.isNull()){
		return -1;			
	}
	std::string option_name= optionNameObj.asString();
	DEBUG_LOG("Option Name: "<<option_name);

	//Search attribute with option name
	try {
		Tango::WAttribute& attr= get_device_attr()->get_w_attr_by_name(option_name.c_str());
		std::string attr_name= attr.get_name();
 		long attr_type= attr.get_data_type();
		Tango::AttrDataFormat attr_format= attr.get_data_format();

		DEBUG_LOG("Attr Name/type: "<<attr_name<<"/"<<attr_type);
		
		if(attr_format==Tango::SCALAR && SetScalarAttrValue(attr,optionObj)<0){
			std::stringstream errMsg;
			errMsg<<"Failed to set scalar attr ("<<attr_name<<")";
			throw std::runtime_error(errMsg.str().c_str());
		}
		if(attr_format==Tango::SPECTRUM && SetSpectrumAttrValue(attr,optionObj)<0){
			std::stringstream errMsg;
			errMsg<<"Failed to set spectrum attr ("<<attr_name<<")";
			throw std::runtime_error(errMsg.str().c_str());
		}
		if(attr_format==Tango::IMAGE){
			std::stringstream errMsg;
			errMsg<<"Failed to set image attr ("<<attr_name<<")";
			throw std::runtime_error(errMsg.str().c_str());
		}
				
	}//close try block
	catch(Tango::DevFailed& e){
		WARN_LOG("No attribute found with given option name ("<<option_name<<"), skip it!");
		return -1;
	}
	catch(std::exception& e){
		WARN_LOG("C++ exception (err="<<e.what()<<")!");
		return -1;
	}

	return 0;

}//close SetAttrFromConfig()

int SFinder::SetScalarAttrValue(Tango::WAttribute& attr,Json::Value& optionObj){

	Json::Value optionNameObj= optionObj["name"];
	Json::Value optionValueObj= optionObj["value"];

	std::string attr_name= attr.get_name();
 	long attr_type= attr.get_data_type();
	
	try {
		
		if(attr_type==Tango::DEV_SHORT) {
			Tango::DevShort attr_val= static_cast<Tango::DevShort>(optionValueObj.asInt());
			attr.set_write_value(attr_val);
			attr.set_value(&attr_val);
		}
		else if(attr_type==Tango::DEV_USHORT){
			Tango::DevUShort attr_val= static_cast<Tango::DevUShort>(optionValueObj.asUInt());
			attr.set_write_value(attr_val);
			attr.set_value(&attr_val);
		}
		else if(attr_type==Tango::DEV_LONG){
			Tango::DevLong attr_val= optionValueObj.asInt();
			attr.set_write_value(attr_val);
			attr.set_value(&attr_val);
		}
		else if(attr_type==Tango::DEV_ULONG){
			Tango::DevULong attr_val= optionValueObj.asUInt();
			attr.set_write_value(attr_val);
			attr.set_value(&attr_val);
		}
		else if(attr_type==Tango::DEV_DOUBLE){ 
			double attr_val= optionValueObj.asDouble();
			attr.set_write_value(attr_val);
			attr.set_value(&attr_val);
		}
		else if(attr_type==Tango::DEV_FLOAT){ 
			float attr_val= optionValueObj.asFloat();
			attr.set_write_value(attr_val);
			attr.set_value(&attr_val);
		}
		else if(attr_type==Tango::DEV_STRING){ 
			std::string attr_val= optionValueObj.asString();
			Tango::DevString attr_read_val= CORBA::string_dup(attr_val.c_str());
			attr.set_write_value(attr_val);
			attr.set_value(&attr_read_val);
		}
		else if(attr_type==Tango::DEV_BOOLEAN){
			bool attr_val= optionValueObj.asBool();
			attr.set_write_value(attr_val);
			attr.set_value(&attr_val);
		}
		else{		
			std::stringstream errMsg;
			errMsg<<"Unsupported data type ("<<attr_type<<")";
			throw std::runtime_error(errMsg.str().c_str());
		}
		
	}//close try block
	catch(Tango::DevFailed& e){
		WARN_LOG("Failed to set attribute value (attr="<<attr_name<<" type="<<attr_type<<")!");
		return -1;
	}
	catch(std::exception& e){
		WARN_LOG("Failed to set attribute value (attr="<<attr_name<<" type="<<attr_type<<"), err="<<e.what()<<"!");
		return -1;
	}

	return 0;

}//close SetScalarAttrValue()


int SFinder::SetSpectrumAttrValue(Tango::WAttribute& attr,Json::Value& optionObj){

	Json::Value optionNameObj= optionObj["name"];
	Json::Value optionValueObj= optionObj["value"];
	if(!optionValueObj.isArray()){
		WARN_LOG("Failed to set attribute value (given option value is not an array)!");
		return -1;
	}

	std::string attr_name= attr.get_name();
 	long attr_type= attr.get_data_type();

	try {
		
		if(attr_type==Tango::DEV_SHORT) {//DEV_SHORT
			std::vector<Tango::DevShort> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				Tango::DevShort thisAttrVal= static_cast<Tango::DevShort>(optionValueObj[i].asInt());
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);
		}
		else if(attr_type==Tango::DEV_USHORT){//DEV_USHORT
			std::vector<Tango::DevUShort> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				Tango::DevUShort thisAttrVal= static_cast<Tango::DevUShort>(optionValueObj[i].asUInt());
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);
		}
		else if(attr_type==Tango::DEV_LONG){//DEV_LONG
			std::vector<Tango::DevLong> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				Tango::DevLong thisAttrVal= static_cast<Tango::DevLong>(optionValueObj[i].asInt());
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);
		}
		else if(attr_type==Tango::DEV_ULONG){//DEV_ULONG
			std::vector<Tango::DevULong> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				Tango::DevULong thisAttrVal= static_cast<Tango::DevULong>(optionValueObj[i].asUInt());
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);		
		}
		else if(attr_type==Tango::DEV_DOUBLE){ 
			std::vector<double> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				double thisAttrVal= optionValueObj[i].asDouble();
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);		
		}
		else if(attr_type==Tango::DEV_FLOAT){ 
			std::vector<float> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				double thisAttrVal= optionValueObj[i].asFloat();
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);
		}
		else if(attr_type==Tango::DEV_STRING){ 
			std::vector<std::string> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				std::string thisAttrVal= optionValueObj[i].asString();
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);	
		}
		else if(attr_type==Tango::DEV_BOOLEAN){
			std::vector<bool> attr_val;
			for(unsigned int i=0;i<optionValueObj.size();i++){
				bool thisAttrVal= optionValueObj[i].asBool();
				attr_val.push_back(thisAttrVal);
			}
			attr.set_write_value(attr_val);	
		}
		else{		
			std::stringstream errMsg;
			errMsg<<"Unsupported data type ("<<attr_type<<")";
			throw std::runtime_error(errMsg.str().c_str());
		}
		
	}//close try block
	catch(Tango::DevFailed& e){
		WARN_LOG("Failed to set attribute value (attr="<<attr_name<<" type="<<attr_type<<")!");
		return -1;
	}
	catch(std::exception& e){
		WARN_LOG("Failed to set attribute value (attr="<<attr_name<<" type="<<attr_type<<"), err="<<e.what()<<"!");
		return -1;
	}

	
	return 0;

}//close SetSpectrumAttrValue()


/*----- PROTECTED REGION END -----*/	//	SFinder::namespace_ending
} //	namespace
