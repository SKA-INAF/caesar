actread.c: *** Copyright (C) 1999-2007
actread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
actread.c:/* ACTREAD -- Read USNO ACT Star Catalog stars from CDROM */
actread.c:double	ddec;		/* Search half-width in declination in degrees */
actread.c:	magsort = sortmag - 1;
actread.c:    star->num = 0.0;
actread.c:	printf ("----------	------------	------------	");
actread.c:	printf ("-----	-----	------	------	------\n");
actread.c:		magv = star->xmag[0];
actread.c:		magb = star->xmag[1];
actread.c:		mag = star->xmag[magsort];
actread.c:		    rapm = star->rapm;
actread.c:		    decpm = star->decpm;
actread.c:		    ra = star->ra;
actread.c:		    dec = star->dec;
actread.c:		    num = (double) rlist[ireg] + (star->num / 100000.0);
actread.c:			     nstar,jstar,starcat->nstars);
actread.c:	    ntot = ntot + starcat->nstars;
actread.c:		 	 ireg+1,nreg,nstar,jstar,starcat->nstars,rlist[ireg]);
actread.c:/* ACTRNUM -- Read HST Guide Star Catalog stars from CDROM */
actread.c:    star->num = 0.0;
actread.c:	snum = (int) (((gnum[jstar] - (double)rnum) * 100000.0) + 0.01);
actread.c:	sysref = starcat->coorsys;
actread.c:	eqref = starcat->equinox;
actread.c:	epref = starcat->epoch;
actread.c:	num = star->num;
actread.c:	ra = star->ra;
actread.c:	dec = star->dec;
actread.c:	rapm = star->rapm;
actread.c:	decpm = star->decpm;
actread.c:	mag = star->xmag[0];
actread.c:	magb = star->xmag[1];
actread.c:/* ACTBIN -- Fill FITS WCS image with USNO ACT Star Catalog stars */
actread.c:    double ddec;	/* Search half-width in declination in degrees */
actread.c:	magsort = sortmag - 1;
actread.c:    sysout = wcs->syswcs;
actread.c:    eqout = wcs->equinox;
actread.c:    epout = wcs->epoch;
actread.c:    star->num = 0.0;
actread.c:		num = star->num;
actread.c:		magv = star->xmag[0];
actread.c:		magb = star->xmag[1];
actread.c:		mag = star->xmag[magsort];
actread.c:		    rapm = star->rapm;
actread.c:		    decpm = star->decpm;
actread.c:		    ra = star->ra;
actread.c:		    dec = star->dec;
actread.c:			    flux = magscale * exp (logt * (-mag / 2.5));
actread.c:			     nstar,jstar,starcat->nstars);
actread.c:	    ntot = ntot + starcat->nstars;
actread.c:		 	 ireg+1,nreg,nstar,jstar,starcat->nstars,rlist[ireg]);
actread.c:/* ACTREG -- from RA and Dec ranges, figure out which ACT files to search
actread.c:	if (ra1 >= reghour[ir-1] && ra1 <= reghour[ir]) {
actread.c:	    ir1 = ir - 1;
actread.c:	if (ra2 >= reghour[ir-1] && ra2 <= reghour[ir]) {
actread.c:	    ir2 = ir - 1;
actread.c:	fprintf (stderr,"ACTREG: RA: %.5f - %.5f, Dec: %.5f - %.5f\n",
actread.c:/* ACTOPEN -- Open ACT catalog region file, returning number of entries */
actread.c:    sc->byteswapped = 0;
actread.c:    sc->nbent = 161;
actread.c:    sc->nstars = lfile / sc->nbent;
actread.c:	strcpy (sc->isfil, actfile);
actread.c:	strncpy (sc->isfil, actfile, 23);
actread.c:    sc->inform = 'J';
actread.c:    sc->coorsys = WCS_J2000;
actread.c:    sc->epoch = 2000.0;
actread.c:    sc->equinox = 2000.0;
actread.c:    sc->ifcat = fcat;
actread.c:    sc->sptype = 2;
actread.c:    /* ACT region files are all RA-sorted */
actread.c:    sc->rasorted = 1;
actread.c:    fclose (sc->ifcat);
actread.c:/* ACTSRA -- Find star closest to given RA in ACT catalog file */
actread.c:	rax = dra - 360.0;
actread.c:	ramin = st->ra;
actread.c:    ismax = sc->nstars;
actread.c:	ramax = st->ra;
actread.c:    istarx = sc->nstars / 2;
actread.c:	if (st->ra < rax) {
actread.c:	    ramin = st->ra;
actread.c:	    if (ismax - istarx > 1)
actread.c:		istarx = istarx + (ismax - istarx) / 2;
actread.c:	    else if (ismax - istarx > 0)
actread.c:	else if (st->ra > rax) {
actread.c:	    ramax = st->ra;
actread.c:	    if (istarx - ismin > 1)
actread.c:		istarx = istarx - ((istarx - ismin) / 2);
actread.c:	    else if (istarx - ismin > 0)
actread.c:		istarx = istarx - 1;
actread.c:	    ra2str (rastr, 16, st->ra, 3);
actread.c:	    fprintf (stderr,"%9d: %s -> %s  %9d: %s  %9d: %s\n",
actread.c:/* ACTSTAR -- Get ACT catalog entry for one star;
actread.c:    if (sc->ifcat == NULL)
actread.c:    if (istar > sc->nstars) {
actread.c:		 istar, sc->nstars);
actread.c:	offset = (istar - 1) * sc->nbent;
actread.c:	if (fseek (sc->ifcat, offset, SEEK_SET))
actread.c:    if ((nbr = fread (line, sc->nbent, 1, sc->ifcat)) > sc->nbent) {
actread.c:		 nbr, sc->nbent, sc->isfil);
actread.c:    st->num = (double) istar;
actread.c:    st->ra = hrdeg ((double)irh + ((double)irm)/60.0 + rs / 3600.0);
actread.c:    st->dec = (double) idd + ((double)idm) / 60.0 + ds / 3600.0;
actread.c:    if (dsgn == '-') st->dec = -st->dec;
actread.c:    st->rapm = hrdeg (atof (line+28)) / 3600.0;
actread.c:    st->decpm = atof (line+36) / 3600.0;
actread.c:    /* Set V, B, B-V magnitudes */
actread.c:    st->xmag[0] = atof (line+75);
actread.c:    st->xmag[1] = atof (line+68);
actread.c:    st->xmag[2] = atof (line+82);
actread.c:    st->isp[0] = (char) 0;
actread.c:    st->isp[1] = (char) 0;
actread.c:/* ACTSIZE -- return size of one ACT catalog file in bytes */
actread.c:	return (-1);
actread.c:	filesize = -1;
actread.c: * Sep 25 2000	Set sc->sptype to 2 to indicate presence of spectral type
actread.c: * Dec  1 2003	Add missing tab to n=-1 header
ang2str.c:	ra = -ra;
ang2str.c:	dsgn = -1.0;
ang2str.c:    b =  (a - (double)hours) * 60.0;
ang2str.c:    seconds = (b - (double)minutes) * 60.0;
ang2str.c:    if (ltstr < lstr-1)
ang2str.c:	strncpy (string, tstring, lstr-1);
ang2str.c:	string[lstr-1] = 0;
ang2str.c:    /* Keep angle between -180 and 360 degrees */
ang2str.c:	deg1 = -deg1;
ang2str.c:	dsgn = -1.0;
ang2str.c:    if (deg1 <= -180.0)
ang2str.c:	sign = '-';
ang2str.c:	a = -a;
ang2str.c:    b =  (a - (double)degrees) * 60.0;
ang2str.c:    seconds = (b - (double)minutes) * 60.0;
ang2str.c:    if (ltstr < lstr-1)
ang2str.c:	strncpy (string, tstring, lstr-1);
ang2str.c:	string[lstr-1] = 0;
ang2str.c:    /* Keep angle between -180 and 360 degrees */
ang2str.c:	deg1 = -deg1;
ang2str.c:	dsgn = -1.0;
ang2str.c:    if (deg1 <= -180.0)
ang2str.c:    if (ltstr < lstr-1)
ang2str.c:	strncpy (string, tstring, lstr-1);
ang2str.c:	string[lstr-1] = 0;
ang2str.c:/* Write the variable a in decimal format into field-character string  */
binread.c: *** Harvard-Smithsonian Center for Astrophysics
binread.c: *** Copyright (C) 1998-2011
binread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
binread.c:/* BINREAD -- Read binary catalog sources + names in specified region */
binread.c:double	ddec;		/* Search half-width in declination in degrees */
binread.c:double	**tmag;		/* 2-D Array of magnitudes (returned) */
binread.c:    int nmag;		/* Real number of magnitudes per entry (- rv) */
binread.c:    if (sc->caturl != NULL) {
binread.c:	strcpy (str, sc->caturl);
binread.c:    if (sc->nstars <= 0) {
binread.c:    if (sortmag > 0 && sortmag <= sc->nmag)
binread.c:	magsort = sortmag - 1;
binread.c:    sysref = sc->coorsys;
binread.c:    eqref = sc->equinox;
binread.c:    epref = sc->epoch;
binread.c:	fprintf (stderr,"BINREAD: RA: %s - %s  Dec: %s - %s %s\n",
binread.c:    if (sc->entrv > 0) {
binread.c:	nmag = sc->nmag - 1;
binread.c:	nmag = sc->nmag;
binread.c:    star->num = 0.0;
binread.c:	if (sc->rasorted) {
binread.c:	    istar1 = sc->star1;
binread.c:	    istar2 = sc->star0 + sc->nstars;
binread.c:	    num = star->num;
binread.c:	    if (sc->entmag[0] > 0)
binread.c:		mag = star->xmag[magsort];
binread.c:		rapm = star->rapm;
binread.c:		decpm = star->decpm;
binread.c:		ra = star->ra;
binread.c:		dec = star->dec;
binread.c:		if (sc->entrv > 0)
binread.c:		    star->xmag[mrv] = star->radvel;
binread.c:		isp = (1000 * (int) star->isp[0]) + (int)star->isp[1];
binread.c:		    if (sc->mprop == 1) {
binread.c:		    for (imag = 0; imag < sc->nmag; imag++) {
binread.c:			    tmag[imag][nstar] = star->xmag[imag];
binread.c:		    if (sc->ncobj > 0 && tobj != NULL) {
binread.c:			lname = strlen (star->objname) + 1;
binread.c:			strcpy (objname, star->objname);
binread.c:			if (sc->mprop == 1) {
binread.c:			for (imag = 0; imag < sc->nmag; imag++) {
binread.c:				tmag[imag][farstar] = star->xmag[imag];
binread.c:			if (sc->ncobj > 0 && tobj != NULL) {
binread.c:			    lname = strlen (star->objname) + 1;
binread.c:			    strcpy (objname, star->objname);
binread.c:		    if (sc->mprop == 1) {
binread.c:		    for (imag = 0; imag < sc->nmag; imag++) {
binread.c:			    tmag[imag][faintstar] = star->xmag[imag];
binread.c:		    if (sc->ncobj > 0 && tobj != NULL) {
binread.c:			lname = strlen (star->objname) + 1;
binread.c:			strcpy (objname, star->objname);
binread.c:			jstar,istar,sc->nstars,bincat);
binread.c:		 bincat,jstar,istar,sc->nstars);
binread.c:/* BINRNUM -- Read binary catalog stars with specified numbers */
binread.c:double	**tmag;		/* 2-D Array of magnitudes (returned) */
binread.c:    if (starcat->caturl != NULL) {
binread.c:	strcpy (str, starcat->caturl);
binread.c:    if (starcat->nstars <= 0) {
binread.c:    sysref = starcat->coorsys;
binread.c:    eqref = starcat->equinox;
binread.c:    epref = starcat->epoch;
binread.c:    star->num = 0.0;
binread.c:    if (starcat->entrv > 0) {
binread.c:	nmag = starcat->nmag - 1;
binread.c:	nmag = starcat->nmag;
binread.c:	    while (istar <= starcat->nstars) {
binread.c:		    for (imag = 0; imag < starcat->nmag; imag++)
binread.c:		if (star->num == tnum[jnum])
binread.c:	    if (star->num != tnum[jnum])
binread.c:	    for (imag = 0; imag < starcat->nmag; imag++)
binread.c:	num = star->num;
binread.c:	ra = star->ra;
binread.c:	dec = star->dec;
binread.c:	rapm = star->rapm;
binread.c:	decpm = star->decpm;
binread.c:	isp = (1000 * (int) star->isp[0]) + (int)star->isp[1];
binread.c:	if (starcat->mprop == 1) {
binread.c:	if (starcat->entrv > 0)
binread.c:	    tmag[mrv][nstar] = star->radvel;
binread.c:		    tmag[imag][nstar] = star->xmag[imag];
binread.c:	if (starcat->ncobj > 0 && tobj != NULL) {
binread.c:	    lname = strlen (star->objname) + 1;
binread.c:	    strcpy (objname, star->objname);
binread.c:	    for (imag = 0; imag < starcat->nmag; imag++)
binread.c:	    fprintf (stderr," %s  \n", star->isp);
binread.c:		 bincat,nstar,starcat->nstars);
binread.c:/* BINBIN -- Fill FITS WCS image with stars from binary catalog */
binread.c:    double ddec;	/* Search half-width in declination in degrees */
binread.c:    int nmag;		/* Real number of magnitudes per entry (- rv) */
binread.c:    if (sc->nstars <= 0) {
binread.c:    if (sortmag > 0 && sortmag <= sc->nmag)
binread.c:	magsort = sortmag - 1;
binread.c:    sysout = wcs->syswcs;
binread.c:    eqout = wcs->equinox;
binread.c:    epout = wcs->epoch;
binread.c:    sysref = sc->coorsys;
binread.c:    eqref = sc->equinox;
binread.c:    epref = sc->epoch;
binread.c:	fprintf (stderr,"BINREAD: RA: %s - %s  Dec: %s - %s %s\n",
binread.c:    if (sc->entrv > 0) {
binread.c:	nmag = sc->nmag - 1;
binread.c:	nmag = sc->nmag;
binread.c:    star->num = 0.0;
binread.c:	if (sc->rasorted) {
binread.c:	    istar1 = sc->star1;
binread.c:	    istar2 = sc->star0 + sc->nstars;
binread.c:	    num = star->num;
binread.c:	    if (sc->entmag[0] > 0)
binread.c:		mag = star->xmag[magsort];
binread.c:		rapm = star->rapm;
binread.c:		decpm = star->decpm;
binread.c:		ra = star->ra;
binread.c:		dec = star->dec;
binread.c:			flux = magscale * exp (logt * (-mag / 2.5));
binread.c:			jstar,istar,sc->nstars,bincat);
binread.c:		 bincat,jstar,istar,sc->nstars);
binread.c:/* BINOPEN -- Open binary catalog, returning number of entries */
binread.c:		sc->caturl = str;
binread.c:		sc->caturl = str;
binread.c:		sc->caturl = str;
binread.c:		sc->caturl = str;
binread.c:		sc->caturl = str;
binread.c:	    sc->caturl = str;
binread.c:    if (sc->caturl != NULL) {
binread.c:	sc->coorsys = 0;
binread.c:	sc->epoch = 0.0;
binread.c:	sc->equinox = 0.0;
binread.c:	   sc->mprop = 1;
binread.c:	   sc->mprop = 0;
binread.c:    if (sc->nbent > 80) {
binread.c:	sc->byteswapped = 1;
binread.c:	binswap4 (&sc->star0);
binread.c:	binswap4 (&sc->star1);
binread.c:	binswap4 (&sc->nstars);
binread.c:	binswap4 (&sc->stnum);
binread.c:	binswap4 (&sc->mprop);
binread.c:	binswap4 (&sc->nmag);
binread.c:	binswap4 (&sc->nbent);
binread.c:	sc->byteswapped = 0;
binread.c:    sc->catline = (char *) calloc (sc->nbent, sizeof (char));
binread.c:    sc->ncobj = 0;
binread.c:    if (sc->stnum < 0)
binread.c:	sc->ncobj = -sc->stnum;
binread.c:    else if (sc->stnum > 0)	
binread.c:    sc->entra = nb;
binread.c:    sc->entdec = nb + 8;
binread.c:    sc->entpeak = nb + 16;
binread.c:    if (sc->nmag < 0) {
binread.c:	sc->inform = 'J';
binread.c:	sc->coorsys = WCS_J2000;
binread.c:	sc->epoch = 2000.0;
binread.c:	sc->equinox = 2000.0;
binread.c:	sc->nmag = -sc->nmag;
binread.c:    else if (sc->nstars < 0) {
binread.c:	sc->inform = 'J';
binread.c:	sc->coorsys = WCS_J2000;
binread.c:	sc->epoch = 2000.0;
binread.c:	sc->equinox = 2000.0;
binread.c:	sc->nstars = -sc->nstars;
binread.c:	sc->inform = 'B';
binread.c:	sc->coorsys = WCS_B1950;
binread.c:	sc->epoch = 1950.0;
binread.c:	sc->equinox = 1950.0;
binread.c:    if (sc->nmag > 0)
binread.c:	sc->entmag[0] = nb + 18;
binread.c:	sc->entmag[0] = 0;
binread.c:    nb = nb + 18 + (sc->nmag * 2);
binread.c:    if (sc->mprop == -1)
binread.c:	sc->mprop = 1;
binread.c:    if (sc->mprop == 1) {
binread.c:	sc->entrpm = nb;
binread.c:	sc->entdpm = nb + 4;
binread.c:    else if (sc->mprop == 2) {
binread.c:	sc->entrv = nb;
binread.c:    if (sc->ncobj)
binread.c:	sc->entname = nb;
binread.c:    if (sc->stnum == 2)
binread.c:	sc->nndec = 4;
binread.c:    else if (sc->stnum == 3)
binread.c:	sc->nndec = 5;
binread.c:	sc->nndec = 0;
binread.c:    strcpy (sc->incdir, bindir);
binread.c:    strcpy (sc->incfile, bincat);
binread.c:	strcpy (sc->isfil, binfile);
binread.c:	strncpy (sc->isfil, binfile, 23);
binread.c:    sc->entadd = fcat;
binread.c:    sc->sptype = 1;
binread.c:    if (sc->mprop == 2)
binread.c:	sc->nmag = sc->nmag + 1;
binread.c:    /* Check name to see if file is RA-sorted */
binread.c:    sc->rasorted = 0;
binread.c:    if (binfile[lf-2] == 'r' && binfile[lf-1] == 'a')
binread.c:	sc->rasorted = 1;
binread.c:	sc->rasorted = 1;
binread.c:    sc->refcat = BINCAT;
binread.c:    close (sc->entadd);
binread.c:    free ((void *)sc->catline);
binread.c:/* BINSRA -- Find star closest to given RA in RA-sorted catalog */
binread.c:	rax = dra - 360.0;
binread.c:	ramin = st->ra;
binread.c:    ismax = sc->nstars;
binread.c:	ramax = st->ra;
binread.c:    istarx = sc->nstars / 2;
binread.c:	if (st->ra < rax) {
binread.c:	    ramin = st->ra;
binread.c:	    if (ismax - istarx > 1)
binread.c:		istarx = istarx + (ismax - istarx) / 2;
binread.c:	    else if (ismax - istarx > 0)
binread.c:	else if (st->ra > rax) {
binread.c:	    ramax = st->ra;
binread.c:	    if (istarx - ismin > 1)
binread.c:		istarx = istarx - ((istarx - ismin) / 2);
binread.c:	    else if (istarx - ismin > 0)
binread.c:		istarx = istarx - 1;
binread.c:	    ra2str (rastr, 16, st->ra, 3);
binread.c:	    fprintf (stderr,"%9d: %s -> %s  %9d: %s  %9d: %s\n",
binread.c:/* BINSTAR -- Get binary catalog entry for one star;
binread.c:    if (sc->entadd < 3)
binread.c:    if (istar > sc->nstars) {
binread.c:		 istar, sc->nstars);
binread.c:	offset = 28 + (istar - sc->star1) * sc->nbent;
binread.c:	if (lseek (sc->entadd, offset, SEEK_SET) < offset)
binread.c:    if ((int)read (sc->entadd, sc->catline, sc->nbent) < 1)
binread.c:    sc->ncobj = 0;
binread.c:    if (sc->stnum <= 0) {
binread.c:	sc->ncobj = -sc->stnum;
binread.c:	movebuff (sc->catline, st->objname, sc->ncobj, sc->entname, 0);
binread.c:	movebuff (sc->catline, (char *) &st->xno, 4, 0, 0);
binread.c:	if (sc->byteswapped)
binread.c:	    binswap4 (&st->xno);
binread.c:    switch (sc->stnum) {
binread.c:	    st->num = (double) st->xno;
binread.c:	    memcpy ((char *) &ino, (char *)&st->xno, 4);
binread.c:	    st->num = 0.0001 * (double) ino;
binread.c:	    memcpy ((char *) &ino, (char *)&st->xno, 4);
binread.c:	    st->num = 0.00001 * (double) ino;
binread.c:	    memcpy ((char *) &ino, (char *)&st->xno, 4);
binread.c:	    st->num = (double) ino;
binread.c:		st->num = (double) istar;
binread.c:		st->num = st->num + 1.0;
binread.c:    movebuff (sc->catline, (char *) &st->ra, 8, sc->entra, 0);
binread.c:    movebuff (sc->catline, (char *) &st->dec, 8, sc->entdec, 0);
binread.c:    if (sc->byteswapped) {
binread.c:	binswap8 (&st->ra);
binread.c:	binswap8 (&st->dec);
binread.c:    st->ra = raddeg (st->ra);
binread.c:    st->dec = raddeg (st->dec);
binread.c:    nmag = sc->nmag;
binread.c:    if (sc->mprop == 1) {
binread.c:	movebuff (sc->catline, (char *) &pm[0], 4, sc->entrpm, 0);
binread.c:	movebuff (sc->catline, (char *) &pm[1], 4, sc->entdpm, 0);
binread.c:	if (sc->byteswapped) {
binread.c:	st->rapm = raddeg ((double) pm[0]);
binread.c:	st->decpm = raddeg ((double) pm[1]);
binread.c:    else if (sc->mprop == 2) {
binread.c:	movebuff (sc->catline, (char *) &radvel, 8, sc->entrv, 0);
binread.c:	if (sc->byteswapped)
binread.c:	st->radvel = radvel;
binread.c:	nmag = nmag - 1;
binread.c:    movebuff (sc->catline, (char *) st->isp, 2, sc->entpeak, 0);
binread.c:    if (sc->entmag[0] > 0) {
binread.c:	    movebuff (sc->catline, (char *) st->mag, 2, sc->entmag[0]+(i*2), i*2);
binread.c:	    if (sc->byteswapped)
binread.c:		binswap2 (&st->mag[i], 2);
binread.c:	    st->xmag[i] = 0.01 * (double) st->mag[i];
binread.c:/* BINSWAP2 -- Swap bytes in string in place */
binread.c:/* BINSWAP4 -- Reverse bytes of Integer*4 or Real*4 number in place */
binread.c:/* BINSWAP8 -- Reverse bytes of Real*8 vector in place */
binread.c:/* BINSIZE -- return size of binary catalog file in bytes */
binread.c:	return (-1);
binread.c:	filesize = -1;
binread.c:/* ISBIN -- Return 1 if TDC binary catalog file, else 0 */
binread.c: * Oct 21 1998	Fix binsra() to get out of 3-in-a-row identical RAs
binread.c: * Nov  9 1998	Add flag to catalog structure for RA-sorted catalogs
binread.c: * Sep 25 2000	Set sc->sptype to 1 to indicate presence of spectral type
binread.c: * Feb 14 2001	Correctly full-circle limits at poles
binread.c: * Aug  6 2002	Make sc->entmag into vector, but only use first position
binread.c: * Mar 11 2003	If proper motion flag is -1, reset it to 1
caphot.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
caphot.c:/* CAPHOT -- Perform rigorous circular aperture photometry using the imapfr()
caphot.c:    iy1 = (int) (cy - rad);
caphot.c:    ix1 = (int) (cx - rad);
caphot.c:/* IMAPFR -- Determine the fraction of a square pixel that is included
caphot.c:    dc = fabs (pcol - ccol);
caphot.c:    dr = fabs (prow - crow);
caphot.c:    dc5 = dc - 0.5;
caphot.c:    dr5 = dr - 0.5;
caphot.c:    if ((pcol-0.5) < ccol && ccol < (pcol+.5)) {
caphot.c:	else if ((prow - 0.5) < crow && crow < (prow + 0.5)) {
caphot.c:    y = prow - 1.5;
caphot.c:	x = pcol - 1.50;
caphot.c:	    dx = x - ccol;
caphot.c:	    dy = y - crow;
caphot.c:	if ((pcol - 0.5) >= ccol || ccol >= (pcol + 0.5)) {
caphot.c:	    xdiff = fabs (pcol - ccol) - 0.5;
caphot.c:	    dx = sqrt (rad*rad - xdiff*xdiff);
caphot.c:	    y0 = crow - dx;
caphot.c:		x = pcol - 0.5;
caphot.c:	    frac = -xdiff * (y1 - y0) + apint ((y1 - crow), rad) -
caphot.c:		   apint ((y0 - crow), rad);
caphot.c:	    ydiff = fabs (prow - crow) - 0.5;
caphot.c:	    dy = sqrt (rad*rad - ydiff*ydiff);
caphot.c:	    x0 = ccol - dy;
caphot.c:		y = prow - 0.5;
caphot.c:	    frac = -ydiff*(x1 - x0) + apint ((x1 - ccol),rad) -
caphot.c:		   apint ((x0 - ccol),rad);
caphot.c:	    ydiff = fabs (prow - crow) - 0.5;;
caphot.c:	    x0 = ccol - sqrt (rad*rad - ydiff*ydiff);
caphot.c:		y = prow - 0.5;
caphot.c:	    frac = -ydiff*(pcol + 0.5 - x0) + apint ((pcol + 0.5 - ccol),rad) -
caphot.c:		   apint ((x0 - ccol),rad);
caphot.c:	    ydiff = fabs (crow - prow) - 0.5;
caphot.c:	    x1 = ccol + sqrt (rad*rad - ydiff*ydiff);
caphot.c:		y = prow - 0.5;
caphot.c:	    frac = -ydiff*(x1 - pcol + 0.5) + apint ((x1 - ccol),rad) -
caphot.c:		   apint ((pcol - .5 - ccol),rad);
caphot.c:    /* determine whether this may be a 4-intersection configuration */
caphot.c:	if (((pcol - 0.5) < ccol && ccol < (pcol + .5) &&
caphot.c:	    (fabs(crow - prow) + 0.5) < rad) ||
caphot.c:	    ((prow - 0.5) < crow && crow < (prow + 0.5) &&
caphot.c:	    (fabs(ccol - pcol) + 0.5) < rad)) {
caphot.c:   determine whether the pixel is east-west or north-south. */
caphot.c:	    /* pixel is east-west */
caphot.c:	    if ((pcol - 0.5) >= ccol || (pcol + 0.5) <= ccol) {
caphot.c:		dx = sqrt (rad*rad - xdiff*xdiff);
caphot.c:		y0 = crow - dx;
caphot.c:		    x = pcol - .5;
caphot.c:		frac = 1. - xdiff*(y0 - y1 + 1.0) +
caphot.c:			apint ((y0 - crow), rad) -
caphot.c:			apint ((prow - 0.5 - crow), rad) +
caphot.c:			apint ((prow + 0.5 - crow), rad) -
caphot.c:			apint ((y1 - crow), rad);
caphot.c:	    /* Pixel is north-south */
caphot.c:		dy = sqrt (rad*rad - ydiff*ydiff);
caphot.c:		/* x0 is the x-coordinate of the small x intercept */
caphot.c:		x0 = ccol - dy;
caphot.c:		/* x1 is the x-coordinate of the large x intercept */
caphot.c:		    y = prow - 0.5;
caphot.c:		frac = 1. - ydiff * (x0 - x1 + 1.0) +
caphot.c:			apint ((x0 - ccol), rad) -
caphot.c:			apint ((pcol - 0.5 - ccol), rad) +
caphot.c:			apint ((pcol + 0.5 - ccol), rad) -
caphot.c:			apint ((x1 - ccol), rad);
caphot.c:	/* in the two-intersection case, determine which corners are included */
caphot.c:		cterm = 0.5 - dr;
caphot.c:		ulim = apint ((pcol + 0.5 - ccol) ,rad);
caphot.c:		llim = apint ((pcol - 0.5 - ccol) ,rad);
caphot.c:		frac = cterm + ulim - llim;
caphot.c:		cterm = 0.5 - dc;
caphot.c:		ulim = apint ((prow + 0.5 - crow), rad);
caphot.c:		llim = apint ((prow - 0.5 - crow), rad);
caphot.c:		frac = cterm + ulim - llim;
caphot.c:		y = prow - 0.5;
caphot.c:	    x0 = ccol + sqrt (rad*rad - ydiff*ydiff);
caphot.c:	    frac = 1.0 - (ydiff * (pcol + 0.5 - x0)) +
caphot.c:		   apint ((pcol + 0.5 - ccol), rad) -
caphot.c:		   apint ((x0 - ccol), rad);
caphot.c:		y = prow - 0.5;
caphot.c:	    x0 = ccol - sqrt (rad*rad - ydiff*ydiff);
caphot.c:	    frac = 1. - ydiff*(x0 - pcol + 0.5) +
caphot.c:		   apint ((x0 - ccol),rad) -
caphot.c:		   apint ((pcol - 0.5 - ccol),rad);
caphot.c:/* APINT -- Evaluate the integral of sqrt (rad**2 - x**2) dx at one limit */
caphot.c:    arcsin = atan2 (arg, sqrt (1.0 - arg2));
caphot.c:    if ((1. - fabs (arg)) < 0.000001) {
caphot.c:	    arcsin = -pi / 2.0;
caphot.c:    return (0.5 * (x * sqrt (rad2 - x2) + rad2 * arcsin));
caphot.c: * Jan  8 1993	Modify to handle arbitrary byte-per-pixel images
catutil.c: *** Harvard-Smithsonian Center for Astrophysics
catutil.c: *** Copyright (C) 1998-2013
catutil.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
catutil.c: *	Compute limiting RA and Dec from center and half-widths
catutil.c: *	Returns number of decimal places in a numeric string (-1=not number)
catutil.c: *	Compute limiting RA and Dec in new system from center and half-widths
catutil.c: *	Return next number from range structure as 4-byte integer
catutil.c: *	Return next number from range structure as 8-byte floating point number
catutil.c: *	approximate spectral type given B - V or B and V magnitudes
catutil.c: *	approximate spectral type given B - R or B and R magnitudes
catutil.c: *	Set version/date message for nstarmax=-1 returns from *read subroutines
catutil.c: *	Return version/date message for nstarmax=-1 returns from *read subroutines
catutil.c:	strcpy (title, "USNO-B1.0 Sources");
catutil.c:	strcpy (title, "USNO-YB6 Sources");
catutil.c:	    strcpy (title, "USNO SA-1.0 Catalog Stars");
catutil.c:	    strcpy (title, "USNO SA-2.0 Catalog Stars");
catutil.c:	    strcpy (title, "USNO A-1.0 Sources");
catutil.c:	    strcpy (title, "USNO A-2.0 Sources");
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *nmag = starcat->nmag;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *nmag = starcat->nmag;
catutil.c:	    *syscat = starcat->coorsys;
catutil.c:	    *eqcat = starcat->equinox;
catutil.c:	    *epcat = starcat->epoch;
catutil.c:	    *catprop = starcat->mprop;
catutil.c:	    *nmag = starcat->nmag;
catutil.c:	strcpy (catname, "GSC-ACT");
catutil.c:	strcpy (catname, "USNO-YB6");
catutil.c:	strcpy (catname, "USNO-A2.0");
catutil.c:	strcpy (catname, "USNO-SA2.0");
catutil.c:    else if (refcat ==  UA1)	/* USNO A-1.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-A1.0");
catutil.c:    else if (refcat ==  UB1)	/* USNO B-1.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-B1.0");
catutil.c:	strcpy (catname, "USNO-UCAC1");
catutil.c:	strcpy (catname, "USNO-UCAC2");
catutil.c:	strcpy (catname, "USNO-UCAC3");
catutil.c:	strcpy (catname, "USNO-UCAC4");
catutil.c:    else if (refcat ==  UA2)	/* USNO A-2.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-A2.0");
catutil.c:    else if (refcat ==  USA1)	/* USNO SA-1.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-SA1.0");
catutil.c:    else if (refcat ==  USA2)	/* USNO SA-2.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-SA2.0");
catutil.c:	     refcat == TYCHO2E)	/* Tycho-2 Star Catalog */
catutil.c:	strcpy (catname, "TYCHO-2");
catutil.c:	strcpy (catname, "GSC-ACT Stars");
catutil.c:	strcpy (catname, "USNO-YB6 Stars");
catutil.c:	strcpy (catname, "USNO-A2.0 Stars");
catutil.c:	strcpy (catname, "USNO-SA2.0 Stars");
catutil.c:    else if (refcat ==  TYCHO2)	/* Tycho-2 Star Catalog */
catutil.c:	strcpy (catname, "Tycho-2 Catalog Stars");
catutil.c:    else if (refcat == TYCHO2E)	/* Tycho-2 Star Catalog */
catutil.c:	strcpy (catname, "Tycho-2 Catalog Stars with mag error");
catutil.c:    else if (refcat ==  UA1)	/* USNO A-1.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-A1.0 Stars");
catutil.c:    else if (refcat ==  UB1)	/* USNO B-1.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-B1.0 Stars");
catutil.c:	strcpy (catname, "USNO-UCAC1 Stars");
catutil.c:	strcpy (catname, "USNO-UCAC2 Stars");
catutil.c:	strcpy (catname, "USNO-UCAC3 Stars");
catutil.c:	strcpy (catname, "USNO-UCAC4 Stars");
catutil.c:    else if (refcat ==  UA2)	/* USNO A-2.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-A2.0 Stars");
catutil.c:    else if (refcat ==  USA1)	/* USNO SA-1.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-SA1.0 Stars");
catutil.c:    else if (refcat ==  USA2)	/* USNO SA-2.0 Star Catalog */
catutil.c:	strcpy (catname, "USNO-SA2.0 Stars");
catutil.c:	strcpy (catname, "2MASS-IDR2 Point Sources");
catutil.c:    for (i = strlen (progpath); i > -1; i--) {
catutil.c:    /* USNO-B1.0  and USNO-YB6 */
catutil.c:    /* USNO-UCAC1 */
catutil.c:    /* USNO-UCAC2 */
catutil.c:    /* USNO-UCAC3 */
catutil.c:    /* USNO-UCAC4 */
catutil.c:		sprintf (numstr, "S%.0f", (-dnum + 0.01));
catutil.c:	    if (lnum < -nnfld) {
catutil.c:		for ( i = lnum; i < -nnfld; i++)
catutil.c:		sprintf (numstr, "S%.0f", (-dnum + 0.5));
catutil.c:    /* Starbase tab-separated, TDC binary, or TDC ASCII catalogs */
catutil.c:	    sprintf (nform,"%%0%d.%df", -nnfld, nndec);
catutil.c:	sprintf (nform,"%%0%dd", -nnfld);
catutil.c:    /* USNO-B1.0 and YB6 */
catutil.c:    /* Starbase tab-separated, TDC binary, or TDC ASCII catalogs */
catutil.c:    /* Starbase tab-separated, TDC binary, or TDC ASCII catalogs */
catutil.c:	return (-1);
catutil.c:	cmag = cmag - 32;
catutil.c:/* Return number of decimal places in numeric string (-1 if not number) */
catutil.c:	return (-1);
catutil.c:	    return (lstr - (cdot - string));
catutil.c:    fracpart = (int) (((number - floor (number)) * shift) + 0.5);
catutil.c:    for (ndec = ndmax; ndec > 0; ndec--) {
catutil.c:	if (nstring[ndec-1] != '0')
catutil.c:/* DateString-- Return string with epoch of position in desired format */
catutil.c:		sprintf (temp,"	0000-00-00");
catutil.c:		sprintf (temp," 0000-00-00");
catutil.c:/* SEARCHLIM-- Set RA and Dec limits for search given center and dimensions */
catutil.c:double	dra, ddec;	/* Horizontal and vertical half-widths in degrees */
catutil.c:    *ra1 = cra - dra;
catutil.c:	    *ra2 = *ra2 - 360.0;
catutil.c:    *dec1 = cdec - ddec;
catutil.c:	if (*dec1 < -90.0) {
catutil.c:	    *dec1 = -90.0;
catutil.c:	fprintf (stderr,"SearchLim: RA: %s - %s  Dec: %s - %s\n",
catutil.c:/* REFLIM-- Set limits in reference catalog coordinates given search coords */
catutil.c:double	dra, ddec;	/* Horizontal and vertical half-widths of area */
catutil.c:	*decmin = -90.0;
catutil.c:	    fprintf (stderr,"RefLim: RA: 0.0 - 360.0  Dec: -90.0 - 90.0\n");
catutil.c:    dec1 = cdec - ddec;
catutil.c:    if (dec1 < -90.0) {
catutil.c:	dec1 = -90.0 - (dec1 + 90.0);
catutil.c:	dec1 = -90.0;
catutil.c:	dec2 = 90.0 - (dec2 - 90.0);
catutil.c:    ra1 = cra - dra1;
catutil.c:	nrot = 1 - (int) (ra1 / 360.0);
catutil.c:	ra1 = ra1 - (360.0 * (double) nrot);
catutil.c:	nrot = 1 - (int) (ra2 / 360.0);
catutil.c:	ra2 = ra2 - (360.0 * (double) nrot);
catutil.c:	dmarg = (secmarg / 3600.0) * fabs (epc - epr);
catutil.c:	*ramin = *ramin - (dmarg * cos (degrad (cdec)));
catutil.c:	*decmin = *decmin - dmarg;
catutil.c:    else if (dec - dist < -90.0) {
catutil.c:	*decmin = -90.0;
catutil.c:    else if (*decmin < -90.0) {
catutil.c:	*decmin = -90.0;
catutil.c:	fprintf (stderr,"RefLim: RA: %s - %s  Dec: %s - %s",
catutil.c:/* RANGEINIT -- Initialize range structure from string */
catutil.c:char	*string;	/* String containing numbers separated by , and - */
catutil.c:    range->irange = -1;
catutil.c:    range->nvalues = 0;
catutil.c:    range->nranges = 0;
catutil.c:    range->valmax = -1000000000000.0;
catutil.c:    range->valmin = 1000000000000.0;
catutil.c:	 * Must be a number, '-', 'x', or EOS.  If not return ERR */
catutil.c:		range->ranges[0] = first;
catutil.c:		    range->ranges[1] = first;
catutil.c:		    range->ranges[1] = last;
catutil.c:		range->ranges[2] = step;
catutil.c:		range->nvalues = range->nvalues + 1 +
catutil.c:			  ((range->ranges[1]-range->ranges[0])/step);
catutil.c:		range->nranges++;
catutil.c:	    ip = slast - string;
catutil.c:	else if (strchr ("-:x", string[ip]) == NULL) {
catutil.c:	* Must be '-', or 'x' otherwise last = first */
catutil.c:	if (string[ip] == '-' || string[ip] == ':') {
catutil.c:		ip = slast - string;
catutil.c:		ip = slast - string;
catutil.c:	    else if (string[ip] != '-' && string[ip] != ':')
catutil.c:	range->ranges[irange*3] = first;
catutil.c:	range->ranges[irange*3 + 1] = last;
catutil.c:	range->ranges[irange*3 + 2] = step;
catutil.c:	range->nvalues = range->nvalues + ((last-first+(0.1*step)) / step + 1);
catutil.c:	range->nranges++;
catutil.c:	    if (first < range->valmin)
catutil.c:		range->valmin = first;
catutil.c:	    if (last > range->valmax)
catutil.c:		range->valmax = last;
catutil.c:	    if (first > range->valmax)
catutil.c:		range->valmax = first;
catutil.c:	    if (last < range->valmin)
catutil.c:		range->valmin = last;
catutil.c:/* ISRANGE -- Return 1 if string is a range, else 0 */
catutil.c:    else if (strchr (string+1, '-') || strchr (string+1, ',')) {
catutil.c:	    if (strchr ("0123456789-,.x", (int)string[i]) == NULL)
catutil.c:/* RSTART -- Restart at beginning of range */
catutil.c:    range->irange = -1;
catutil.c:/* RGETN -- Return number of values from range structure */
catutil.c:    return (range->nvalues);
catutil.c:/*  RGETR8 -- Return next number from range structure as 8-byte f.p. number */
catutil.c:    else if (range->irange < 0) {
catutil.c:	range->irange = 0;
catutil.c:	range->first = range->ranges[0];
catutil.c:	range->last = range->ranges[1];
catutil.c:	range->step = range->ranges[2];
catutil.c:	range->value = range->first;
catutil.c:	range->value = range->value + range->step;
catutil.c:	if (range->value > (range->last + (range->step * 0.5))) {
catutil.c:	    range->irange++;
catutil.c:	    if (range->irange < range->nranges) {
catutil.c:		i = range->irange * 3;
catutil.c:		range->first = range->ranges[i];
catutil.c:		range->last = range->ranges[i+1];
catutil.c:		range->step = range->ranges[i+2];
catutil.c:		range->value = range->first;
catutil.c:		range->value = 0.0;
catutil.c:    return (range->value);
catutil.c:/*  RGETI4 -- Return next number from range structure as 4-byte integer */
catutil.c:/* AGETI4 -- Get integer value from ASCII string where keyword=value anywhere */
catutil.c:/* AGETR8 -- Get double value from ASCII string where keyword=value anywhere */
catutil.c:/* AGETS -- Get keyword value from ASCII string with keyword=value anywhere */
catutil.c:		   if non-zero, replace blanks with underscores */
catutil.c:    strncpy (keyword,keyword0, sizeof(keyword)-1);
catutil.c:	if (pkey != string && *(pkey-1) > 32) {
catutil.c:	lastval = value - lval - 1;
catutil.c:	lastval = value + lval - 1;
catutil.c:	for (ival = value+lval-1; ival > value; ival--) {
catutil.c:double	*bv;	/* B-V Magnitude */
catutil.c:    double bmv;	/* B - V magnitude */
catutil.c:	bmv = b - v;
catutil.c:    if (bmv < -0.32) {
catutil.c:	im = 2 * (32 + (int)(bmv * 100.0 - 0.5));
catutil.c:double	*br;	/* B-R Magnitude */
catutil.c:    double bmr;	/* B - R magnitude */
catutil.c:	bmr = b - r;
catutil.c:    else if (bmr < -0.47) {
catutil.c:	im = 2 * (47 + (int)(bmr * 100.0 - 0.5));
catutil.c:int	tabout;		/* 1 if output is tab-delimited */
catutil.c:int	classd; 	/* GSC object class to accept (-1=all) */
catutil.c:    else if ((refcat == GSC || refcat == GSCACT) && classd < -1)
catutil.c:    strcpy (headline, "---------------------");
catutil.c:    strcat (headline,"	------------	------------");
catutil.c:	strcat (headline,"	-----	-----");
catutil.c:	strcat (headline,"	-----");
catutil.c:	strcat (headline,"	-----	----	-");
catutil.c:	strcat (headline,"	----");
catutil.c:	strcat (headline,"	-----");
catutil.c:	strcat (headline,"	-----");
catutil.c:	strcat (headline,"	-------	------");
catutil.c:	strcat (headline, "	------");
catutil.c:	strcat (headline,"	------");
catutil.c:	strcat (headline, "	-------	-------");
catutil.c:/* TMCID -- Return 1 if string is 2MASS ID, else 0 */
catutil.c:    sdec = strsrch (string, "-");
catutil.c:    printf ("<!DOCTYPE VOTABLE SYSTEM \"http://us-vo.org/xml/VOTable.dtd\">\n");
catutil.c:    printf ("<VOTABLE version=\"v1.1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n");
catutil.c:	printf ("  <DESCRIPTION>Tycho-2 Object Identifier</DESCRIPTION>\n");
catutil.c:	printf ("  <DESCRIPTION> Tycho-2 BT magnitude </DESCRIPTION>\n");
catutil.c:	printf ("  <DESCRIPTION> Tycho-2 VT magnitude </DESCRIPTION>\n");
catutil.c: *      y = a(1) + a(2)*(x-x0) + a(3)*(x-x0)**2 + a(3)*(x-x0)**3 + . . .
catutil.c:    nmax = 2 * nterms - 1;
catutil.c:	xi = x[i] - x0;
catutil.c:	sigma2sum = sigma2sum + ((y[i] - yi) * (y[i] - yi));
catutil.c:    *stdev = sqrt (sigma2sum / (double) (npts - 1));
catutil.c:/*--- Calculate the determinant of a square matrix
catutil.c:	    det = -det;
catutil.c:	if (k < norder - 1) {
catutil.c:		    array[i+j*norder] = array[i+j*norder] -
catutil.c:/* POLCOMP -- Polynomial evaluation
catutil.c:    x = xi - x0;
catutil.c:/* MOVEB -- Copy nbytes bytes from source+offs to dest+offd (any data type) */
catutil.c: * Nov 20 1998	Add USNO A-2.0 catalog and return different code
catutil.c: * May 22 2000	Add bv2sp() to approximate main sequence spectral type from B-V
catutil.c: * Sep 22 2000	Add br2sp() to approximate main sequence spectral type from B-R
catutil.c: * Mar 19 2001	Fix setting of ra-sorted PPM catalog in RefCat()
catutil.c: * May 22 2001	Add GSC-ACT catalog
catutil.c: * Jan 23 2003	Add USNO-B1.0 Catalog
catutil.c: * Oct  1 2003	Add code in RefLim() for all-sky images
catutil.c: * Oct  6 2003	Add code in RefLim() to cover near-polar searches
catutil.c: * Dec  4 2003	Implement GSC 2.3 and USNO-YB6
catutil.c: * May 18 2005	Change Tycho-2 magnitudes to include B and V errors
catutil.c: * Aug 16 2005	Make all string matches case-independent
cel.c:*   WCSLIB - an implementation of the FITS WCS proposal.
cel.c:*   Copyright (C) 1995-2002, Mark Calabretta
cel.c:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
cel.c:*   -------------------
cel.c:*   the transformation parameters but need not be called explicitly - see the
cel.c:*   --------------------------------
cel.c:*                           2: Ill-conditioned coordinate transformation
cel.c:*   --------------------------------
cel.c:*   --------------------------------
cel.c:*   ------------------------------------
cel.c:*         ref[3] to 999.0 to choose the more northerly solution - the default
cel.c:*         LONPOLE = +/- 90 then the celestial latitude of the pole is not
cel.c:*   --------------------
cel.c:*   Pseudo-cylindricals:
cel.c:*      SFL: Sanson-Flamsteed
cel.c:*      AIT: Hammer-Aitoff
cel.c:*   Quad-cubes:
cel.c:   "Ill-conditioned coordinate transformation parameters"};
cel.c:   const double tol = 1.0e-10;
cel.c:   dophip = (cel->ref[2] == 999.0);
cel.c:   if (prj->theta0 == 90.0) {
cel.c:         cel->ref[2] = 180.0;
cel.c:      latp = cel->ref[1];
cel.c:      cel->ref[3] = latp;
cel.c:      cel->euler[0] = cel->ref[0];
cel.c:      cel->euler[1] = 90.0 - latp;
cel.c:         cel->ref[2] = (cel->ref[1] < prj->theta0) ? 180.0 : 0.0;
cel.c:      clat0 = cosdeg (cel->ref[1]);
cel.c:      slat0 = sindeg (cel->ref[1]);
cel.c:      cphip = cosdeg (cel->ref[2]);
cel.c:      sphip = sindeg (cel->ref[2]);
cel.c:      cthe0 = cosdeg (prj->theta0);
cel.c:      sthe0 = sindeg (prj->theta0);
cel.c:         latp = cel->ref[3];
cel.c:            latp1 -= 360.0;
cel.c:         } else if (latp1 < -180.0) {
cel.c:         latp2 = u - v;
cel.c:            latp2 -= 360.0;
cel.c:         } else if (latp2 < -180.0) {
cel.c:         if (fabs(cel->ref[3]-latp1) < fabs(cel->ref[3]-latp2)) {
cel.c:         cel->ref[3] = latp;
cel.c:      cel->euler[1] = 90.0 - latp;
cel.c:            cel->euler[0] = cel->ref[0];
cel.c:            cel->euler[1] = 90.0 - prj->theta0;
cel.c:            cel->euler[0] = cel->ref[0] + cel->ref[2] - 180.0;
cel.c:            cel->euler[1] = 0.0;
cel.c:            cel->euler[0] = cel->ref[0] - cel->ref[2];
cel.c:            cel->euler[1] = 180.0;
cel.c:         x = (sthe0 - sindeg (latp)*slat0)/z;
cel.c:         cel->euler[0] = cel->ref[0] - atan2deg (y,x);
cel.c:      if (cel->ref[0] >= 0.0) {
cel.c:         if (cel->euler[0] < 0.0) cel->euler[0] += 360.0;
cel.c:         if (cel->euler[0] > 0.0) cel->euler[0] -= 360.0;
cel.c:   cel->euler[2] = cel->ref[2];
cel.c:   cel->euler[3] = cosdeg (cel->euler[1]);
cel.c:   cel->euler[4] = sindeg (cel->euler[1]);
cel.c:   cel->flag = CELSET;
cel.c:   /* Check for ill-conditioned parameters. */
cel.c:/*--------------------------------------------------------------------------*/
cel.c:   if (cel->flag != CELSET) {
cel.c:   sphfwd(lng, lat, cel->euler, phi, theta);
cel.c:   if ((err = prj->prjfwd(*phi, *theta, prj, x, y))) {
cel.c:/*--------------------------------------------------------------------------*/
cel.c:   if (cel->flag != CELSET) {
cel.c:   if ((err = prj->prjrev(x, y, prj, phi, theta))) {
cel.c:   sphrev(*phi, *theta, cel->euler, lng, lat);
cel.c:/* Dec 20 1999	Doug Mink - Change cosd() and sind() to cosdeg() and sindeg()
cel.c: * Dec 20 1999	Doug Mink - Include wcslib.h, which includes wcsmath.h and cel.h
cel.c: * Dec 18 2000	Doug Mink - Include string.h for strcmp()
cel.c: * Mar 20 2001	Doug Mink - Add () around err assignments in if statements
cel.c: * Sep 19 2001	Doug Mink - Add above changes to WCSLIB-2.7 cel.c
cel.c: * Mar 12 2002	Doug Mink - Add changes to WCSLIB-2.8.2 cel.c
COPYING:     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
COPYING:free software--to make sure the software is free for all its users.
COPYING:specially designated software packages--typically libraries--of the
COPYING:  We protect your rights with a two-step method: (1) we copyright the
COPYING:libraries into non-free programs.
COPYING:of an advantage over competing non-free programs.  These disadvantages
COPYING:a de-facto standard.  To achieve this, non-free programs must be
COPYING:library does the same job as widely used non-free libraries.  In this
COPYING:  In other cases, permission to use a particular library in non-free
COPYING:non-free programs enables many more people to use the whole GNU
COPYING:    a purpose that is entirely well-defined independent of the
COPYING:    application-supplied function or table used by this function must
COPYING:it with the complete corresponding machine-readable source code, which
COPYING:    machine-readable source code for the Library including whatever
COPYING:    with the Library, with the complete machine-readable "work that
COPYING:    interface-compatible with the version that the work was made with.
COPYING:Library side-by-side in a single library together with other library
COPYING:license would not permit royalty-free redistribution of the Library by
ctgread.c: *** Harvard-Smithsonian Center for Astrophysics
ctgread.c: *** Copyright (C) 1998-2013
ctgread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
ctgread.c:/* CTGREAD -- Read ASCII stars in specified region */
ctgread.c:double	ddec;		/* Search half-width in declination in degrees */
ctgread.c:double	**tmag;		/* 2-D array of magnitudes (returned) */
ctgread.c:    if (cdec - ddec < -90.0) {
ctgread.c:	dec1 = -90.0;
ctgread.c:    star->num = 0.0;
ctgread.c:    if (sc->nstars <= 0) {
ctgread.c:    if (sortmag > 0 && sortmag <= sc->nmag)
ctgread.c:	magsort = sortmag - 1;
ctgread.c:    if (tobj == NULL || sc->ignore)
ctgread.c:    for (istar = 1; istar <= sc->nstars; istar++) {
ctgread.c:		     sc->isfil, istar);
ctgread.c:	mag = star->xmag[magsort];
ctgread.c:	    sysref = star->coorsys;
ctgread.c:	    eqref = star->equinox;
ctgread.c:	    epref = star->epoch;
ctgread.c:	    num = star->num;
ctgread.c:	    ra = star->ra;
ctgread.c:	    dec = star->dec;
ctgread.c:	    rapm = star->rapm;
ctgread.c:	    decpm = star->decpm;
ctgread.c:	    /* If catalog is RA-sorted, stop reading if past highest RA */
ctgread.c:	    if (sc->rasorted && !wrap && ra > ra2)
ctgread.c:	    if (sc->inform != 'X') {
ctgread.c:		if (sc->mprop == 1)
ctgread.c:		if (sc->inform == 'X')
ctgread.c:		    dist = sqrt ((ra-cra)*(ra-cra) + (dec-cdec)*(dec-cdec));
ctgread.c:	    if (sc->sptype)
ctgread.c:		isp = (1000 * (int) star->isp[0]) + (int)star->isp[1];
ctgread.c:		for (imag = 0; imag < sc->nmag; imag++) {
ctgread.c:			tmag[imag][nstar] = star->xmag[imag];
ctgread.c:		if (sc->mprop == 1) {
ctgread.c:		if (sc->sptype)
ctgread.c:		    lname = strlen (star->objname) + 1;
ctgread.c:			strcpy (objname, star->objname);
ctgread.c:		    if (sc->mprop == 1) {
ctgread.c:		    for (imag = 0; imag < sc->nmag; imag++) {
ctgread.c:			    tmag[imag][farstar] = star->xmag[imag];
ctgread.c:		    if (sc->sptype)
ctgread.c:			lname = strlen (star->objname) + 1;
ctgread.c:			    strcpy (objname, star->objname);
ctgread.c:		if (sc->mprop == 1) {
ctgread.c:		for (imag = 0; imag < sc->nmag; imag++) {
ctgread.c:			tmag[imag][faintstar] = star->xmag[imag];
ctgread.c:		if (sc->sptype)
ctgread.c:		    lname = strlen (star->objname) + 1;
ctgread.c:			strcpy (objname, star->objname);
ctgread.c:		     jstar,istar,sc->nstars,catfile);
ctgread.c:		 catfile,jstar,istar,sc->nstars);
ctgread.c:/* CTGRNUM -- Read ASCII stars with specified numbers */
ctgread.c:double	**tmag;		/* 2-D Array of magnitudes (returned) */
ctgread.c:    sysref = sc->coorsys;
ctgread.c:    eqref = sc->equinox;
ctgread.c:    epref = sc->epoch;
ctgread.c:    star->num = 0.0;
ctgread.c:    if (tobj == NULL || sc->ignore)
ctgread.c:	if (match && sc->stnum > 0) {
ctgread.c:	    for (istar = 1; istar <= sc->nstars; istar++) {
ctgread.c:		if (star->num == tnum[jnum]) {
ctgread.c:	    ra = star->ra;
ctgread.c:	    dec = star->dec;
ctgread.c:	    rapm = star->rapm;
ctgread.c:	    decpm = star->decpm;
ctgread.c:	    sysref = star->coorsys;
ctgread.c:	    eqref = star->equinox;
ctgread.c:	    epref = star->epoch;
ctgread.c:	    if (sc->inform != 'X') {
ctgread.c:		if (sc->mprop == 1)
ctgread.c:	    tnum[nstar] = star->num;
ctgread.c:	    if (sc->mprop == 1) {
ctgread.c:	    for (imag = 0; imag < sc->nmag; imag++) {
ctgread.c:		    tmag[imag][nstar] = star->xmag[imag];
ctgread.c:	    if (sc->sptype)
ctgread.c:		tc[nstar] = (1000 * (int) star->isp[0]) + (int)star->isp[1];
ctgread.c:		lname = strlen (star->objname) + 1;
ctgread.c:		    strcpy (objname, star->objname);
ctgread.c:			 star->num,ra,dec,cstr,star->xmag[0]);
ctgread.c:		     nstar,jnum,sc->nstars,catfile);
ctgread.c:		 catfile,nstar,sc->nstars);
ctgread.c:/* CTGRDATE -- Read ASCII stars with specified date range */
ctgread.c:double	**tmag;		/* 2-D Array of magnitudes (returned) */
ctgread.c:    sysref = sc->coorsys;
ctgread.c:    eqref = sc->equinox;
ctgread.c:    epref = sc->epoch;
ctgread.c:    star->num = 0.0;
ctgread.c:    if (tobj == NULL || sc->ignore)
ctgread.c:    for (istar = 1; istar <= sc->nstars; istar++) {
ctgread.c:	if (star->epoch < epoch1) {
ctgread.c:	else if (star->epoch > epoch2) {
ctgread.c:	ra = star->ra;
ctgread.c:	dec = star->dec;
ctgread.c:	rapm = star->rapm;
ctgread.c:	decpm = star->decpm;
ctgread.c:	sysref = star->coorsys;
ctgread.c:	eqref = star->equinox;
ctgread.c:	epref = star->epoch;
ctgread.c:	if (sc->inform != 'X') {
ctgread.c:	    if (sc->mprop == 1)
ctgread.c:	tnum[nstar] = star->num;
ctgread.c:	if (sc->mprop == 1) {
ctgread.c:	for (imag = 0; imag < sc->nmag; imag++) {
ctgread.c:		tmag[imag][nstar] = star->xmag[imag];
ctgread.c:	if (sc->sptype)
ctgread.c:	    tc[nstar] = (1000 * (int) star->isp[0]) + (int)star->isp[1];
ctgread.c:	    lname = strlen (star->objname) + 1;
ctgread.c:		strcpy (objname, star->objname);
ctgread.c:		     star->num,ra,dec,cstr,star->xmag[0]);
ctgread.c:		     nstar,istar,sc->nstars,catfile);
ctgread.c:		 catfile,nstar,sc->nstars);
ctgread.c:/* CTGBIN -- Fill a FITS WCS image with stars from catalog */
ctgread.c:    double ddec;	/* Search half-width in declination in degrees */
ctgread.c:            nstar = -1;
ctgread.c:    sysout = wcs->syswcs;
ctgread.c:    eqout = wcs->equinox;
ctgread.c:    epout = wcs->epoch;
ctgread.c:    if (cdec - ddec < -90.0) {
ctgread.c:	dec1 = -90.0;
ctgread.c:    star->num = 0.0;
ctgread.c:    if (sc->nstars <= 0) {
ctgread.c:    if (sortmag > 0 && sortmag <= sc->nmag)
ctgread.c:	magsort = sortmag - 1;
ctgread.c:    for (istar = 1; istar <= sc->nstars; istar++) {
ctgread.c:		     sc->isfil, istar);
ctgread.c:	mag = star->xmag[magsort];
ctgread.c:	    sysref = star->coorsys;
ctgread.c:	    eqref = star->equinox;
ctgread.c:	    epref = star->epoch;
ctgread.c:	    num = star->num;
ctgread.c:	    ra = star->ra;
ctgread.c:	    dec = star->dec;
ctgread.c:	    rapm = star->rapm;
ctgread.c:	    decpm = star->decpm;
ctgread.c:	    /* If catalog is RA-sorted, stop reading if past highest RA */
ctgread.c:	    if (sc->rasorted && !wrap && ra > ra2)
ctgread.c:	    if (sc->inform != 'X') {
ctgread.c:		if (sc->mprop == 1)
ctgread.c:		    flux = magscale * exp (logt * (-mag / 2.5));
ctgread.c:		     jstar,istar,sc->nstars,catfile);
ctgread.c:		 catfile,jstar,istar,sc->nstars);
ctgread.c:/* CTGOPEN -- Open ASCII catalog, returning number of entries */
ctgread.c:    if ((sc->catbuff = malloc (lfile+2)) == NULL) {
ctgread.c:    sc->catbuff[lfile] = (char) 0;
ctgread.c:    sc->catbuff[lfile+1] = (char) 0;
ctgread.c:	strcpy (sc->isfil, catname);
ctgread.c:	strncpy (sc->isfil, catname, 23);
ctgread.c:    nr = fread (sc->catbuff, 1, lfile, fcat);
ctgread.c:    sc->inform = 'H';
ctgread.c:    sc->coorsys = WCS_B1950;
ctgread.c:    sc->epoch = 1950.0;
ctgread.c:    sc->equinox = 1950.0;
ctgread.c:    sc->nmag = 1;
ctgread.c:    sc->mprop = 0;
ctgread.c:    sc->rasorted = 0;
ctgread.c:    sc->sptype = 0;
ctgread.c:    sc->stnum = 1;
ctgread.c:    sc->entepoch = 0;
ctgread.c:    sc->entrv = 0;
ctgread.c:    catdesc = strchr (sc->catbuff, newline) + 1;
ctgread.c:    lhead = catdesc - sc->catbuff;
ctgread.c:    if (sc->catbuff[0] == '#' && sc->catbuff[1] == ' ') {
ctgread.c:	strncpy (header, sc->catbuff+2, lhead-2);
ctgread.c:	header[lhead-2] = (char) 0;
ctgread.c:    else if (sc->catbuff[0] == '#') {
ctgread.c:	strncpy (header, sc->catbuff+1, lhead-1);
ctgread.c:	header[lhead-1] = (char) 0;
ctgread.c:	strncpy (header, sc->catbuff, lhead);
ctgread.c:	sc->inform = 'R';
ctgread.c:	sc->coorsys = WCS_B1950;
ctgread.c:	sc->epoch = 1950.0;
ctgread.c:	sc->equinox = 1950.0;
ctgread.c:	sc->inform = 'D';
ctgread.c:	sc->coorsys = WCS_ECLIPTIC;
ctgread.c:	sc->inform = 'D';
ctgread.c:	sc->epoch = 2000.0;
ctgread.c:	sc->equinox = 2000.0;
ctgread.c:	sc->inform = 'F';
ctgread.c:	sc->coorsys = WCS_GALACTIC;
ctgread.c:	sc->inform = 'D';
ctgread.c:	sc->epoch = 2000.0;
ctgread.c:	sc->equinox = 2000.0;
ctgread.c:	sc->inform = 'H';
ctgread.c:	sc->ignore = 1;
ctgread.c:	sc->ignore = 0;
ctgread.c:	sc->coorsys = WCS_J2000;
ctgread.c:	sc->epoch = 2000.0;
ctgread.c:	sc->equinox = 2000.0;
ctgread.c:	sc->inform = 'K';
ctgread.c:	sc->nmag = 0;
ctgread.c:	sc->nmag = 2;
ctgread.c:	sc->nmag = 3;
ctgread.c:	sc->nmag = 4;
ctgread.c:	sc->nmag = 5;
ctgread.c:	sc->nmag = 6;
ctgread.c:	sc->nmag = 7;
ctgread.c:	sc->nmag = 8;
ctgread.c:	sc->nmag = 9;
ctgread.c:	sc->stnum = 0;
ctgread.c:	sc->stnum = -16;
ctgread.c:	sc->mprop = 1;
ctgread.c:	sc->coorsys = 0;
ctgread.c:	sc->epoch = 0.0;
ctgread.c:	sc->equinox = 0.0;
ctgread.c:    /* RA-sorted catalog */
ctgread.c:	sc->rasorted = 1;
ctgread.c:	sc->sptype = 1;
ctgread.c:	sc->inform = 'T';
ctgread.c:	sc->inform = 'U';
ctgread.c:	sc->mprop = 2;
ctgread.c:	sc->entrv = 1;
ctgread.c:	sc->inform = 'X';
ctgread.c:	sc->coorsys = WCS_XY;
ctgread.c:	sc->nepoch = 1;
ctgread.c:	sc->nepoch = 0;
ctgread.c:    sc->catdata = strchr (catdesc, newline) + 1;
ctgread.c:    ldesc = sc->catdata - catdesc;
ctgread.c:	strncpy (sc->isname, catdesc+2, ldesc-2);
ctgread.c:	sc->isname[ldesc-2] = (char) 0;
ctgread.c:	strncpy (sc->isname, catdesc+1, ldesc-1);
ctgread.c:	sc->isname[ldesc-1] = (char) 0;
ctgread.c:	strncpy (sc->isname, catdesc, ldesc);
ctgread.c:	sc->isname[ldesc] = (char) 0;
ctgread.c:    if (sc->entrv > 0 && sc->nmag < 10) {
ctgread.c:	sc->nmag = sc->nmag + 1;
ctgread.c:	strcpy (sc->keymag[sc->nmag-1], "velocity");
ctgread.c:    if (sc->nepoch > 0 && sc->nmag < 10) {
ctgread.c:	sc->nmag = sc->nmag + 1;
ctgread.c:	strcpy (sc->keymag[sc->nmag-1], "epoch");
ctgread.c:    catnew = sc->catdata;
ctgread.c:    sc->nstars = 0;
ctgread.c:	    sc->nstars = sc->nstars + 1;
ctgread.c:    sc->catline = sc->catdata;
ctgread.c:    sc->catlast = sc->catdata + lfile;
ctgread.c:    sc->istar = 1;
ctgread.c:    if (sc->stnum == 1) {
ctgread.c:	line = sc->catline;
ctgread.c:	linend = strchr (sc->catline, newline);
ctgread.c:	    linend = sc->catlast;
ctgread.c:	sc->nnfld = ltok;
ctgread.c:	    sc->nndec = 0;
ctgread.c:		    sc->nndec++;
ctgread.c:	    sc->nndec = 0;
ctgread.c:    sc->refcat = TXTCAT;
ctgread.c:/* CTGCLOSE -- Close ASCII catalog and free associated data structures */
ctgread.c:    else if (sc->refcat == BINCAT)
ctgread.c:    else if (sc->refcat == TABCAT)
ctgread.c:    else if (sc->refcat == TXTCAT) {
ctgread.c:	free (sc->catbuff);
ctgread.c:/* CTGSTAR -- Get ASCII catalog entry for one star; return 0 if successful */
ctgread.c:    if (istar > sc->nstars) {
ctgread.c:	return (-1);
ctgread.c:	line = strchr (sc->catline, newline) + 1;
ctgread.c:	    return (-1);
ctgread.c:	    sc->catline = line;
ctgread.c:    else if (istar < sc->istar) {
ctgread.c:	sc->istar = 1;
ctgread.c:	sc->catline = sc->catdata;
ctgread.c:	nextline = sc->catline;
ctgread.c:	while (sc->istar < istar) {
ctgread.c:		return (-1);
ctgread.c:	    sc->catline = nextline;
ctgread.c:	    sc->istar++;
ctgread.c:    else if (istar > sc->istar) {
ctgread.c:	nextline = sc->catline;
ctgread.c:	while (sc->istar < istar) {
ctgread.c:		return (-1);
ctgread.c:	    sc->catline = nextline;
ctgread.c:	    sc->istar++;
ctgread.c:    line = sc->catline;
ctgread.c:    linend = strchr (sc->catline, newline);
ctgread.c:	linend = sc->catlast;
ctgread.c:    st->objname[0] = (char) 0;
ctgread.c:    if (sc->stnum > 0) {
ctgread.c:	    st->num = atof (token);
ctgread.c:	    if (st->num - ((double) ((int) st->num)) < 0.000001)
ctgread.c:		sc->stnum = 1;
ctgread.c:		sc->stnum = 2;
ctgread.c:	st->num = (double) sc->istar;
ctgread.c:    if (sc->stnum < 0) {
ctgread.c:	    strncpy (st->objname, token, 31);
ctgread.c:	    st->objname[31] = 0;
ctgread.c:	    strcpy (st->objname, token);
ctgread.c:	return (-1);
ctgread.c:    /* Translate 3-token right ascension (hh mm ss.ss) */
ctgread.c:    if (sc->inform == 'T') {
ctgread.c:	    return (-1);
ctgread.c:	    return (-1);
ctgread.c:	st->ra = 15.0 * ((double) hr + ((double) mn / 60.0) + (sec / 3600.0));
ctgread.c:    /* Translate single-token right ascension from hhmmss.ss */
ctgread.c:    else if (sc->inform == 'U') {
ctgread.c:	st->ra = ctg2ra (token);
ctgread.c:    /* Translate single-token right ascension as degrees */
ctgread.c:    else if (sc->inform == 'D')
ctgread.c:	st->ra = atof (token);
ctgread.c:    /* Translate single-token right ascension as hh.mm */
ctgread.c:    else if (sc->inform == 'F')
ctgread.c:	st->ra = ctg2ra (token);
ctgread.c:    /* Translate single-token right ascension as fractional hours */
ctgread.c:    else if (sc->inform == 'K')
ctgread.c:	st->ra = 15.0 * atof (token);
ctgread.c:    /* Translate single-token right ascension as radians */
ctgread.c:    else if (sc->inform == 'R')
ctgread.c:	st->ra = raddeg (atof (token));
ctgread.c:    /* Translate single-token right ascension as X image coordinate */
ctgread.c:    else if (sc->inform == 'X')
ctgread.c:	st->ra = atof (token);
ctgread.c:    /* Translate single-token right ascension (hh:mm:ss.ss or hh.mmssss) */
ctgread.c:	st->ra = ctg2ra (token);
ctgread.c:	return (-1);
ctgread.c:    /* Translate 3-token declination (sdd mm ss.ss) */
ctgread.c:    if (sc->inform == 'T') {
ctgread.c:	if (strchr (token, '-') != NULL) {
ctgread.c:	    deg = (int) (atof (token) - 0.5);
ctgread.c:	    return (-1);
ctgread.c:	    return (-1);
ctgread.c:	st->dec = (double) deg + ((double) min / 60.0) + (sec / 3600.0);
ctgread.c:	if (deg > -1 && decsgn)
ctgread.c:	    st->dec = -st->dec;
ctgread.c:    /* Translate single-token declination as Y image coordinate */
ctgread.c:    else if (sc->inform == 'X')
ctgread.c:	st->dec = atof (token);
ctgread.c:    /* Translate single-token declination as degrees */
ctgread.c:    else if (sc->inform == 'D' || sc->inform == 'F' || sc->inform == 'K')
ctgread.c:	st->dec = atof (token);
ctgread.c:    /* Translate single-token declination as radians */
ctgread.c:    else if (sc->inform == 'R')
ctgread.c:	st->dec = raddeg (atof (token));
ctgread.c:    /* Translate single-token declination from ddmmss.ss */
ctgread.c:    else if (sc->inform == 'U') {
ctgread.c:	st->dec = ctg2dec (token);
ctgread.c:    /* Translate single-token declination (dd:mm:ss.ss or dd.mmssss) */
ctgread.c:	st->dec = ctg2dec (token);
ctgread.c:    if (sc->coorsys == 0) {
ctgread.c:	    return (-1);
ctgread.c:	st->coorsys = wcscsys (token);
ctgread.c:	st->equinox = wcsceq (token);
ctgread.c:	st->epoch = sc->epoch;
ctgread.c:	if (st->epoch == 0.0)
ctgread.c:	    st->epoch = st->equinox;
ctgread.c:	st->coorsys = sc->coorsys;
ctgread.c:	st->equinox = sc->equinox;
ctgread.c:	st->epoch = sc->epoch;
ctgread.c:    nmag = sc->nmag;
ctgread.c:    if (sc->nmag > 0 && sc->mprop == 2)
ctgread.c:	nmag = nmag - 1;
ctgread.c:    if (sc->nmag > 0 && sc->nepoch)
ctgread.c:	nmag = nmag - 1;
ctgread.c:		st->xmag[imag] = atof (token);
ctgread.c:		st->xmag[imag] = 0.0;
ctgread.c:    if (sc->sptype > 0) {
ctgread.c:		st->isp[0] = '_';
ctgread.c:		st->isp[1] = '_';
ctgread.c:		st->isp[0] = token[0];
ctgread.c:		st->isp[1] = token[1];
ctgread.c:    if (sc->entrv > 0) {
ctgread.c:	    st->radvel = atof (token);
ctgread.c:	    st->radvel = 0.0;
ctgread.c:	st->xmag[nmag] = st->radvel;
ctgread.c:    if (sc->mprop == 1) {
ctgread.c:	    st->rapm = atof (token) / 3600.0;
ctgread.c:	    st->decpm = atof (token) / 3600.0;
ctgread.c:    if (sc->nepoch) {
ctgread.c:	if (strchr (token, '-') != NULL)
ctgread.c:	    st->epoch = fd2ep (token);
ctgread.c:		st->epoch = dt2ep (ydate, 12.0);
ctgread.c:		st->epoch = mjd2ep (ydate);
ctgread.c:		st->epoch = jd2ep (ydate);
ctgread.c:	if (sc->entrv > 0)
ctgread.c:	    st->xmag[nmag+1] = st->epoch;
ctgread.c:	    st->xmag[nmag] = st->epoch;
ctgread.c:    if (sc->stnum > 0 && itok < ntok && !sc->ignore) {
ctgread.c:	itok = -(itok+1);
ctgread.c:	    strncpy (st->objname, token, 79);
ctgread.c:	    st->objname[79] = 0;
ctgread.c:	    strcpy (st->objname, token);
ctgread.c:/* CTGSIZE -- return size of ASCII catalog file in bytes */
ctgread.c:	return (-1);
ctgread.c:	filesize = -1;
ctgread.c:/* ISACAT -- Return 1 if file is likely to be an ASCII catalog */
ctgread.c:/* CTG2RA -- Read the right ascension, ra, in sexagesimal hours from in[] */
ctgread.c:/* CTG2DEC -- Read the declination, dec, in sexagesimal degrees from in[] */
ctgread.c:    /* Translate value from ASCII colon-delimited string to binary */
ctgread.c:    if (!strchr (value,'-'))
ctgread.c:	sign = -1.0;
ctgread.c:	value = strchr (value,'-') + 1;
ctgread.c:    /* Translate value from ASCII colon-delimited string to binary */
ctgread.c:	xnum = (xnum - deg) * 100.0;
ctgread.c:	sec = (xnum - min) * 100.0;
ctgread.c: * May 22 2001	Add GSC-ACT catalog; pass refcat to gscread() and gscrnum()
ctgread.c: * Jan 16 2003	Add USNO-B1.0 Catalog
ctgread.c: * Aug  5 2005	Add additional catalog codes for Tycho-2 and 2MASS w/mag errs
ctgread.c: * Nov 16 2006	Return -1 for SDSS and GSC2; binning subroutines do not exist
daoread.c: *** Harvard-Smithsonian Center for Astrophysics
daoread.c: *** Copyright (C) 1996-2007
daoread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
daoread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
daoread.c:/* DAOREAD -- Read DAOFIND file of star positions in an image */
daoread.c:		(*xa)[nstars-1] = xi;
daoread.c:		(*ya)[nstars-1] = yi;
daoread.c:		(*ba)[nstars-1] = magi;
daoread.c:		flux = pow (10.0, (-magi / 2.5));
daoread.c:		(*pa)[nstars-1] = (int) flux;
daoread.c:/* DAOOPEN -- Open DAOFIND catalog, returning number of entries */
daoread.c:/* DAOLINE -- Get DAOFIND catalog entry for one star; return 0 if successful */
dateutil0.c: *** Harvard-Smithsonian Center for Astrophysics
dateutil0.c: *** Copyright (C) 1999-2008
dateutil0.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
dateutil0.c:  epb = Besselian epoch = 365.242198781-day years based on 1900.0
dateutil0.c:  epj = Julian epoch = 365.25-day years based on 2000.0
dateutil0.c:	dd-mm-yy (nonstandard FITS use before 2000)
dateutil0.c:	yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:	yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999)
dateutil0.c:  mjd = modified Julian Date = JD - 2400000.5
dateutil0.c:   ts = UT seconds since 1950-01-01T00:00 (used for ephemeris computations)
dateutil0.c:  tsi = local seconds since 1980-01-01T00:00 (used by IRAF as a time tag)
dateutil0.c:  tsu = UT seconds since 1970-01-01T00:00 (used as Unix system time)
dateutil0.c: mhjd = modified Heliocentric Julian Date = HJD - 2400000.5
dateutil0.c: *	Convert date (yyyy.ddmm) and time (hh.mmsss) to seconds since 1950-01-01
dateutil0.c: *	Convert date (yyyy.ddmm) and time (hh.mmsss) to seconds since 1980-01-01
dateutil0.c: *	Convert date (yyyy.ddmm) and time (hh.mmsss) to seconds since 1970-01-01
dateutil0.c: *	Convert from UT in seconds since 1950-01-01 to ET in same format
dateutil0.c: *	Convert from ET in seconds since 1950-01-01 to UT in same format
dateutil0.c: *	Convert FITS standard date string to old-format FITS date and time
dateutil0.c: *	Convert FITS standard date string to old-format FITS date string
dateutil0.c: *	Return local time as IRAF seconds since 1980-01-01 00:00
dateutil0.c: *	Return local time as Unix seconds since 1970-01-01 00:00
dateutil0.c: *	Return local time as Unix seconds since 1950-01-01 00:00
dateutil0.c: *	Convert seconds since 1980-01-01 to FITS standard date string
dateutil0.c: *	Convert seconds since 1980-01-01 to date as yyyy.ddmm, time as hh.mmsss
dateutil0.c: *	Convert seconds since 1970-01-01 to FITS standard date string
dateutil0.c: *	Convert UT seconds since 1970-01-01 to local seconds since 1980-01-01
dateutil0.c: *	Convert seconds since 1970-01-01 to date as yyyy.ddmm, time as hh.mmsss
dateutil0.c: *          in seconds since 1951-01-01T0:00:00
dateutil0.c: *          in seconds since 1951-01-01T0:00:00
dateutil0.c: *	Calculate Local Sidereal Time given UT in seconds since 1951-01-01T0:00
dateutil0.c: *	Compute difference between UT and dynamical time (ET-UT)
dateutil0.c: *	Current Universal Time to IRAF seconds since 1980-01-01T00:00
dateutil0.c: *	Current Universal Time to Unix seconds since 1970-01-01T00:00
dateutil0.c: *	Current Universal Time to seconds since 1950-01-01T00:00
dateutil0.c: * Internally-used subroutines
dateutil0.c: *	Calculate days in month 1-12 given year (Gregorian calendar only
dateutil0.c:/* ANG2HR -- Convert angle in fraction degrees to hours as hh:mm:ss.ss */
dateutil0.c:/* ANG2DEG -- Convert angle in fraction degrees to degrees as dd:mm:ss.ss */
dateutil0.c:/* DEG2ANG -- Convert angle in degrees as dd:mm:ss.ss to fractional degrees */
dateutil0.c:/* HR2ANG -- Convert angle in hours as hh:mm:ss.ss to fractional degrees */
dateutil0.c:/* DT2FD-- convert vigesimal date and time to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:	sprintf (dstring, "%4d-%02d-%02d", iyr, imon, iday);
dateutil0.c:/* DT2JD-- convert from date as yyyy.mmdd and time as hh.mmsss to Julian Date
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:/* DT2MJD-- convert from date yyyy.mmdd time hh.mmsss to modified Julian Date
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:    return (dj - 2400000.5);
dateutil0.c:/* HJD2JD-- convert  Heliocentric Julian Date to (geocentric) Julian date */
dateutil0.c:    return (dj - lt);
dateutil0.c:/* JD2HJD-- convert (geocentric) Julian date to Heliocentric Julian Date */
dateutil0.c:/* MHJD2MJD-- convert modified Heliocentric Julian Date to
dateutil0.c:    return (jd2mjd (hjd - lt));
dateutil0.c:/* MJD2MHJD-- convert modified geocentric Julian date tp
dateutil0.c:/* SUNTL-- compute light travel time to heliocentric correction in days */
dateutil0.c:    t = (dj - 2415020.0) / 36525.0;
dateutil0.c:    manom = 358.47583 + (t * (35999.04975 - t * (0.000150 + t * 0.000003)));
dateutil0.c:    oblq = 23.452294 - (t * (0.0130125 + t * (0.00000164 - t * 0.000000503)));
dateutil0.c:    eccen = 0.01675104 - (t * (0.00004180 + t * 0.000000126));
dateutil0.c:    manom = manom - (360.0 * (dint) (manom / 360.0));
dateutil0.c:    lperi = lperi - (360.0 * (dint) (lperi / 360.0));
dateutil0.c:    tanom = manom + (2 * eccen - 0.25 * eccen3) * sin (manom) +
dateutil0.c:    rs1 = 1.0 - eccen2;
dateutil0.c:    lt = -0.005770 * rs * cos (b) * cos (l - slong);
dateutil0.c:/* JD2DT-- convert Julian date to date as yyyy.mmdd and time as hh.mmssss */
dateutil0.c:	*date = (double) (-iyr) + 0.01 * (double) imon + 0.0001 * (double) iday;
dateutil0.c:	*date = -(*date);
dateutil0.c:/* JD2I-- convert Julian date to date as year, month, and day, and time hours,
dateutil0.c:    /* Round seconds to 0 - 4 decimal places */
dateutil0.c:	dts = -0.5;
dateutil0.c:	jd = (int) (dj - frac);
dateutil0.c:	jd = (int) (dj - frac) + 1;
dateutil0.c:	sday = (frac - 0.5) * 86400.0;
dateutil0.c:    sday = sday - (double) (*ihr * 3600);
dateutil0.c:    *sec = sday - (double) (*imn * 60);
dateutil0.c:    l = l - (146097 * n + 3) / 4;
dateutil0.c:    l = l - (1461 * i) / 4 + 31;
dateutil0.c:    *iday = l - (2447 * j) / 80;
dateutil0.c:    *imon = j + 2 - (12 * l);
dateutil0.c:    *iyr = 100 * (n - 49) + i + l;
dateutil0.c:/* JD2MJD-- convert Julian Date to Modified Julian Date */
dateutil0.c:    return (dj - 2400000.5);
dateutil0.c:/* JD2EP-- convert Julian date to fractional year as used in epoch */
dateutil0.c:/* JD2EPB-- convert Julian date to Besselian epoch */
dateutil0.c:    return (1900.0 + (dj - 2415020.31352) / 365.242198781);
dateutil0.c:/* JD2EPJ-- convert Julian date to Julian epoch */
dateutil0.c:    return (2000.0 + (dj - 2451545.0) / 365.25);
dateutil0.c:/* LT2DT-- Return local time as yyyy.mmdd and time as hh.mmssss */
dateutil0.c:    if (ts->tm_year < 1000)
dateutil0.c:	*date = (double) (ts->tm_year + 1900);
dateutil0.c:	*date = (double) ts->tm_year;
dateutil0.c:    *date = *date + (0.01 * (double) (ts->tm_mon + 1));
dateutil0.c:    *date = *date + (0.0001 * (double) ts->tm_mday);
dateutil0.c:    *time = (double) ts->tm_hour;
dateutil0.c:    *time = *time + (0.01 * (double) ts->tm_min);
dateutil0.c:    *time = *time + (0.0001 * (double) ts->tm_sec);
dateutil0.c:/* LT2FD-- Return current local time as FITS ISO date string */
dateutil0.c:    year = ts->tm_year;
dateutil0.c:    month = ts->tm_mon + 1;
dateutil0.c:    day = ts->tm_mday;
dateutil0.c:    hour = ts->tm_hour;
dateutil0.c:    minute = ts->tm_min;
dateutil0.c:    second = ts->tm_sec;
dateutil0.c:    sprintf (isotime, "%04d-%02d-%02dT%02d:%02d:%02d",
dateutil0.c:/* LT2TSI-- Return local time as IRAF seconds since 1980-01-01 00:00 */
dateutil0.c:    return ((int)(lt2ts() - 946684800.0));
dateutil0.c:/* LT2TSU-- Return local time as Unix seconds since 1970-01-01 00:00 */
dateutil0.c:    return ((time_t)(lt2ts() - 631152000.0));
dateutil0.c:/* LT2TS-- Return local time as Unix seconds since 1950-01-01 00:00 */
dateutil0.c:/* MJD2DT-- convert Modified Julian Date to date (yyyy.mmdd) time (hh.mmssss) */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:/* MJD2I-- convert Modified Julian Date to date as year, month, day and
dateutil0.c:/* MJD2DOY-- convert Modified Julian Date to Year,Day-of-Year */
dateutil0.c:/* MJD2JD-- convert Modified Julian Date to Julian Date */
dateutil0.c:/* MJD2EP-- convert Modified Julian Date to fractional year */
dateutil0.c:/* MJD2EPB-- convert Modified Julian Date to Besselian epoch */
dateutil0.c:    return (1900.0 + (dj - 15019.81352) / 365.242198781);
dateutil0.c:/* MJD2EPJ-- convert Modified Julian Date to Julian epoch */
dateutil0.c:    return (2000.0 + (dj - 51544.5) / 365.25);
dateutil0.c:/* MJD2FD-- convert modified Julian date to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil0.c:/* MJD2TS-- convert modified Julian date to seconds since 1950.0 */
dateutil0.c:    return ((dj - 33282.0) * 86400.0);
dateutil0.c:/* EP2FD-- convert fractional year to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil0.c:/* EPB2FD-- convert Besselian epoch to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:/* EPJ2FD-- convert Julian epoch to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:/* EP2TS-- convert fractional year to seconds since 1950.0 */
dateutil0.c:    return ((dj - 2433282.5) * 86400.0);
dateutil0.c:/* EPB2TS-- convert Besselian epoch to seconds since 1950.0 */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:    return ((dj - 2433282.5) * 86400.0);
dateutil0.c:/* EPJ2TS-- convert Julian epoch to seconds since 1950.0 */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:    return ((dj - 2433282.5) * 86400.0);
dateutil0.c:/* EPB2EP-- convert Besselian epoch to fractional years */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:/* EP2EPB-- convert fractional year to Besselian epoch */
dateutil0.c:/* EPJ2EP-- convert Julian epoch to fractional year */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:/* EP2EPJ-- convert fractional year to Julian epoch */
dateutil0.c:/* EP2I-- convert fractional year to year month day hours min sec */
dateutil0.c:/* EPB2I-- convert Besselian epoch to year month day hours min sec */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:/* EPJ2I-- convert Julian epoch to year month day hours min sec */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:/* EP2JD-- convert fractional year as used in epoch to Julian date */
dateutil0.c:/* EPB2JD-- convert Besselian epoch to Julian Date */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:    return (2415020.31352 + ((epoch - 1900.0) * 365.242198781));
dateutil0.c:/* EPJ2JD-- convert Julian epoch to Julian Date */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:    return (2451545.0 + ((epoch - 2000.0) * 365.25));
dateutil0.c:/* EP2MJD-- convert fractional year as used in epoch to modified Julian date */
dateutil0.c:    return (dj - 2400000.5);
dateutil0.c:/* EPB2MJD-- convert Besselian epoch to modified Julian Date */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:    return (15019.81352 + ((epoch - 1900.0) * 365.242198781));
dateutil0.c:/* EPJ2MJD-- convert Julian epoch to modified Julian Date */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:    return (51544.5 + ((epoch - 2000.0) * 365.25));
dateutil0.c:/* EPB2EPJ-- convert Besselian epoch to Julian epoch */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:/* EPJ2EPB-- convert Julian epoch to Besselian epoch */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:/* JD2FD-- convert Julian date to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil0.c:    tsec = (dj - 2433282.5) * 86400.0;
dateutil0.c:/* JD2TS-- convert Julian date to seconds since 1950.0 */
dateutil0.c:    return ((dj - 2433282.5) * 86400.0);
dateutil0.c:/* JD2TSI-- convert Julian date to IRAF seconds since 1980-01-01T0:00 */
dateutil0.c:    ts = (dj - 2444239.5) * 86400.0;
dateutil0.c:/* JD2TSU-- convert Julian date to Unix seconds since 1970-01-01T0:00 */
dateutil0.c:    return ((time_t)((dj - 2440587.5) * 86400.0));
dateutil0.c:/* DT2DOY-- convert yyyy.mmdd hh.mmss to year and day of year */
dateutil0.c:    *doy = dj - dj0 + 1.0;
dateutil0.c:/* DOY2DT-- convert year and day of year to yyyy.mmdd hh.mmss */
dateutil0.c:    dj = dj0 + doy - 1.0;
dateutil0.c:/* DOY2EP-- convert year and day of year to fractional year as used in epoch */
dateutil0.c:/* DOY2EPB-- convert year and day of year to Besellian epoch */
dateutil0.c:/* DOY2EPJ-- convert year and day of year to Julian epoch */
dateutil0.c:/* DOY2FD-- convert year and day of year to FITS date */
dateutil0.c:/* DOY2JD-- convert year and day of year to Julian date */
dateutil0.c:    return (dj0 + doy - 1.0);
dateutil0.c:/* DOY2MJD-- convert year and day of year to Julian date */
dateutil0.c:    return (dj0 + doy - 1.0 - 2400000.5);
dateutil0.c:/* DOY2TSU-- convert from FITS date to Unix seconds since 1970-01-01T0:00 */
dateutil0.c:/* DOY2TSI-- convert from FITS date to IRAF seconds since 1980-01-01T0:00 */
dateutil0.c:/* DOY2TS-- convert year, day of year to seconds since 1950 */
dateutil0.c:/* FD2DOY-- convert FITS date to year and day of year */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* JD2DOY-- convert Julian date to year and day of year */
dateutil0.c:    *doy = dj - dj0 + 1.0;
dateutil0.c:/* TS2JD-- convert seconds since 1950.0 to Julian date */
dateutil0.c:/* TS2MJD-- convert seconds since 1950.0 to modified Julian date */
dateutil0.c:/* TS2EP-- convert seconds since 1950.0 to fractional year as used in epoch */
dateutil0.c:/* TS2EPB-- convert seconds since 1950.0 to Besselian epoch */
dateutil0.c:/* TS2EPB-- convert seconds since 1950.0 to Julian epoch */
dateutil0.c:/* DT2EP-- convert from date, time as yyyy.mmdd hh.mmsss to fractional year */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:	epoch = dint (date) + ((dj - dj0) / (dj1 - dj0));
dateutil0.c:/* DT2EPB-- convert from date, time as yyyy.mmdd hh.mmsss to Besselian epoch */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:/* DT2EPJ-- convert from date, time as yyyy.mmdd hh.mmsss to Julian epoch */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:/* EP2DT-- convert from fractional year to date, time as yyyy.mmdd hh.mmsss */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:    epochf = epoch - epochi;
dateutil0.c:    dj = dj0 + epochf * (dj1 - dj0);
dateutil0.c:/* EPB2DT-- convert from Besselian epoch to date, time as yyyy.mmdd hh.mmsss */
dateutil0.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:/* EPJ2DT-- convert from Julian epoch to date, time as yyyy.mmdd hh.mmsss */
dateutil0.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:/* FD2JD-- convert FITS standard date to Julian date */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2MJD-- convert FITS standard date to modified Julian date */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:    return (fd2jd (string) - 2400000.5);
dateutil0.c:/* FD2TSU-- convert from FITS date to Unix seconds since 1970-01-01T0:00 */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2TSI-- convert from FITS date to IRAF seconds since 1980-01-01T0:00 */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2TS-- convert FITS standard date to seconds since 1950 */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2FD-- convert any FITS standard date to ISO FITS standard date */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2OF-- convert any FITS standard date to old FITS standard date time */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:		 iday, imon, iyr-1900, ihr, imn, sec);
dateutil0.c:		 iday, imon, iyr-1900, ihr, imn, sec);
dateutil0.c:/* TAI-UTC from the U.S. Naval Observatory */
dateutil0.c:/* ftp://maia.usno.navy.mil/ser7/tai-utc.dat */
dateutil0.c:	   7.54, 6.97, 6.40, 6.02, 5.41, 4.10, 2.92, 1.82, 1.61, 0.10,-1.02,
dateutil0.c:	  -1.28,-2.69,-3.24,-3.64,-4.54,-4.71,-5.11,-5.40,-5.42,-5.20,-5.46,
dateutil0.c:	  -5.46,-5.79,-5.63,-5.64,-5.80,-5.66,-5.87,-6.01,-6.19,-6.64,-6.44,
dateutil0.c:	  -6.47,-6.09,-5.76,-4.66,-3.74,-2.72,-1.54,-0.02, 1.24, 2.64, 3.86,
dateutil0.c:/* ET2FD-- convert from ET (or TDT or TT) in FITS format to UT in FITS format */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:    dj = dj0 - (dt / 86400.0);
dateutil0.c:    tsec = tsec - dt;
dateutil0.c:/* FD2ET-- convert from UT in FITS format to ET (or TDT or TT) in FITS format */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* DT2ET-- convert from UT as yyyy.mmdd hh.mmssss to ET in same format */
dateutil0.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil0.c:/* EDT2DT-- convert from ET as yyyy.mmdd hh.mmssss to UT in same format */
dateutil0.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil0.c:/* JD2JED-- convert from Julian Date to Julian Ephemeris Date */
dateutil0.c:/* JED2JD-- convert from Julian Ephemeris Date to Julian Date */
dateutil0.c:    dj = dj0 - (dt / 86400.0);
dateutil0.c:    return (dj - (dt / 86400.0));
dateutil0.c:/* TS2ETS-- convert from UT in seconds since 1950-01-01 to ET in same format */
dateutil0.c:/* ETS2TS-- convert from ET in seconds since 1950-01-01 to UT in same format */
dateutil0.c:    dj = dj0 - (dt / 86400.0);
dateutil0.c:    return (tsec - dt);
dateutil0.c:/* UTDT-- Compute difference between UT and dynamical time (ET-UT) */
dateutil0.c:    /* If after 1972-01-01, use tabulated TAI-UT */
dateutil0.c:	for (i = 22;  i > 0; i--) {
dateutil0.c:    /* For 1800-01-01 to 1972-01-01, use table of ET-UT from AE */
dateutil0.c:	iyr = iyear - 1800;
dateutil0.c:	yfrac = (ts - ts0) / (ts1 - ts0);
dateutil0.c:	diff = dttab[iyr+1] - dttab[iyr];
dateutil0.c:	cj = (dj - 2378496.5) / 36525.0;
dateutil0.c:	dt = 5.156 + 13.3066 * (cj - 0.19) * (cj - 0.19);
dateutil0.c:	cj = (dj - 2378496.5) / 36525.0;
dateutil0.c:/* FD2OFD-- convert any FITS standard date to old FITS standard date */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:	sprintf (string, "%02d/%02d/%02d", iday, imon, iyr-1900);
dateutil0.c:	sprintf (string, "%02d/%02d/%3d", iday, imon, iyr-1900);
dateutil0.c:/* FD2OFT-- convert any FITS standard date to old FITS standard time */
dateutil0.c:			dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2DT-- convert FITS standard date to date, time as yyyy.mmdd hh.mmsss */
dateutil0.c:		    dd-mm-yy (nonstandard use before 2000)
dateutil0.c:		    yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:		    yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:	*date = (double) (-iyr) + 0.01 * (double) imon + 0.0001 * (double) iday;
dateutil0.c:	*date = -(*date);
dateutil0.c:/* FD2EP-- convert from FITS standard date to fractional year */
dateutil0.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2EPB-- convert from FITS standard date to Besselian epoch */
dateutil0.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* FD2EPJ-- convert from FITS standard date to Julian epoch */
dateutil0.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* DT2TSU-- convert from date and time to Unix seconds since 1970-01-01T0:00 */
dateutil0.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil0.c:    return ((time_t)(dt2ts (date, time) - 631152000.0));
dateutil0.c:/* DT2TSI-- convert from date and time to IRAF seconds since 1980-01-01T0:00 */
dateutil0.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil0.c:    return ((int)(dt2ts (date, time) - 946684800.0));
dateutil0.c:/* DT2TS-- convert from date, time as yyyy.mmdd hh.mmsss to sec since 1950.0 */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c: * elapsed since 0h, March 1, -1 (up to most recent midnight). */
dateutil0.c:	tsec = time * -86400.0;
dateutil0.c:	dm = (int) (((time - dh) * 100.0) + 0.0000000001);
dateutil0.c:	tsec = (time * 10000.0) - (dh * 10000.0) - (dm * 100.0);
dateutil0.c:	im = (int) (((date - (double) (iy)) * 10000.0) + 0.00000001);
dateutil0.c:	if (im < 12) iy = iy - 1;
dateutil0.c:	id = id - 1;
dateutil0.c:	 * determines the number of whole days elapsed since 3/1/-1 and then
dateutil0.c:	id = id + ((im+1+im/6+im/11)/2 * 31) + ((im-im/6-im/11)/2 * 30) +
dateutil0.c:	     (iy / 4) - (iy / 100) + (iy / 400);
dateutil0.c:	dd = (double) id + (365.0 * (double) iy) - 712163.0;
dateutil0.c:/* TS2DT-- convert seconds since 1950.0 to date, time as yyyy.mmdd hh.mmssss */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:	*date = (double) (-iyr) + 0.01 * (double) imon + 0.0001 * (double) iday;
dateutil0.c:	*date = -(*date);
dateutil0.c:/* TSI2DT-- Convert seconds since 1980-01-01 to date yyyy.ddmm, time hh.mmsss */
dateutil0.c:int	isec;	/* Seconds past 1980-01-01 */
dateutil0.c:/* TSI2FD-- Convert seconds since 1980-01-01 to FITS standard date string */
dateutil0.c:int	isec;	/* Seconds past 1980-01-01 */
dateutil0.c:/* TSI2TS-- Convert seconds since 1980-01-01 to seconds since 1950-01-01 */
dateutil0.c:int	isec;	/* Seconds past 1980-01-01 */
dateutil0.c:/* TSU2FD-- Convert seconds since 1970-01-01 to FITS standard date string */
dateutil0.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil0.c:/* TSU2DT-- Convert seconds since 1970-01-01 to date yyyy.ddmm, time hh.mmsss */
dateutil0.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil0.c:/* TSU2TS-- Convert seconds since 1970-01-01 to seconds since 1950-01-01 */
dateutil0.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil0.c:/* TSU2TSI-- UT seconds since 1970-01-01 to local seconds since 1980-01-01 */
dateutil0.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil0.c:    if (ts->tm_year < 1000)
dateutil0.c:	date = (double) (ts->tm_year + 1900);
dateutil0.c:	date = (double) ts->tm_year;
dateutil0.c:    date = date + (0.01 * (double) (ts->tm_mon + 1));
dateutil0.c:    date = date + (0.0001 * (double) ts->tm_mday);
dateutil0.c:    time = (double) ts->tm_hour;
dateutil0.c:    time = time + (0.01 * (double) ts->tm_min);
dateutil0.c:    time = time + (0.0001 * (double) ts->tm_sec);
dateutil0.c:    return ((int)(dt2ts (date, time) - 631152000.0));
dateutil0.c:/* TS2FD-- convert seconds since 1950.0 to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil0.c:/* TSD2FD-- convert seconds since start of day to FITS time, hh:mm:ss.ss */
dateutil0.c:    nbc = lfd - 11;
dateutil0.c:/* TSD2DT-- convert seconds since start of day to hh.mmssss */
dateutil0.c:/* DT2I-- convert vigesimal date and time to year month day hours min sec */
dateutil0.c:		    *if time<0, it is time as -(fraction of a day)
dateutil0.c:	d = -date;
dateutil0.c:    t = 100.0 * (t - (double) *ihr);
dateutil0.c:    *sec = 100.0 * (t - (double) *imn);
dateutil0.c:    d = 100.0 * (d - (double) *iyr);
dateutil0.c:	*iyr = - *iyr;
dateutil0.c:    d = 100.0 * (d - (double) *imon);
dateutil0.c:/* FD2I-- convert from FITS standard date to year, mon, day, hours, min, sec */
dateutil0.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:    /* Check for various non-numeric characters */
dateutil0.c:    dstr = strchr (string,'-');
dateutil0.c:	dstr = strchr (string+1, '-');
dateutil0.c:		sstr = strchr (nval,'-');
dateutil0.c:    /* New FITS date format: yyyy-mm-ddThh:mm:ss[.sss] */
dateutil0.c:	*dstr = '-';
dateutil0.c:	dstr = strchr (nval,'-');
dateutil0.c:	    *dstr = '-';
dateutil0.c:		mn = 60.0 * (hr - (double) *ihr);
dateutil0.c:		*sec = 60.0 * (mn - (double) *imn);
dateutil0.c:	ndsec = -1;
dateutil0.c:/* TS2I-- convert sec since 1950.0 to year month day hours minutes seconds */
dateutil0.c:    /* Round seconds to 0 - 4 decimal places */
dateutil0.c:	dts = -0.5;
dateutil0.c:    days = days - (146097.0 * (double) (nc4));
dateutil0.c:    days = days - (36524.0 * nc);
dateutil0.c:    days = days - (1461.0 * (double) nly);
dateutil0.c:    days = days - (365.0 * (double) ny);
dateutil0.c:	    im = (m + ((m - 1) / 5)) % 2;
dateutil0.c:	    if (*iday-1 < im+30) break;
dateutil0.c:	    *iday = *iday - im - 30;
dateutil0.c:/* UT2DOY-- Current Universal Time as year, day of year */
dateutil0.c:/* UT2DT-- Current Universal Time as date (yyyy.mmdd) and time (hh.mmsss) */
dateutil0.c:    if (ts->tm_year < 1000)
dateutil0.c:	*date = (double) (ts->tm_year + 1900);
dateutil0.c:	*date = (double) ts->tm_year;
dateutil0.c:    *date = *date + (0.01 * (double) (ts->tm_mon + 1));
dateutil0.c:    *date = *date + (0.0001 * (double) ts->tm_mday);
dateutil0.c:    *time = (double) ts->tm_hour;
dateutil0.c:    *time = *time + (0.01 * (double) ts->tm_min);
dateutil0.c:    *time = *time + (0.0001 * (double) ts->tm_sec);
dateutil0.c:/* UT2EP-- Return current Universal Time as fractional year */
dateutil0.c:/* UT2EPB-- Return current Universal Time as Besselian epoch */
dateutil0.c:/* UT2EPJ-- Return current Universal Time as Julian epoch */
dateutil0.c:/* UT2FD-- Return current Universal Time as FITS ISO date string */
dateutil0.c:    year = ts->tm_year;
dateutil0.c:    month = ts->tm_mon + 1;
dateutil0.c:    day = ts->tm_mday;
dateutil0.c:    hour = ts->tm_hour;
dateutil0.c:    minute = ts->tm_min;
dateutil0.c:    second = ts->tm_sec; 
dateutil0.c:    sprintf (isotime, "%04d-%02d-%02dT%02d:%02d:%02d",
dateutil0.c:/* UT2JD-- Return current Universal Time as Julian Date */
dateutil0.c:/* UT2MJD-- convert current UT to Modified Julian Date */
dateutil0.c:    return (ut2jd() - 2400000.5);
dateutil0.c:/* UT2TS-- current Universal Time as IRAF seconds since 1950-01-01T00:00 */
dateutil0.c:/* UT2TSI-- current Universal Time as IRAF seconds since 1980-01-01T00:00 */
dateutil0.c:    return ((int)(ut2ts() - 946684800.0));
dateutil0.c:/* UT2TSU-- current Universal Time as IRAF seconds since 1970-01-01T00:00 */
dateutil0.c:    return ((time_t)(ut2ts () - 631152000.0));
dateutil0.c:/* FD2GST-- convert from FITS date to Greenwich Sidereal Time */
dateutil0.c:			  dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			  yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			  yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* DT2GST-- convert from UT as yyyy.mmdd hh.mmssss to Greenwich Sidereal Time*/
dateutil0.c:                 *if time<0, it is time as -(fraction of a day) */
dateutil0.c:/* JD2LST - Local Sidereal Time in seconds from Julian Date */
dateutil0.c:    lst = gst - 3600.0 * (longitude / 15.0);
dateutil0.c:	lst = lst - 86400.0;
dateutil0.c:/* FD2LST - Local Sidereal Time  as hh:mm:ss.ss
dateutil0.c:			  dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			  yyyy-mm-dd (FITS standard after 1999) */
dateutil0.c:/* DT2LST - Local Sidereal Time  as hh.mmssss
dateutil0.c:                 *if time<0, it is time as -(fraction of a day) */
dateutil0.c:/* TS2LST - Local Sidereal Time in seconds of day
dateutil0.c: *          from Universal Time in seconds since 1951-01-01T0:00:00
dateutil0.c:    lst = gst - (longitude / 15.0);
dateutil0.c:	lst = lst - 86400.0;
dateutil0.c:/* LST2FD - calculate current UT given Local Sidereal Time
dateutil0.c: *	    plus date in FITS ISO format (yyyy-mm-dd)
dateutil0.c:char *string;		/* UT Date, LST as yyyy-mm-ddShh:mm:ss.ss */
dateutil0.c:/* LST2JD - calculate current Julian Date given Local Sidereal Time
dateutil0.c:    if (dj0 > sdj) dj0 = dj0 - 1.0;
dateutil0.c:    lsd = (sdj - dj0) * 86400.0;
dateutil0.c:    tsd = (gst - gst0) / 1.0027379093;
dateutil0.c:    dj1 = dj1 - (eqnx / 86400.0);
dateutil0.c:/* MST2FD - calculate current UT given Greenwich Mean Sidereal Time
dateutil0.c: *	    plus date in FITS ISO format (yyyy-mm-ddShh:mm:ss.ss)
dateutil0.c:char *string;		/* UT Date, MST as yyyy-mm-ddShh:mm:ss.ss */
dateutil0.c:/* MST2JD - calculate current UT given Greenwich Mean Sidereal Time
dateutil0.c:    tsd = (sdj - dj0) * 86400.0;
dateutil0.c:    djd = ((tsd - st0) / 1.0027379093) / 86400.0;
dateutil0.c:/* GST2FD - calculate current UT given Greenwich Sidereal Time
dateutil0.c: *	    plus date in FITS ISO format (yyyy-mm-ddShh:mm:ss.ss)
dateutil0.c:char *string;		/* UT Date, GST as yyyy-mm-ddShh:mm:ss.ss */
dateutil0.c:/* GST2JD - calculate current UT given Greenwich Sidereal Time
dateutil0.c:    tsd = (sdj - dj0) * 86400.0;
dateutil0.c:    djd = ((tsd - st0) / 1.0027379093) / 86400.0;
dateutil0.c:    dj = dj - eqnx / 86400.0;
dateutil0.c:/* LST2DT - calculate current UT given Local Sidereal Time as hh.mmsss
dateutil0.c:    tsd = (gst - gst0) / 1.0027379093;
dateutil0.c:/* TS2GST - calculate Greenwich Sidereal Time given Universal Time
dateutil0.c: *	    in seconds since 1951-01-01T0:00:00
dateutil0.c:	its = (int) (-tsec + 0.5);
dateutil0.c:	tsd = (double) (86400 - (its % 86400));
dateutil0.c:/* FD2MST-- convert from FITS date Mean Sidereal Time */
dateutil0.c:			  dd-mm-yy (nonstandard use before 2000)
dateutil0.c:			  yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			  yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:/* DT2MST-- convert from UT as yyyy.mmdd hh.mmssss to Mean Sidereal Time
dateutil0.c:                 *if time<0, it is time as -(fraction of a day) */
dateutil0.c:/* TS2MST - calculate Greenwich Mean Sidereal Time given Universal Time
dateutil0.c: *	    in seconds since 1951-01-01T0:00:00
dateutil0.c:/* JD2MST - Julian Date to Greenwich Mean Sidereal Time using IAU 2000
dateutil0.c:    dt = dj - 2451545.0;
dateutil0.c:    st = (8640184.812866 * t) +  (3155760000.0 * t) - (0.0000062 * t3)
dateutil0.c:/* MJD2MST - Modified Julian Date to Greenwich Mean Sidereal Time using IAU 2000
dateutil0.c:    dt = dj - 51544.5;
dateutil0.c:    st = (8640184.812866 * t) +  (3155760000.0 * t) - (0.0000062 * t3)
dateutil0.c:/* JD2GST - Julian Date to Greenwich Sideral Time
dateutil0.c: *	    (Jean Meeus, Astronomical Algorithms, Willmann-Bell, 1991, pp 83-84)
dateutil0.c:    if (dj0 > dj) dj0 = dj0 - 1.0;
dateutil0.c:    tsd = (dj - dj0) * 86400.0;
dateutil0.c:/* EQEQNX - Compute equation of the equinoxes for apparent sidereal time */
dateutil0.c:/* JD2MST - Julian Date to Mean Sideral Time
dateutil0.c: *	    (Jean Meeus, Astronomical Algorithms, Willmann-Bell, 1991, pp 83-84)
dateutil0.c:    dt = dj - 2451545.0;
dateutil0.c:    mst = 280.46061837 + (360.98564736629 * dt) + (0.000387933 * t * t) -
dateutil0.c:	mst = mst - 360.0;
dateutil0.c:    mst = mst - 3600.0 * (longitude / 15.0);
dateutil0.c:	mst = mst - 86400.0;
dateutil0.c:/*  COMPNUT - Compute nutation using the IAU 2000b model */
dateutil0.c:#define NLS	77 /* number of terms in the luni-solar nutation model */
dateutil0.c: *     the nutation model consists only of luni-solar terms, but includes
dateutil0.c: *     also a fixed offset which compensates for certain long-period
dateutil0.c: *     2000.  the routine computes the mhb_2000_short luni-solar nutation
dateutil0.c: *     corrections for the essentially unpredictable free-core-nutation
dateutil0.c: *     adjustments, and nutation (luni-solar + planetary).  these total
dateutil0.c: *     precession implementation, such as iau_pmat76, to deliver gcrs-to-
dateutil0.c: *     in size but compensate for long-period nutations.  the amplitudes
dateutil0.c: *     quoted in mccarthy & luzum (2003), namely dpsi = -1.5835 mas and
dateutil0.c: *     sofa implementation, namely -0.135 mas and +0.388 mas, are
dateutil0.c: *     interval 1995-2050, the sofa implementation delivers a maximum
dateutil0.c: *     astronomical constants", Astron.Astrophys. 58, 1-2, 1-16. (1977)
dateutil0.c: *     precession-nutation of the celestial pole", Cel.Mech.Dyn.Astron.
dateutil0.c: *     85, 37-49 (2003)
dateutil0.c: *     Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,
dateutil0.c: *     Francou, G., Laskar, J., Astron.Astrophys. 282, 663-683 (1994)
dateutil0.c:    int nls = NLS; /* number of terms in the luni-solar nutation model */
dateutil0.c:    double dpplan = - 0.135 * dmas2r;
dateutil0.c:    /* Luni-solar argument multipliers: */
dateutil0.c:             0,    0,    2,   -2,    2,
dateutil0.c:             0,    1,    2,   -2,    2,
dateutil0.c:             0,   -1,    2,   -2,    2,
dateutil0.c:             0,    0,    2,   -2,    1,
dateutil0.c:            -1,    0,    2,    0,    2,
dateutil0.c:            -1,    0,    0,    2,    0,
dateutil0.c:            -1,    0,    0,    0,    1,
dateutil0.c:            -1,    0,    2,    2,    2,
dateutil0.c:            -2,    0,    2,    0,    1,
dateutil0.c:             0,   -2,    2,   -2,    2,
dateutil0.c:            -2,    0,    0,    2,    0,
dateutil0.c:             1,    0,    2,   -2,    2,
dateutil0.c:            -1,    0,    2,    0,    1,
dateutil0.c:            -1,    0,    0,    2,    1,
dateutil0.c:             0,    2,    2,   -2,    2,
dateutil0.c:             0,    0,   -2,    2,    0,
dateutil0.c:             1,    0,    0,   -2,    1,
dateutil0.c:             0,   -1,    0,    0,    1,
dateutil0.c:            -1,    0,    2,    2,    1,
dateutil0.c:            -2,    0,    2,    0,    0,
dateutil0.c:             0,   -1,    2,    0,    2,
dateutil0.c:             1,    0,    2,   -2,    1,
dateutil0.c:             2,    0,    2,   -2,    2,
dateutil0.c:            -2,    0,    0,    2,    1,
dateutil0.c:             0,   -1,    2,   -2,    1,
dateutil0.c:             0,    0,    0,   -2,    1,
dateutil0.c:            -1,   -1,    0,    2,    0,
dateutil0.c:             2,    0,    0,   -2,    1,
dateutil0.c:             0,    1,    2,   -2,    1,
dateutil0.c:             1,   -1,    0,    0,    0,
dateutil0.c:            -2,    0,    2,    0,    2,
dateutil0.c:             0,   -1,    0,    2,    0,
dateutil0.c:             1,   -1,    2,    0,    2,
dateutil0.c:            -1,   -1,    2,    2,    2,
dateutil0.c:            -1,    0,    2,    0,    0,
dateutil0.c:             0,   -1,    2,    2,    2,
dateutil0.c:            -2,    0,    0,    0,    1,
dateutil0.c:            -1,    1,    0,    1,    0,
dateutil0.c:            -1,    0,    2,   -2,    1,
dateutil0.c:            -1,    0,    0,    1,    0,
dateutil0.c:            -1,    0,    2,    4,    2,
dateutil0.c:            -1,    1,    0,    1,    1,
dateutil0.c:             0,   -2,    2,   -2,    1,
dateutil0.c:            -2,    0,    2,    2,    2,
dateutil0.c:            -1,    0,    0,    0,    2,
dateutil0.c:             1,    1,    2,   -2,    2};
dateutil0.c:    /* Luni-solar nutation coefficients, in 1e-7 arcsec */
dateutil0.c:   {-172064161.0, -174666.0,  33386.0, 92052331.0,  9086.0, 15377.0,
dateutil0.c:     -13170906.0,   -1675.0, -13696.0,  5730336.0, -3015.0, -4587.0,
dateutil0.c:      -2276413.0,    -234.0,   2796.0,   978459.0,  -485.0,  1374.0,
dateutil0.c:       2074554.0,     207.0,   -698.0,  -897492.0,   470.0,  -291.0,
dateutil0.c:       1475877.0,   -3633.0,  11817.0,    73871.0,  -184.0, -1924.0,
dateutil0.c:       -516821.0,    1226.0,   -524.0,   224386.0,  -677.0,  -174.0,
dateutil0.c:        711159.0,      73.0,   -872.0,    -6750.0,     0.0,   358.0,
dateutil0.c:       -387298.0,    -367.0,    380.0,   200728.0,    18.0,   318.0,
dateutil0.c:       -301461.0,     -36.0,    816.0,   129025.0,   -63.0,   367.0,
dateutil0.c:        215829.0,    -494.0,    111.0,   -95929.0,   299.0,   132.0,
dateutil0.c:        128227.0,     137.0,    181.0,   -68982.0,    -9.0,    39.0,
dateutil0.c:        123457.0,      11.0,     19.0,   -53311.0,    32.0,    -4.0,
dateutil0.c:        156994.0,      10.0,   -168.0,    -1235.0,     0.0,    82.0,
dateutil0.c:         63110.0,      63.0,     27.0,   -33228.0,     0.0,    -9.0,
dateutil0.c:        -57976.0,     -63.0,   -189.0,    31429.0,     0.0,   -75.0,
dateutil0.c:        -59641.0,     -11.0,    149.0,    25543.0,   -11.0,    66.0,
dateutil0.c:        -51613.0,     -42.0,    129.0,    26366.0,     0.0,    78.0,
dateutil0.c:         45893.0,      50.0,     31.0,   -24236.0,   -10.0,    20.0,
dateutil0.c:         63384.0,      11.0,   -150.0,    -1220.0,     0.0,    29.0,
dateutil0.c:        -38571.0,      -1.0,    158.0,    16452.0,   -11.0,    68.0,
dateutil0.c:         32481.0,       0.0,      0.0,   -13870.0,     0.0,     0.0,
dateutil0.c:        -47722.0,       0.0,    -18.0,      477.0,     0.0,   -25.0,
dateutil0.c:        -31046.0,      -1.0,    131.0,    13238.0,   -11.0,    59.0,
dateutil0.c:         28593.0,       0.0,     -1.0,   -12338.0,    10.0,    -3.0,
dateutil0.c:         20441.0,      21.0,     10.0,   -10758.0,     0.0,    -3.0,
dateutil0.c:         29243.0,       0.0,    -74.0,     -609.0,     0.0,    13.0,
dateutil0.c:         25887.0,       0.0,    -66.0,     -550.0,     0.0,    11.0,
dateutil0.c:        -14053.0,     -25.0,     79.0,     8551.0,    -2.0,   -45.0,
dateutil0.c:         15164.0,      10.0,     11.0,    -8001.0,     0.0,    -1.0,
dateutil0.c:        -15794.0,      72.0,    -16.0,     6850.0,   -42.0,    -5.0,
dateutil0.c:         21783.0,       0.0,     13.0,     -167.0,     0.0,    13.0,
dateutil0.c:        -12873.0,     -10.0,    -37.0,     6953.0,     0.0,   -14.0,
dateutil0.c:        -12654.0,      11.0,     63.0,     6415.0,     0.0,    26.0,
dateutil0.c:        -10204.0,       0.0,     25.0,     5222.0,     0.0,    15.0,
dateutil0.c:         16707.0,     -85.0,    -10.0,      168.0,    -1.0,    10.0,
dateutil0.c:         -7691.0,       0.0,     44.0,     3268.0,     0.0,    19.0,
dateutil0.c:        -11024.0,       0.0,    -14.0,      104.0,     0.0,     2.0,
dateutil0.c:          7566.0,     -21.0,    -11.0,    -3250.0,     0.0,    -5.0,
dateutil0.c:         -6637.0,     -11.0,     25.0,     3353.0,     0.0,    14.0,
dateutil0.c:         -7141.0,      21.0,      8.0,     3070.0,     0.0,     4.0,
dateutil0.c:         -6302.0,     -11.0,      2.0,     3272.0,     0.0,     4.0,
dateutil0.c:          5800.0,      10.0,      2.0,    -3045.0,     0.0,    -1.0,
dateutil0.c:          6443.0,       0.0,     -7.0,    -2768.0,     0.0,    -4.0,
dateutil0.c:         -5774.0,     -11.0,    -15.0,     3041.0,     0.0,    -5.0,
dateutil0.c:         -5350.0,       0.0,     21.0,     2695.0,     0.0,    12.0,
dateutil0.c:         -4752.0,     -11.0,     -3.0,     2719.0,     0.0,    -3.0,
dateutil0.c:         -4940.0,     -11.0,    -21.0,     2720.0,     0.0,    -9.0,
dateutil0.c:          7350.0,       0.0,     -8.0,      -51.0,     0.0,     4.0,
dateutil0.c:          4065.0,       0.0,      6.0,    -2206.0,     0.0,     1.0,
dateutil0.c:          6579.0,       0.0,    -24.0,     -199.0,     0.0,     2.0,
dateutil0.c:          3579.0,       0.0,      5.0,    -1900.0,     0.0,     1.0,
dateutil0.c:          4725.0,       0.0,     -6.0,      -41.0,     0.0,     3.0,
dateutil0.c:         -3075.0,       0.0,     -2.0,     1313.0,     0.0,    -1.0,
dateutil0.c:         -2904.0,       0.0,     15.0,     1233.0,     0.0,     7.0,
dateutil0.c:          4348.0,       0.0,    -10.0,      -81.0,     0.0,     2.0,
dateutil0.c:         -2878.0,       0.0,      8.0,     1232.0,     0.0,     4.0,
dateutil0.c:         -4230.0,       0.0,      5.0,      -20.0,     0.0,    -2.0,
dateutil0.c:         -2819.0,       0.0,      7.0,     1207.0,     0.0,     3.0,
dateutil0.c:         -4056.0,       0.0,      5.0,       40.0,     0.0,    -2.0,
dateutil0.c:         -2647.0,       0.0,     11.0,     1129.0,     0.0,     5.0,
dateutil0.c:         -2294.0,       0.0,    -10.0,     1266.0,     0.0,    -4.0,
dateutil0.c:          2481.0,       0.0,     -7.0,    -1062.0,     0.0,    -3.0,
dateutil0.c:          2179.0,       0.0,     -2.0,    -1129.0,     0.0,    -2.0,
dateutil0.c:          3276.0,       0.0,      1.0,       -9.0,     0.0,     0.0,
dateutil0.c:         -3389.0,       0.0,      5.0,       35.0,     0.0,    -2.0,
dateutil0.c:          3339.0,       0.0,    -13.0,     -107.0,     0.0,     1.0,
dateutil0.c:         -1987.0,       0.0,     -6.0,     1073.0,     0.0,    -2.0,
dateutil0.c:         -1981.0,       0.0,      0.0,      854.0,     0.0,     0.0,
dateutil0.c:          4026.0,       0.0,   -353.0,     -553.0,     0.0,  -139.0,
dateutil0.c:          1660.0,       0.0,     -5.0,     -710.0,     0.0,    -2.0,
dateutil0.c:         -1521.0,       0.0,      9.0,      647.0,     0.0,     4.0,
dateutil0.c:          1314.0,       0.0,      0.0,     -700.0,     0.0,     0.0,
dateutil0.c:         -1283.0,       0.0,      0.0,      672.0,     0.0,     0.0,
dateutil0.c:         -1331.0,       0.0,      8.0,      663.0,     0.0,     4.0,
dateutil0.c:          1383.0,       0.0,     -2.0,     -594.0,     0.0,    -2.0,
dateutil0.c:          1405.0,       0.0,      4.0,     -610.0,     0.0,     2.0,
dateutil0.c:          1290.0,       0.0,      0.0,     -556.0,     0.0,     0.0};
dateutil0.c:    t = (dj - dj0) / djc;
dateutil0.c:/* Luni-solar nutation */
dateutil0.c:    om  = fmod (450160.398036 - (6962890.5431 * t), as2pi ) * as2r;
dateutil0.c:    /* Summation of luni-solar nutation series (in reverse order) */
dateutil0.c:    for (i = nls; i > 0; i=i-1) {
dateutil0.c:	j = i - 1;
dateutil0.c:    /* Add luni-solar and planetary components */
dateutil0.c:	    ( -46.836769    +
dateutil0.c:	    (  -0.0001831   +
dateutil0.c:	    (  -0.000000576 +
dateutil0.c:	    (  -0.0000000434 ) * t ) * t ) * t ) * t ) * t ) * as2r;
dateutil0.c:/* ISDATE - Return 1 if string is an old or ISO FITS standard date */
dateutil0.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil0.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil0.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil0.c:    dstr = strchr (string,'-');
dateutil0.c:	dstr = strchr (string+1,'-');
dateutil0.c:	    sstr = strchr (nval,'-');
dateutil0.c:    /* New FITS date format: yyyy-mm-ddThh:mm:ss[.sss] */
dateutil0.c:	*dstr = '-';
dateutil0.c:	dstr = strchr (nval,'-');
dateutil0.c:	    *dstr = '-';
dateutil0.c:    /* Round seconds to 0 - 4 decimal places (no rounding if <0, >4) */
dateutil0.c:	*sec = *sec - 60.0;
dateutil0.c:	*imn = *imn - 60;
dateutil0.c:	*ihr = *ihr - 24;
dateutil0.c:	*iday = *iday - days;
dateutil0.c:	*imon = *imon - 1;
dateutil0.c:	    *iyr = *iyr - 1;
dateutil0.c:	*iyr = *iyr - 1;
dateutil0.c:	    *iday = *iday - days;
dateutil0.c:	*imon = *imon - 12;
dateutil0.c:/* Calculate days in month 1-12 given year (Gregorian calendar only) */
dateutil0.c:int	year;	/* 4-digit year */
dateutil0.c:	month = month - 12;
dateutil0.c:	dn = -floor (-dnum);
dateutil0.c:	dnumx = -dnum;
dateutil0.c:	dnumf = dnum - (dnumi * dm);
dateutil0.c: * Mar 14 2000	Fix bug in dealing with 2000-02-29 in ts2i()
dateutil0.c: * Jul  8 2002	If first character of string is -, check for other -'s in isdate
dateutil.c: *** Harvard-Smithsonian Center for Astrophysics
dateutil.c: *** Copyright (C) 1999-2012
dateutil.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
dateutil.c:  epb = Besselian epoch = 365.242198781-day years based on 1900.0
dateutil.c:  epj = Julian epoch = 365.25-day years based on 2000.0
dateutil.c:	dd-mm-yy (nonstandard FITS use before 2000)
dateutil.c:	yyyy-mm-dd (FITS standard after 1999)
dateutil.c:	yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999)
dateutil.c:  mjd = modified Julian Date = JD - 2400000.5
dateutil.c:   ts = UT seconds since 1950-01-01T00:00 (used for ephemeris computations)
dateutil.c:  tsi = local seconds since 1980-01-01T00:00 (used by IRAF as a time tag)
dateutil.c:  tsu = UT seconds since 1970-01-01T00:00 (used as Unix system time)
dateutil.c:  tai = International Atomic Time (Temps Atomique International) = ET - 32.184 seconds
dateutil.c:  gps = GPS time = TAI - 19 seconds
dateutil.c: mhjd = modified Heliocentric Julian Date = HJD - 2400000.5
dateutil.c: *	Convert date (yyyy.ddmm) and time (hh.mmsss) to seconds since 1950-01-01
dateutil.c: *	Convert date (yyyy.ddmm) and time (hh.mmsss) to seconds since 1980-01-01
dateutil.c: *	Convert date (yyyy.ddmm) and time (hh.mmsss) to seconds since 1970-01-01
dateutil.c: *	Convert from UT in seconds since 1950-01-01 to ET in same format
dateutil.c: *	Convert from ET in seconds since 1950-01-01 to UT in same format
dateutil.c: *	Convert FITS standard date string to old-format FITS date and time
dateutil.c: *	Convert FITS standard date string to old-format FITS date string
dateutil.c: *	Return local time as IRAF seconds since 1980-01-01 00:00
dateutil.c: *	Return local time as Unix seconds since 1970-01-01 00:00
dateutil.c: *	Return local time as Unix seconds since 1950-01-01 00:00
dateutil.c: *	Convert seconds since 1980-01-01 to FITS standard date string
dateutil.c: *	Convert seconds since 1980-01-01 to date as yyyy.ddmm, time as hh.mmsss
dateutil.c: *	Convert seconds since 1970-01-01 to FITS standard date string
dateutil.c: *	Convert UT seconds since 1970-01-01 to local seconds since 1980-01-01
dateutil.c: *	Convert seconds since 1970-01-01 to date as yyyy.ddmm, time as hh.mmsss
dateutil.c: *          in seconds since 1951-01-01T0:00:00
dateutil.c: *          in seconds since 1951-01-01T0:00:00
dateutil.c: *	Calculate Local Sidereal Time given UT in seconds since 1951-01-01T0:00
dateutil.c: *	Compute difference between UT and dynamical time (ET-UT)
dateutil.c: *	Current Universal Time to IRAF seconds since 1980-01-01T00:00
dateutil.c: *	Current Universal Time to Unix seconds since 1970-01-01T00:00
dateutil.c: *	Current Universal Time to seconds since 1950-01-01T00:00
dateutil.c: * Internally-used subroutines
dateutil.c: *	Calculate days in month 1-12 given year (Gregorian calendar only
dateutil.c:/* ANG2HR -- Convert angle in fraction degrees to hours as hh:mm:ss.ss */
dateutil.c:/* ANG2DEG -- Convert angle in fraction degrees to degrees as dd:mm:ss.ss */
dateutil.c:/* DEG2ANG -- Convert angle in degrees as dd:mm:ss.ss to fractional degrees */
dateutil.c:/* HR2ANG -- Convert angle in hours as hh:mm:ss.ss to fractional degrees */
dateutil.c:/* DT2FD-- convert vigesimal date and time to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:	sprintf (dstring, "%4d-%02d-%02d", iyr, imon, iday);
dateutil.c:/* DT2JD-- convert from date as yyyy.mmdd and time as hh.mmsss to Julian Date
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:/* DT2MJD-- convert from date yyyy.mmdd time hh.mmsss to modified Julian Date
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:    return (dj - 2400000.5);
dateutil.c:/* HJD2JD-- convert  Heliocentric Julian Date to (geocentric) Julian date */
dateutil.c:    return (dj - lt);
dateutil.c:/* JD2HJD-- convert (geocentric) Julian date to Heliocentric Julian Date */
dateutil.c:/* MHJD2MJD-- convert modified Heliocentric Julian Date to
dateutil.c:    return (jd2mjd (hjd - lt));
dateutil.c:/* MJD2MHJD-- convert modified geocentric Julian date tp
dateutil.c:/* SUNTL-- compute light travel time to heliocentric correction in days */
dateutil.c:    t = (dj - 2415020.0) / 36525.0;
dateutil.c:    manom = 358.47583 + (t * (35999.04975 - t * (0.000150 + t * 0.000003)));
dateutil.c:    oblq = 23.452294 - (t * (0.0130125 + t * (0.00000164 - t * 0.000000503)));
dateutil.c:    eccen = 0.01675104 - (t * (0.00004180 + t * 0.000000126));
dateutil.c:    manom = manom - (360.0 * (dint) (manom / 360.0));
dateutil.c:    lperi = lperi - (360.0 * (dint) (lperi / 360.0));
dateutil.c:    tanom = manom + (2 * eccen - 0.25 * eccen3) * sin (manom) +
dateutil.c:    rs1 = 1.0 - eccen2;
dateutil.c:    lt = -0.005770 * rs * cos (b) * cos (l - slong);
dateutil.c:/* JD2DT-- convert Julian date to date as yyyy.mmdd and time as hh.mmssss */
dateutil.c:	*date = (double) (-iyr) + 0.01 * (double) imon + 0.0001 * (double) iday;
dateutil.c:	*date = -(*date);
dateutil.c:/* JD2I-- convert Julian date to date as year, month, and day, and time hours,
dateutil.c:    /* Round seconds to 0 - 4 decimal places */
dateutil.c:	dts = -0.5;
dateutil.c:	jd = (int) (dj - frac);
dateutil.c:	jd = (int) (dj - frac) + 1;
dateutil.c:	sday = (frac - 0.5) * 86400.0;
dateutil.c:    sday = sday - (double) (*ihr * 3600);
dateutil.c:    *sec = sday - (double) (*imn * 60);
dateutil.c:    l = l - (146097 * n + 3) / 4;
dateutil.c:    l = l - (1461 * i) / 4 + 31;
dateutil.c:    *iday = l - (2447 * j) / 80;
dateutil.c:    *imon = j + 2 - (12 * l);
dateutil.c:    *iyr = 100 * (n - 49) + i + l;
dateutil.c:/* JD2MJD-- convert Julian Date to Modified Julian Date */
dateutil.c:    return (dj - 2400000.5);
dateutil.c:/* JD2EP-- convert Julian date to fractional year as used in epoch */
dateutil.c:/* JD2EPB-- convert Julian date to Besselian epoch */
dateutil.c:    return (1900.0 + (dj - 2415020.31352) / 365.242198781);
dateutil.c:/* JD2EPJ-- convert Julian date to Julian epoch */
dateutil.c:    return (2000.0 + (dj - 2451545.0) / 365.25);
dateutil.c:/* LT2DT-- Return local time as yyyy.mmdd and time as hh.mmssss */
dateutil.c:    if (ts->tm_year < 1000)
dateutil.c:	*date = (double) (ts->tm_year + 1900);
dateutil.c:	*date = (double) ts->tm_year;
dateutil.c:    *date = *date + (0.01 * (double) (ts->tm_mon + 1));
dateutil.c:    *date = *date + (0.0001 * (double) ts->tm_mday);
dateutil.c:    *time = (double) ts->tm_hour;
dateutil.c:    *time = *time + (0.01 * (double) ts->tm_min);
dateutil.c:    *time = *time + (0.0001 * (double) ts->tm_sec);
dateutil.c:/* LT2FD-- Return current local time as FITS ISO date string */
dateutil.c:    year = ts->tm_year;
dateutil.c:    month = ts->tm_mon + 1;
dateutil.c:    day = ts->tm_mday;
dateutil.c:    hour = ts->tm_hour;
dateutil.c:    minute = ts->tm_min;
dateutil.c:    second = ts->tm_sec;
dateutil.c:    sprintf (isotime, "%04d-%02d-%02dT%02d:%02d:%02d",
dateutil.c:/* LT2TSI-- Return local time as IRAF seconds since 1980-01-01 00:00 */
dateutil.c:    return ((int)(lt2ts() - 946684800.0));
dateutil.c:/* LT2TSU-- Return local time as Unix seconds since 1970-01-01 00:00 */
dateutil.c:    return ((time_t)(lt2ts() - 631152000.0));
dateutil.c:/* LT2TS-- Return local time as Unix seconds since 1950-01-01 00:00 */
dateutil.c:/* MJD2DT-- convert Modified Julian Date to date (yyyy.mmdd) time (hh.mmssss) */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:/* MJD2I-- convert Modified Julian Date to date as year, month, day and
dateutil.c:/* MJD2DOY-- convert Modified Julian Date to Year,Day-of-Year */
dateutil.c:/* MJD2JD-- convert Modified Julian Date to Julian Date */
dateutil.c:/* MJD2EP-- convert Modified Julian Date to fractional year */
dateutil.c:/* MJD2EPB-- convert Modified Julian Date to Besselian epoch */
dateutil.c:    return (1900.0 + (dj - 15019.81352) / 365.242198781);
dateutil.c:/* MJD2EPJ-- convert Modified Julian Date to Julian epoch */
dateutil.c:    return (2000.0 + (dj - 51544.5) / 365.25);
dateutil.c:/* MJD2FD-- convert modified Julian date to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil.c:/* MJD2TS-- convert modified Julian date to seconds since 1950.0 */
dateutil.c:    return ((dj - 33282.0) * 86400.0);
dateutil.c:/* EP2FD-- convert fractional year to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil.c:/* EPB2FD-- convert Besselian epoch to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:/* EPJ2FD-- convert Julian epoch to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:/* EP2TS-- convert fractional year to seconds since 1950.0 */
dateutil.c:    return ((dj - 2433282.5) * 86400.0);
dateutil.c:/* EPB2TS-- convert Besselian epoch to seconds since 1950.0 */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:    return ((dj - 2433282.5) * 86400.0);
dateutil.c:/* EPJ2TS-- convert Julian epoch to seconds since 1950.0 */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:    return ((dj - 2433282.5) * 86400.0);
dateutil.c:/* EPB2EP-- convert Besselian epoch to fractional years */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:/* EP2EPB-- convert fractional year to Besselian epoch */
dateutil.c:/* EPJ2EP-- convert Julian epoch to fractional year */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:/* EP2EPJ-- convert fractional year to Julian epoch */
dateutil.c:/* EP2I-- convert fractional year to year month day hours min sec */
dateutil.c:/* EPB2I-- convert Besselian epoch to year month day hours min sec */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:/* EPJ2I-- convert Julian epoch to year month day hours min sec */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:/* EP2JD-- convert fractional year as used in epoch to Julian date */
dateutil.c:/* EPB2JD-- convert Besselian epoch to Julian Date */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:    return (2415020.31352 + ((epoch - 1900.0) * 365.242198781));
dateutil.c:/* EPJ2JD-- convert Julian epoch to Julian Date */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:    return (2451545.0 + ((epoch - 2000.0) * 365.25));
dateutil.c:/* EP2MJD-- convert fractional year as used in epoch to modified Julian date */
dateutil.c:    return (dj - 2400000.5);
dateutil.c:/* EPB2MJD-- convert Besselian epoch to modified Julian Date */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:    return (15019.81352 + ((epoch - 1900.0) * 365.242198781));
dateutil.c:/* EPJ2MJD-- convert Julian epoch to modified Julian Date */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:    return (51544.5 + ((epoch - 2000.0) * 365.25));
dateutil.c:/* EPB2EPJ-- convert Besselian epoch to Julian epoch */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:/* EPJ2EPB-- convert Julian epoch to Besselian epoch */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:/* JD2FD-- convert Julian date to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil.c:    tsec = (dj - 2433282.5) * 86400.0;
dateutil.c:/* JD2TS-- convert Julian date to seconds since 1950.0 */
dateutil.c:    return ((dj - 2433282.5) * 86400.0);
dateutil.c:/* JD2TSI-- convert Julian date to IRAF seconds since 1980-01-01T0:00 */
dateutil.c:    ts = (dj - 2444239.5) * 86400.0;
dateutil.c:/* JD2TSU-- convert Julian date to Unix seconds since 1970-01-01T0:00 */
dateutil.c:    return ((time_t)((dj - 2440587.5) * 86400.0));
dateutil.c:/* DT2DOY-- convert yyyy.mmdd hh.mmss to year and day of year */
dateutil.c:    *doy = dj - dj0 + 1.0;
dateutil.c:/* DOY2DT-- convert year and day of year to yyyy.mmdd hh.mmss */
dateutil.c:    dj = dj0 + doy - 1.0;
dateutil.c:/* DOY2EP-- convert year and day of year to fractional year as used in epoch */
dateutil.c:/* DOY2EPB-- convert year and day of year to Besellian epoch */
dateutil.c:/* DOY2EPJ-- convert year and day of year to Julian epoch */
dateutil.c:/* DOY2FD-- convert year and day of year to FITS date */
dateutil.c:/* DOY2JD-- convert year and day of year to Julian date */
dateutil.c:    return (dj0 + doy - 1.0);
dateutil.c:/* DOY2MJD-- convert year and day of year to Julian date */
dateutil.c:    return (dj0 + doy - 1.0 - 2400000.5);
dateutil.c:/* DOY2TSU-- convert from FITS date to Unix seconds since 1970-01-01T0:00 */
dateutil.c:/* DOY2TSI-- convert from FITS date to IRAF seconds since 1980-01-01T0:00 */
dateutil.c:/* DOY2TS-- convert year, day of year to seconds since 1950 */
dateutil.c:/* FD2DOY-- convert FITS date to year and day of year */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* JD2DOY-- convert Julian date to year and day of year */
dateutil.c:    *doy = dj - dj0 + 1.0;
dateutil.c:/* TS2JD-- convert seconds since 1950.0 to Julian date */
dateutil.c:/* TS2MJD-- convert seconds since 1950.0 to modified Julian date */
dateutil.c:/* TS2EP-- convert seconds since 1950.0 to fractional year as used in epoch */
dateutil.c:/* TS2EPB-- convert seconds since 1950.0 to Besselian epoch */
dateutil.c:/* TS2EPB-- convert seconds since 1950.0 to Julian epoch */
dateutil.c:/* DT2EP-- convert from date, time as yyyy.mmdd hh.mmsss to fractional year */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:	epoch = dint (date) + ((dj - dj0) / (dj1 - dj0));
dateutil.c:/* DT2EPB-- convert from date, time as yyyy.mmdd hh.mmsss to Besselian epoch */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:/* DT2EPJ-- convert from date, time as yyyy.mmdd hh.mmsss to Julian epoch */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:/* EP2DT-- convert from fractional year to date, time as yyyy.mmdd hh.mmsss */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:    epochf = epoch - epochi;
dateutil.c:    dj = dj0 + epochf * (dj1 - dj0);
dateutil.c:/* EPB2DT-- convert from Besselian epoch to date, time as yyyy.mmdd hh.mmsss */
dateutil.c:double	epoch;	/* Besselian epoch (fractional 365.242198781-day years) */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:/* EPJ2DT-- convert from Julian epoch to date, time as yyyy.mmdd hh.mmsss */
dateutil.c:double	epoch;	/* Julian epoch (fractional 365.25-day years) */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:/* FD2JD-- convert FITS standard date to Julian date */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2MJD-- convert FITS standard date to modified Julian date */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:    return (fd2jd (string) - 2400000.5);
dateutil.c:/* FD2TSU-- convert from FITS date to Unix seconds since 1970-01-01T0:00 */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2TSI-- convert from FITS date to IRAF seconds since 1980-01-01T0:00 */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2TS-- convert FITS standard date to seconds since 1950 */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2FD-- convert any FITS standard date to ISO FITS standard date */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2OF-- convert any FITS standard date to old FITS standard date time */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:		 iday, imon, iyr-1900, ihr, imn, sec);
dateutil.c:		 iday, imon, iyr-1900, ihr, imn, sec);
dateutil.c:/* TAI-UTC from the U.S. Naval Observatory */
dateutil.c:/* ftp://maia.usno.navy.mil/ser7/tai-utc.dat */
dateutil.c:	   7.54, 6.97, 6.40, 6.02, 5.41, 4.10, 2.92, 1.82, 1.61, 0.10,-1.02,
dateutil.c:	  -1.28,-2.69,-3.24,-3.64,-4.54,-4.71,-5.11,-5.40,-5.42,-5.20,-5.46,
dateutil.c:	  -5.46,-5.79,-5.63,-5.64,-5.80,-5.66,-5.87,-6.01,-6.19,-6.64,-6.44,
dateutil.c:	  -6.47,-6.09,-5.76,-4.66,-3.74,-2.72,-1.54,-0.02, 1.24, 2.64, 3.86,
dateutil.c:/* TAI2FD-- convert from TAI in FITS format to UT in FITS format */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:    dj = dj0 - (dt / 86400.0);
dateutil.c:    tsec = tsec - dt + 32.184;
dateutil.c:/* FD2TAI-- convert from UT in FITS format to TAI in FITS format */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:    tsec = tsec + dt - 32.184;
dateutil.c:/* DT2TAI-- convert from UT as yyyy.mmdd hh.mmssss to TAI in same format */
dateutil.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil.c:    tsec = tsec + dt - 32.184;
dateutil.c:/* TAI2DT-- convert from TAI as yyyy.mmdd hh.mmssss to UT in same format */
dateutil.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil.c:/* ET2FD-- convert from ET (or TDT or TT) in FITS format to UT in FITS format */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:    dj = dj0 - (dt / 86400.0);
dateutil.c:    tsec = tsec - dt;
dateutil.c:/* FD2ET-- convert from UT in FITS format to ET (or TDT or TT) in FITS format */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* DT2ET-- convert from UT as yyyy.mmdd hh.mmssss to ET in same format */
dateutil.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil.c:/* EDT2DT-- convert from ET as yyyy.mmdd hh.mmssss to UT in same format */
dateutil.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil.c:/* JD2JED-- convert from Julian Date to Julian Ephemeris Date */
dateutil.c:/* JED2JD-- convert from Julian Ephemeris Date to Julian Date */
dateutil.c:    dj = dj0 - (dt / 86400.0);
dateutil.c:    return (dj - (dt / 86400.0));
dateutil.c:/* TS2ETS-- convert from UT in seconds since 1950-01-01 to ET in same format */
dateutil.c:/* ETS2TS-- convert from ET in seconds since 1950-01-01 to UT in same format */
dateutil.c:    dj = dj0 - (dt / 86400.0);
dateutil.c:    return (tsec - dt);
dateutil.c:/* UTDT-- Compute difference between UT and dynamical time (ET-UT) */
dateutil.c:    /* If after 1972-01-01, use tabulated TAI-UT */
dateutil.c:	for (i = 22;  i > 0; i--) {
dateutil.c:    /* For 1800-01-01 to 1972-01-01, use table of ET-UT from AE */
dateutil.c:	iyr = iyear - 1800;
dateutil.c:	yfrac = (ts - ts0) / (ts1 - ts0);
dateutil.c:	diff = dttab[iyr+1] - dttab[iyr];
dateutil.c:	cj = (dj - 2378496.5) / 36525.0;
dateutil.c:	dt = 5.156 + 13.3066 * (cj - 0.19) * (cj - 0.19);
dateutil.c:	cj = (dj - 2378496.5) / 36525.0;
dateutil.c:/* FD2OFD-- convert any FITS standard date to old FITS standard date */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:	sprintf (string, "%02d/%02d/%02d", iday, imon, iyr-1900);
dateutil.c:	sprintf (string, "%02d/%02d/%3d", iday, imon, iyr-1900);
dateutil.c:/* FD2OFT-- convert any FITS standard date to old FITS standard time */
dateutil.c:			dd-mm-yy (nonstandard use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2DT-- convert FITS standard date to date, time as yyyy.mmdd hh.mmsss */
dateutil.c:		    dd-mm-yy (nonstandard use before 2000)
dateutil.c:		    yyyy-mm-dd (FITS standard after 1999)
dateutil.c:		    yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:	*date = (double) (-iyr) + 0.01 * (double) imon + 0.0001 * (double) iday;
dateutil.c:	*date = -(*date);
dateutil.c:/* FD2EP-- convert from FITS standard date to fractional year */
dateutil.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2EPB-- convert from FITS standard date to Besselian epoch */
dateutil.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* FD2EPJ-- convert from FITS standard date to Julian epoch */
dateutil.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* DT2TSU-- convert from date and time to Unix seconds since 1970-01-01T0:00 */
dateutil.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil.c:    return ((time_t)(dt2ts (date, time) - 631152000.0));
dateutil.c:/* DT2TSI-- convert from date and time to IRAF seconds since 1980-01-01T0:00 */
dateutil.c:		 *if time<0, it is time as -(fraction of a day) */
dateutil.c:    return ((int)(dt2ts (date, time) - 946684800.0));
dateutil.c:/* DT2TS-- convert from date, time as yyyy.mmdd hh.mmsss to sec since 1950.0 */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c: * elapsed since 0h, March 1, -1 (up to most recent midnight). */
dateutil.c:	tsec = time * -86400.0;
dateutil.c:	dm = (int) (((time - dh) * 100.0) + 0.0000000001);
dateutil.c:	tsec = (time * 10000.0) - (dh * 10000.0) - (dm * 100.0);
dateutil.c:	im = (int) (((date - (double) (iy)) * 10000.0) + 0.00000001);
dateutil.c:	if (im < 12) iy = iy - 1;
dateutil.c:	id = id - 1;
dateutil.c:	 * determines the number of whole days elapsed since 3/1/-1 and then
dateutil.c:	id = id + ((im+1+im/6+im/11)/2 * 31) + ((im-im/6-im/11)/2 * 30) +
dateutil.c:	     (iy / 4) - (iy / 100) + (iy / 400);
dateutil.c:	dd = (double) id + (365.0 * (double) iy) - 712163.0;
dateutil.c:/* TS2DT-- convert seconds since 1950.0 to date, time as yyyy.mmdd hh.mmssss */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:	*date = (double) (-iyr) + 0.01 * (double) imon + 0.0001 * (double) iday;
dateutil.c:	*date = -(*date);
dateutil.c:/* TSI2DT-- Convert seconds since 1980-01-01 to date yyyy.ddmm, time hh.mmsss */
dateutil.c:int	isec;	/* Seconds past 1980-01-01 */
dateutil.c:/* TSI2FD-- Convert seconds since 1980-01-01 to FITS standard date string */
dateutil.c:int	isec;	/* Seconds past 1980-01-01 */
dateutil.c:/* TSI2TS-- Convert seconds since 1980-01-01 to seconds since 1950-01-01 */
dateutil.c:int	isec;	/* Seconds past 1980-01-01 */
dateutil.c:/* TSU2FD-- Convert seconds since 1970-01-01 to FITS standard date string */
dateutil.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil.c:/* TSU2DT-- Convert seconds since 1970-01-01 to date yyyy.ddmm, time hh.mmsss */
dateutil.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil.c:/* TSU2TS-- Convert seconds since 1970-01-01 to seconds since 1950-01-01 */
dateutil.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil.c:/* TSU2TSI-- UT seconds since 1970-01-01 to local seconds since 1980-01-01 */
dateutil.c:time_t	isec;	/* Seconds past 1970-01-01 */
dateutil.c:    if (ts->tm_year < 1000)
dateutil.c:	date = (double) (ts->tm_year + 1900);
dateutil.c:	date = (double) ts->tm_year;
dateutil.c:    date = date + (0.01 * (double) (ts->tm_mon + 1));
dateutil.c:    date = date + (0.0001 * (double) ts->tm_mday);
dateutil.c:    time = (double) ts->tm_hour;
dateutil.c:    time = time + (0.01 * (double) ts->tm_min);
dateutil.c:    time = time + (0.0001 * (double) ts->tm_sec);
dateutil.c:    return ((int)(dt2ts (date, time) - 631152000.0));
dateutil.c:/* TS2FD-- convert seconds since 1950.0 to FITS date, yyyy-mm-ddThh:mm:ss.ss */
dateutil.c:/* TSD2FD-- convert seconds since start of day to FITS time, hh:mm:ss.ss */
dateutil.c:    nbc = lfd - 11;
dateutil.c:/* TSD2DT-- convert seconds since start of day to hh.mmssss */
dateutil.c:/* DT2I-- convert vigesimal date and time to year month day hours min sec */
dateutil.c:		    *if time<0, it is time as -(fraction of a day)
dateutil.c:	d = -date;
dateutil.c:    t = 100.0 * (t - (double) *ihr);
dateutil.c:    *sec = 100.0 * (t - (double) *imn);
dateutil.c:    d = 100.0 * (d - (double) *iyr);
dateutil.c:	*iyr = - *iyr;
dateutil.c:    d = 100.0 * (d - (double) *imon);
dateutil.c:/* FD2I-- convert from FITS standard date to year, mon, day, hours, min, sec */
dateutil.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:    /* Check for various non-numeric characters */
dateutil.c:    dstr = strchr (string,'-');
dateutil.c:	dstr = strchr (string+1, '-');
dateutil.c:		sstr = strchr (nval,'-');
dateutil.c:    /* New FITS date format: yyyy-mm-ddThh:mm:ss[.sss] */
dateutil.c:	*dstr = '-';
dateutil.c:	dstr = strchr (nval,'-');
dateutil.c:	    *dstr = '-';
dateutil.c:		mn = 60.0 * (hr - (double) *ihr);
dateutil.c:		*sec = 60.0 * (mn - (double) *imn);
dateutil.c:	ndsec = -1;
dateutil.c:/* TS2I-- convert sec since 1950.0 to year month day hours minutes seconds */
dateutil.c:    /* Round seconds to 0 - 4 decimal places */
dateutil.c:	dts = -0.5;
dateutil.c:    days = days - (146097.0 * (double) (nc4));
dateutil.c:    days = days - (36524.0 * nc);
dateutil.c:    days = days - (1461.0 * (double) nly);
dateutil.c:    days = days - (365.0 * (double) ny);
dateutil.c:	    im = (m + ((m - 1) / 5)) % 2;
dateutil.c:	    if (*iday-1 < im+30) break;
dateutil.c:	    *iday = *iday - im - 30;
dateutil.c:/* UT2DOY-- Current Universal Time as year, day of year */
dateutil.c:/* UT2DT-- Current Universal Time as date (yyyy.mmdd) and time (hh.mmsss) */
dateutil.c:    if (ts->tm_year < 1000)
dateutil.c:	*date = (double) (ts->tm_year + 1900);
dateutil.c:	*date = (double) ts->tm_year;
dateutil.c:    *date = *date + (0.01 * (double) (ts->tm_mon + 1));
dateutil.c:    *date = *date + (0.0001 * (double) ts->tm_mday);
dateutil.c:    *time = (double) ts->tm_hour;
dateutil.c:    *time = *time + (0.01 * (double) ts->tm_min);
dateutil.c:    *time = *time + (0.0001 * (double) ts->tm_sec);
dateutil.c:/* UT2EP-- Return current Universal Time as fractional year */
dateutil.c:/* UT2EPB-- Return current Universal Time as Besselian epoch */
dateutil.c:/* UT2EPJ-- Return current Universal Time as Julian epoch */
dateutil.c:/* UT2FD-- Return current Universal Time as FITS ISO date string */
dateutil.c:    year = ts->tm_year;
dateutil.c:    month = ts->tm_mon + 1;
dateutil.c:    day = ts->tm_mday;
dateutil.c:    hour = ts->tm_hour;
dateutil.c:    minute = ts->tm_min;
dateutil.c:    second = ts->tm_sec; 
dateutil.c:    sprintf (isotime, "%04d-%02d-%02dT%02d:%02d:%02d",
dateutil.c:/* UT2JD-- Return current Universal Time as Julian Date */
dateutil.c:/* UT2MJD-- convert current UT to Modified Julian Date */
dateutil.c:    return (ut2jd() - 2400000.5);
dateutil.c:/* UT2TS-- current Universal Time as IRAF seconds since 1950-01-01T00:00 */
dateutil.c:/* UT2TSI-- current Universal Time as IRAF seconds since 1980-01-01T00:00 */
dateutil.c:    return ((int)(ut2ts() - 946684800.0));
dateutil.c:/* UT2TSU-- current Universal Time as IRAF seconds since 1970-01-01T00:00 */
dateutil.c:    return ((time_t)(ut2ts () - 631152000.0));
dateutil.c:/* FD2GST-- convert from FITS date to Greenwich Sidereal Time */
dateutil.c:			  dd-mm-yy (nonstandard use before 2000)
dateutil.c:			  yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			  yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* DT2GST-- convert from UT as yyyy.mmdd hh.mmssss to Greenwich Sidereal Time*/
dateutil.c:                 *if time<0, it is time as -(fraction of a day) */
dateutil.c:/* JD2LST - Local Sidereal Time in seconds from Julian Date */
dateutil.c:    lst = gst - (240.0 * longitude);
dateutil.c:	lst = lst - 86400.0;
dateutil.c:/* FD2LST - Local Sidereal Time  as hh:mm:ss.ss
dateutil.c:			  dd-mm-yy (nonstandard use before 2000)
dateutil.c:			  yyyy-mm-dd (FITS standard after 1999) */
dateutil.c:/* DT2LST - Local Sidereal Time  as hh.mmssss
dateutil.c:                 *if time<0, it is time as -(fraction of a day) */
dateutil.c:/* TS2LST - Local Sidereal Time in seconds of day
dateutil.c: *          from Universal Time in seconds since 1951-01-01T0:00:00
dateutil.c:    lst = gst - (longitude / 15.0);
dateutil.c:	lst = lst - 86400.0;
dateutil.c:/* LST2FD - calculate current UT given Local Sidereal Time
dateutil.c: *	    plus date in FITS ISO format (yyyy-mm-dd)
dateutil.c:char *string;		/* UT Date, LST as yyyy-mm-ddShh:mm:ss.ss */
dateutil.c:/* LST2JD - calculate current Julian Date given Local Sidereal Time
dateutil.c:    if (dj0 > sdj) dj0 = dj0 - 1.0;
dateutil.c:    lsd = (sdj - dj0) * 86400.0;
dateutil.c:    tsd = (gst - gst0) / 1.0027379093;
dateutil.c:    dj1 = dj1 - (eqnx / 86400.0);
dateutil.c:/* MST2FD - calculate current UT given Greenwich Mean Sidereal Time
dateutil.c: *	    plus date in FITS ISO format (yyyy-mm-ddShh:mm:ss.ss)
dateutil.c:char *string;		/* UT Date, MST as yyyy-mm-ddShh:mm:ss.ss */
dateutil.c:/* MST2JD - calculate current UT given Greenwich Mean Sidereal Time
dateutil.c:    tsd = (sdj - dj0) * 86400.0;
dateutil.c:    djd = ((tsd - st0) / 1.0027379093) / 86400.0;
dateutil.c:/* GST2FD - calculate current UT given Greenwich Sidereal Time
dateutil.c: *	    plus date in FITS ISO format (yyyy-mm-ddShh:mm:ss.ss)
dateutil.c:char *string;		/* UT Date, GST as yyyy-mm-ddShh:mm:ss.ss */
dateutil.c:/* GST2JD - calculate current UT given Greenwich Sidereal Time
dateutil.c:    tsd = (sdj - dj0) * 86400.0;
dateutil.c:    djd = ((tsd - st0) / 1.0027379093) / 86400.0;
dateutil.c:    dj = dj - eqnx / 86400.0;
dateutil.c:/* LST2DT - calculate current UT given Local Sidereal Time as hh.mmsss
dateutil.c:    tsd = (gst - gst0) / 1.0027379093;
dateutil.c:/* TS2GST - calculate Greenwich Sidereal Time given Universal Time
dateutil.c: *	    in seconds since 1951-01-01T0:00:00
dateutil.c:	its = (int) (-tsec + 0.5);
dateutil.c:	tsd = (double) (86400 - (its % 86400));
dateutil.c:/* FD2MST-- convert from FITS date Mean Sidereal Time */
dateutil.c:			  dd-mm-yy (nonstandard use before 2000)
dateutil.c:			  yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			  yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:/* DT2MST-- convert from UT as yyyy.mmdd hh.mmssss to Mean Sidereal Time
dateutil.c:                 *if time<0, it is time as -(fraction of a day) */
dateutil.c:/* TS2MST - calculate Greenwich Mean Sidereal Time given Universal Time
dateutil.c: *	    in seconds since 1951-01-01T0:00:00
dateutil.c:/* JD2MST - Julian Date to Greenwich Mean Sidereal Time using IAU 2000
dateutil.c:    dt = dj - 2451545.0;
dateutil.c:    st = (8640184.812866 * t) +  (3155760000.0 * t) - (0.0000062 * t3)
dateutil.c:/* MJD2MST - Modified Julian Date to Greenwich Mean Sidereal Time using IAU 2000
dateutil.c:    dt = dj - 51544.5;
dateutil.c:    st = (8640184.812866 * t) +  (3155760000.0 * t) - (0.0000062 * t3)
dateutil.c:/* JD2GST - Julian Date to Greenwich Sideral Time
dateutil.c: *	    (Jean Meeus, Astronomical Algorithms, Willmann-Bell, 1991, pp 83-84)
dateutil.c:    if (dj0 > dj) dj0 = dj0 - 1.0;
dateutil.c:    tsd = (dj - dj0) * 86400.0;
dateutil.c:/* EQEQNX - Compute equation of the equinoxes for apparent sidereal time */
dateutil.c:/* JD2MST - Julian Date to Mean Sideral Time
dateutil.c: *	    (Jean Meeus, Astronomical Algorithms, Willmann-Bell, 1991, pp 83-84)
dateutil.c:    dt = dj - 2451545.0;
dateutil.c:    mst = 280.46061837 + (360.98564736629 * dt) + (0.000387933 * t * t) -
dateutil.c:	mst = mst - 360.0;
dateutil.c:    mst = mst - (240.0 * longitude);
dateutil.c:	mst = mst - 86400.0;
dateutil.c:/*  COMPNUT - Compute nutation using the IAU 2000b model */
dateutil.c:#define NLS	77 /* number of terms in the luni-solar nutation model */
dateutil.c: *     the nutation model consists only of luni-solar terms, but includes
dateutil.c: *     also a fixed offset which compensates for certain long-period
dateutil.c: *     2000.  the routine computes the mhb_2000_short luni-solar nutation
dateutil.c: *     corrections for the essentially unpredictable free-core-nutation
dateutil.c: *     adjustments, and nutation (luni-solar + planetary).  these total
dateutil.c: *     precession implementation, such as iau_pmat76, to deliver gcrs-to-
dateutil.c: *     in size but compensate for long-period nutations.  the amplitudes
dateutil.c: *     quoted in mccarthy & luzum (2003), namely dpsi = -1.5835 mas and
dateutil.c: *     sofa implementation, namely -0.135 mas and +0.388 mas, are
dateutil.c: *     interval 1995-2050, the sofa implementation delivers a maximum
dateutil.c: *     astronomical constants", Astron.Astrophys. 58, 1-2, 1-16. (1977)
dateutil.c: *     precession-nutation of the celestial pole", Cel.Mech.Dyn.Astron.
dateutil.c: *     85, 37-49 (2003)
dateutil.c: *     Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,
dateutil.c: *     Francou, G., Laskar, J., Astron.Astrophys. 282, 663-683 (1994)
dateutil.c:    int nls = NLS; /* number of terms in the luni-solar nutation model */
dateutil.c:    double dpplan = - 0.135 * dmas2r;
dateutil.c:    /* Luni-solar argument multipliers: */
dateutil.c:             0,    0,    2,   -2,    2,
dateutil.c:             0,    1,    2,   -2,    2,
dateutil.c:             0,   -1,    2,   -2,    2,
dateutil.c:             0,    0,    2,   -2,    1,
dateutil.c:            -1,    0,    2,    0,    2,
dateutil.c:            -1,    0,    0,    2,    0,
dateutil.c:            -1,    0,    0,    0,    1,
dateutil.c:            -1,    0,    2,    2,    2,
dateutil.c:            -2,    0,    2,    0,    1,
dateutil.c:             0,   -2,    2,   -2,    2,
dateutil.c:            -2,    0,    0,    2,    0,
dateutil.c:             1,    0,    2,   -2,    2,
dateutil.c:            -1,    0,    2,    0,    1,
dateutil.c:            -1,    0,    0,    2,    1,
dateutil.c:             0,    2,    2,   -2,    2,
dateutil.c:             0,    0,   -2,    2,    0,
dateutil.c:             1,    0,    0,   -2,    1,
dateutil.c:             0,   -1,    0,    0,    1,
dateutil.c:            -1,    0,    2,    2,    1,
dateutil.c:            -2,    0,    2,    0,    0,
dateutil.c:             0,   -1,    2,    0,    2,
dateutil.c:             1,    0,    2,   -2,    1,
dateutil.c:             2,    0,    2,   -2,    2,
dateutil.c:            -2,    0,    0,    2,    1,
dateutil.c:             0,   -1,    2,   -2,    1,
dateutil.c:             0,    0,    0,   -2,    1,
dateutil.c:            -1,   -1,    0,    2,    0,
dateutil.c:             2,    0,    0,   -2,    1,
dateutil.c:             0,    1,    2,   -2,    1,
dateutil.c:             1,   -1,    0,    0,    0,
dateutil.c:            -2,    0,    2,    0,    2,
dateutil.c:             0,   -1,    0,    2,    0,
dateutil.c:             1,   -1,    2,    0,    2,
dateutil.c:            -1,   -1,    2,    2,    2,
dateutil.c:            -1,    0,    2,    0,    0,
dateutil.c:             0,   -1,    2,    2,    2,
dateutil.c:            -2,    0,    0,    0,    1,
dateutil.c:            -1,    1,    0,    1,    0,
dateutil.c:            -1,    0,    2,   -2,    1,
dateutil.c:            -1,    0,    0,    1,    0,
dateutil.c:            -1,    0,    2,    4,    2,
dateutil.c:            -1,    1,    0,    1,    1,
dateutil.c:             0,   -2,    2,   -2,    1,
dateutil.c:            -2,    0,    2,    2,    2,
dateutil.c:            -1,    0,    0,    0,    2,
dateutil.c:             1,    1,    2,   -2,    2};
dateutil.c:    /* Luni-solar nutation coefficients, in 1e-7 arcsec */
dateutil.c:   {-172064161.0, -174666.0,  33386.0, 92052331.0,  9086.0, 15377.0,
dateutil.c:     -13170906.0,   -1675.0, -13696.0,  5730336.0, -3015.0, -4587.0,
dateutil.c:      -2276413.0,    -234.0,   2796.0,   978459.0,  -485.0,  1374.0,
dateutil.c:       2074554.0,     207.0,   -698.0,  -897492.0,   470.0,  -291.0,
dateutil.c:       1475877.0,   -3633.0,  11817.0,    73871.0,  -184.0, -1924.0,
dateutil.c:       -516821.0,    1226.0,   -524.0,   224386.0,  -677.0,  -174.0,
dateutil.c:        711159.0,      73.0,   -872.0,    -6750.0,     0.0,   358.0,
dateutil.c:       -387298.0,    -367.0,    380.0,   200728.0,    18.0,   318.0,
dateutil.c:       -301461.0,     -36.0,    816.0,   129025.0,   -63.0,   367.0,
dateutil.c:        215829.0,    -494.0,    111.0,   -95929.0,   299.0,   132.0,
dateutil.c:        128227.0,     137.0,    181.0,   -68982.0,    -9.0,    39.0,
dateutil.c:        123457.0,      11.0,     19.0,   -53311.0,    32.0,    -4.0,
dateutil.c:        156994.0,      10.0,   -168.0,    -1235.0,     0.0,    82.0,
dateutil.c:         63110.0,      63.0,     27.0,   -33228.0,     0.0,    -9.0,
dateutil.c:        -57976.0,     -63.0,   -189.0,    31429.0,     0.0,   -75.0,
dateutil.c:        -59641.0,     -11.0,    149.0,    25543.0,   -11.0,    66.0,
dateutil.c:        -51613.0,     -42.0,    129.0,    26366.0,     0.0,    78.0,
dateutil.c:         45893.0,      50.0,     31.0,   -24236.0,   -10.0,    20.0,
dateutil.c:         63384.0,      11.0,   -150.0,    -1220.0,     0.0,    29.0,
dateutil.c:        -38571.0,      -1.0,    158.0,    16452.0,   -11.0,    68.0,
dateutil.c:         32481.0,       0.0,      0.0,   -13870.0,     0.0,     0.0,
dateutil.c:        -47722.0,       0.0,    -18.0,      477.0,     0.0,   -25.0,
dateutil.c:        -31046.0,      -1.0,    131.0,    13238.0,   -11.0,    59.0,
dateutil.c:         28593.0,       0.0,     -1.0,   -12338.0,    10.0,    -3.0,
dateutil.c:         20441.0,      21.0,     10.0,   -10758.0,     0.0,    -3.0,
dateutil.c:         29243.0,       0.0,    -74.0,     -609.0,     0.0,    13.0,
dateutil.c:         25887.0,       0.0,    -66.0,     -550.0,     0.0,    11.0,
dateutil.c:        -14053.0,     -25.0,     79.0,     8551.0,    -2.0,   -45.0,
dateutil.c:         15164.0,      10.0,     11.0,    -8001.0,     0.0,    -1.0,
dateutil.c:        -15794.0,      72.0,    -16.0,     6850.0,   -42.0,    -5.0,
dateutil.c:         21783.0,       0.0,     13.0,     -167.0,     0.0,    13.0,
dateutil.c:        -12873.0,     -10.0,    -37.0,     6953.0,     0.0,   -14.0,
dateutil.c:        -12654.0,      11.0,     63.0,     6415.0,     0.0,    26.0,
dateutil.c:        -10204.0,       0.0,     25.0,     5222.0,     0.0,    15.0,
dateutil.c:         16707.0,     -85.0,    -10.0,      168.0,    -1.0,    10.0,
dateutil.c:         -7691.0,       0.0,     44.0,     3268.0,     0.0,    19.0,
dateutil.c:        -11024.0,       0.0,    -14.0,      104.0,     0.0,     2.0,
dateutil.c:          7566.0,     -21.0,    -11.0,    -3250.0,     0.0,    -5.0,
dateutil.c:         -6637.0,     -11.0,     25.0,     3353.0,     0.0,    14.0,
dateutil.c:         -7141.0,      21.0,      8.0,     3070.0,     0.0,     4.0,
dateutil.c:         -6302.0,     -11.0,      2.0,     3272.0,     0.0,     4.0,
dateutil.c:          5800.0,      10.0,      2.0,    -3045.0,     0.0,    -1.0,
dateutil.c:          6443.0,       0.0,     -7.0,    -2768.0,     0.0,    -4.0,
dateutil.c:         -5774.0,     -11.0,    -15.0,     3041.0,     0.0,    -5.0,
dateutil.c:         -5350.0,       0.0,     21.0,     2695.0,     0.0,    12.0,
dateutil.c:         -4752.0,     -11.0,     -3.0,     2719.0,     0.0,    -3.0,
dateutil.c:         -4940.0,     -11.0,    -21.0,     2720.0,     0.0,    -9.0,
dateutil.c:          7350.0,       0.0,     -8.0,      -51.0,     0.0,     4.0,
dateutil.c:          4065.0,       0.0,      6.0,    -2206.0,     0.0,     1.0,
dateutil.c:          6579.0,       0.0,    -24.0,     -199.0,     0.0,     2.0,
dateutil.c:          3579.0,       0.0,      5.0,    -1900.0,     0.0,     1.0,
dateutil.c:          4725.0,       0.0,     -6.0,      -41.0,     0.0,     3.0,
dateutil.c:         -3075.0,       0.0,     -2.0,     1313.0,     0.0,    -1.0,
dateutil.c:         -2904.0,       0.0,     15.0,     1233.0,     0.0,     7.0,
dateutil.c:          4348.0,       0.0,    -10.0,      -81.0,     0.0,     2.0,
dateutil.c:         -2878.0,       0.0,      8.0,     1232.0,     0.0,     4.0,
dateutil.c:         -4230.0,       0.0,      5.0,      -20.0,     0.0,    -2.0,
dateutil.c:         -2819.0,       0.0,      7.0,     1207.0,     0.0,     3.0,
dateutil.c:         -4056.0,       0.0,      5.0,       40.0,     0.0,    -2.0,
dateutil.c:         -2647.0,       0.0,     11.0,     1129.0,     0.0,     5.0,
dateutil.c:         -2294.0,       0.0,    -10.0,     1266.0,     0.0,    -4.0,
dateutil.c:          2481.0,       0.0,     -7.0,    -1062.0,     0.0,    -3.0,
dateutil.c:          2179.0,       0.0,     -2.0,    -1129.0,     0.0,    -2.0,
dateutil.c:          3276.0,       0.0,      1.0,       -9.0,     0.0,     0.0,
dateutil.c:         -3389.0,       0.0,      5.0,       35.0,     0.0,    -2.0,
dateutil.c:          3339.0,       0.0,    -13.0,     -107.0,     0.0,     1.0,
dateutil.c:         -1987.0,       0.0,     -6.0,     1073.0,     0.0,    -2.0,
dateutil.c:         -1981.0,       0.0,      0.0,      854.0,     0.0,     0.0,
dateutil.c:          4026.0,       0.0,   -353.0,     -553.0,     0.0,  -139.0,
dateutil.c:          1660.0,       0.0,     -5.0,     -710.0,     0.0,    -2.0,
dateutil.c:         -1521.0,       0.0,      9.0,      647.0,     0.0,     4.0,
dateutil.c:          1314.0,       0.0,      0.0,     -700.0,     0.0,     0.0,
dateutil.c:         -1283.0,       0.0,      0.0,      672.0,     0.0,     0.0,
dateutil.c:         -1331.0,       0.0,      8.0,      663.0,     0.0,     4.0,
dateutil.c:          1383.0,       0.0,     -2.0,     -594.0,     0.0,    -2.0,
dateutil.c:          1405.0,       0.0,      4.0,     -610.0,     0.0,     2.0,
dateutil.c:          1290.0,       0.0,      0.0,     -556.0,     0.0,     0.0};
dateutil.c:    t = (dj - dj0) / djc;
dateutil.c:/* Luni-solar nutation */
dateutil.c:    om  = fmod (450160.398036 - (6962890.5431 * t), as2pi ) * as2r;
dateutil.c:    /* Summation of luni-solar nutation series (in reverse order) */
dateutil.c:    for (i = nls; i > 0; i=i-1) {
dateutil.c:	j = i - 1;
dateutil.c:    /* Add luni-solar and planetary components */
dateutil.c:	    ( -46.836769    +
dateutil.c:	    (  -0.0001831   +
dateutil.c:	    (  -0.000000576 +
dateutil.c:	    (  -0.0000000434 ) * t ) * t ) * t ) * t ) * t ) * as2r;
dateutil.c:/* ISDATE - Return 1 if string is an old or ISO FITS standard date */
dateutil.c:			dd-mm-yy (nonstandard FITS use before 2000)
dateutil.c:			yyyy-mm-dd (FITS standard after 1999)
dateutil.c:			yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
dateutil.c:    dstr = strchr (string,'-');
dateutil.c:	dstr = strchr (string+1,'-');
dateutil.c:	    sstr = strchr (nval,'-');
dateutil.c:    /* New FITS date format: yyyy-mm-ddThh:mm:ss[.sss] */
dateutil.c:	*dstr = '-';
dateutil.c:	dstr = strchr (nval,'-');
dateutil.c:	    *dstr = '-';
dateutil.c:    /* Round seconds to 0 - 4 decimal places (no rounding if <0, >4) */
dateutil.c:	*sec = *sec - 60.0;
dateutil.c:	*imn = *imn - 60;
dateutil.c:	*ihr = *ihr - 24;
dateutil.c:	*iday = *iday - days;
dateutil.c:	*imon = *imon - 1;
dateutil.c:	    *iyr = *iyr - 1;
dateutil.c:	*iyr = *iyr - 1;
dateutil.c:	    *iday = *iday - days;
dateutil.c:	*imon = *imon - 12;
dateutil.c:/* Calculate days in month 1-12 given year (Gregorian calendar only) */
dateutil.c:int	year;	/* 4-digit year */
dateutil.c:	month = month - 12;
dateutil.c:	dn = -floor (-dnum);
dateutil.c:	dnumx = -dnum;
dateutil.c:	dnumf = dnum - (dnumi * dm);
dateutil.c: * Mar 14 2000	Fix bug in dealing with 2000-02-29 in ts2i()
dateutil.c: * Jul  8 2002	If first character of string is -, check for other -'s in isdate
distort:actread.c:    sysout = wcs->syswcs;
distort:actread.c:    eqout = wcs->equinox;
distort:actread.c:    epout = wcs->epoch;
distort:binread.c:    sysout = wcs->syswcs;
distort:binread.c:    eqout = wcs->equinox;
distort:binread.c:    epout = wcs->epoch;
distort:ctgread.c:    sysout = wcs->syswcs;
distort:ctgread.c:    eqout = wcs->equinox;
distort:ctgread.c:    epout = wcs->epoch;
distort:distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort:distort.c:	if (wcs->wcsproj == WCS_OLD) {
distort:distort.c:	    wcs->wcsproj = WCS_NEW;
distort:distort.c:	    wcs->distort.a_order = 0;
distort:distort.c:	    wcs->distort.b_order = 0;
distort:distort.c:	    wcs->distort.ap_order = 0;
distort:distort.c:	    wcs->distort.bp_order = 0;
distort:distort.c:	    if (!hgeti4 (hstring, "A_ORDER", &wcs->distort.a_order)) {
distort:distort.c:		m = wcs->distort.a_order;
distort:distort.c:			wcs->distort.a[i][j] = 0.0;
distort:distort.c:			hgetr8 (hstring, keyword, &wcs->distort.a[i][j]);
distort:distort.c:	    if (!hgeti4 (hstring, "B_ORDER", &wcs->distort.b_order)) {
distort:distort.c:		m = wcs->distort.b_order;
distort:distort.c:			wcs->distort.b[i][j] = 0.0;
distort:distort.c:			hgetr8 (hstring, keyword, &wcs->distort.b[i][j]);
distort:distort.c:	    if (!hgeti4 (hstring, "AP_ORDER", &wcs->distort.ap_order)) {
distort:distort.c:		m = wcs->distort.ap_order;
distort:distort.c:			wcs->distort.ap[i][j] = 0.0;
distort:distort.c:			hgetr8 (hstring, keyword, &wcs->distort.ap[i][j]);
distort:distort.c:	    if (!hgeti4 (hstring, "BP_ORDER", &wcs->distort.bp_order)) {
distort:distort.c:		m = wcs->distort.bp_order;
distort:distort.c:			wcs->distort.bp[i][j] = 0.0;
distort:distort.c:			hgetr8 (hstring, keyword, &wcs->distort.bp[i][j]);
distort:distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort:distort.c:	m = wcs->distort.ap_order;
distort:distort.c:	n = wcs->distort.bp_order;
distort:distort.c:	temp_x = x - wcs->xrefpix;
distort:distort.c:	temp_y = y - wcs->yrefpix;
distort:distort.c:	    s[j] = wcs->distort.ap[m-j][j];
distort:distort.c:	   	s[j] = (temp_y * s[j]) + wcs->distort.ap[m-j][k];
distort:distort.c:	    s[j] = wcs->distort.bp[n-j][j];
distort:distort.c:		s[j] = temp_y*s[j] + wcs->distort.bp[n-j][k];
distort:distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort:distort.c:	m = wcs->distort.a_order;
distort:distort.c:	n = wcs->distort.b_order;
distort:distort.c:	temp_u = u - wcs->xrefpix;
distort:distort.c:	temp_v = v - wcs->yrefpix;
distort:distort.c:	    s[j] = wcs->distort.a[m-j][j];
distort:distort.c:		s[j] = (temp_v * s[j]) + wcs->distort.a[m-j][k];
distort:distort.c:	    s[j] = wcs->distort.b[n-j][j];
distort:distort.c:		s[j] =temp_v*s[j] + wcs->distort.b[n-j][k];
distort:distort.c:	wcs->distcode = DISTORT_NONE;
distort:distort.c:	    wcs->distcode = DISTORT_SIRTF;
distort:distort.c:	    wcs->distcode = DISTORT_NONE;
distort:distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort:dsspos.c:  x = xpix + wcs->x_pixel_offset - 1.0 + 0.5;
distort:dsspos.c:  y = ypix + wcs->y_pixel_offset - 1.0 + 0.5;
distort:dsspos.c:  xmm = (wcs->ppo_coeff[2] - x * wcs->x_pixel_size) / 1000.0;
distort:dsspos.c:  ymm = (y * wcs->y_pixel_size - wcs->ppo_coeff[5]) / 1000.0;
distort:dsspos.c:  xi =  wcs->x_coeff[ 0]*xmm	+ wcs->x_coeff[ 1]*ymm +
distort:dsspos.c:	wcs->x_coeff[ 2]		+ wcs->x_coeff[ 3]*xmm2 +
distort:dsspos.c:	wcs->x_coeff[ 4]*xmm*ymm	+ wcs->x_coeff[ 5]*ymm2 +
distort:dsspos.c:	wcs->x_coeff[ 6]*(x2y2)	+ wcs->x_coeff[ 7]*xmm3 +
distort:dsspos.c:	wcs->x_coeff[ 8]*xmm2*ymm	+ wcs->x_coeff[ 9]*xmm*ymm2 +
distort:dsspos.c:	wcs->x_coeff[10]*ymm3	+ wcs->x_coeff[11]*xmm*(x2y2) +
distort:dsspos.c:	wcs->x_coeff[12]*xmm*x2y2*x2y2;
distort:dsspos.c:	+ wcs->x_coeff[13]*mag	+ wcs->x_coeff[14]*mag*mag +
distort:dsspos.c:	wcs->x_coeff[15]*mag*mag*mag + wcs->x_coeff[16]*mag*xmm +
distort:dsspos.c:	wcs->x_coeff[17]*mag*x2y2	+ wcs->x_coeff[18]*mag*xmm*x2y2 +
distort:dsspos.c:	wcs->x_coeff[19]*color; */
distort:dsspos.c:  eta =	wcs->y_coeff[ 0]*ymm	+ wcs->y_coeff[ 1]*xmm +
distort:dsspos.c:	wcs->y_coeff[ 2]		+ wcs->y_coeff[ 3]*ymm2 +
distort:dsspos.c:	wcs->y_coeff[ 4]*xmm*ymm	+ wcs->y_coeff[ 5]*xmm2 +
distort:dsspos.c:	wcs->y_coeff[ 6]*(x2y2)	+ wcs->y_coeff[ 7]*ymm3 +
distort:dsspos.c:	wcs->y_coeff[ 8]*ymm2*xmm	+ wcs->y_coeff[ 9]*ymm*xmm2 +
distort:dsspos.c:	wcs->y_coeff[10]*xmm3	+ wcs->y_coeff[11]*ymm*(x2y2) +
distort:dsspos.c:	wcs->y_coeff[12]*ymm*x2y2*x2y2;
distort:dsspos.c:	+ wcs->y_coeff[13]*mag	+ wcs->y_coeff[14]*mag*mag +
distort:dsspos.c:	wcs->y_coeff[15]*mag*mag*mag + wcs->y_coeff[16]*mag*ymm +
distort:dsspos.c:	wcs->y_coeff[17]*mag*x2y2)	+ wcs->y_coeff[18]*mag*ymm*x2y2 +
distort:dsspos.c:	wcs->y_coeff[19]*color; */
distort:dsspos.c:  ctan = tan (wcs->plate_dec);
distort:dsspos.c:  ccos = cos (wcs->plate_dec);
distort:dsspos.c:  ra = raoff + wcs->plate_ra;
distort:dsspos.c:  if (wcs->plate_dec == 0.0)
distort:dsspos.c:    wcs->plate_dec = degrad (wcs->yref);
distort:dsspos.c:  syplate = sin (wcs->plate_dec);
distort:dsspos.c:  cyplate = cos (wcs->plate_dec);
distort:dsspos.c:  if (wcs->plate_ra == 0.0)
distort:dsspos.c:    wcs->plate_ra = degrad (wcs->yref);
distort:dsspos.c:  sxdiff = sin (xr - wcs->plate_ra);
distort:dsspos.c:  cxdiff = cos (xr - wcs->plate_ra);
distort:dsspos.c:  if (wcs->plate_scale == 0.0)
distort:dsspos.c:  xmm = xi / wcs->plate_scale;
distort:dsspos.c:  ymm = eta / wcs->plate_scale;
distort:dsspos.c:    f = wcs->x_coeff[0]*xmm      + wcs->x_coeff[1]*ymm +
distort:dsspos.c:        wcs->x_coeff[2]          + wcs->x_coeff[3]*x2 +
distort:dsspos.c:        wcs->x_coeff[4]*xy       + wcs->x_coeff[5]*y2 +
distort:dsspos.c:        wcs->x_coeff[6]*x2y2     + wcs->x_coeff[7]*x3 +
distort:dsspos.c:        wcs->x_coeff[8]*x2y      + wcs->x_coeff[9]*y2x +
distort:dsspos.c:        wcs->x_coeff[10]*y3      + wcs->x_coeff[11]*xmm*x2y2 +
distort:dsspos.c:        wcs->x_coeff[12]*xmm*cjunk;
distort:dsspos.c:      + wcs->x_coeff[13]*mag +
distort:dsspos.c:        wcs->x_coeff[14]*mag*mag   + wcs->x_coeff[15]*mag*mag*mag +
distort:dsspos.c:        wcs->x_coeff[16]*mag*xmm   + wcs->x_coeff[17]*mag*(x2+y2) +
distort:dsspos.c:        wcs->x_coeff[18]*mag*xmm*(x2+y2)  + wcs->x_coeff[19]*color;
distort:dsspos.c:    fx = wcs->x_coeff[0]           + wcs->x_coeff[3]*2.0*xmm +
distort:dsspos.c:         wcs->x_coeff[4]*ymm       + wcs->x_coeff[6]*2.0*xmm +
distort:dsspos.c:         wcs->x_coeff[7]*3.0*x2    + wcs->x_coeff[8]*2.0*xy +
distort:dsspos.c:         wcs->x_coeff[9]*y2        + wcs->x_coeff[11]*(3.0*x2+y2) +
distort:dsspos.c:         wcs->x_coeff[12]*(5.0*x4 +6.0*x2*y2+y4);
distort:dsspos.c:         wcs->x_coeff[16]*mag      + wcs->x_coeff[17]*mag*2.0*xmm +
distort:dsspos.c:         wcs->x_coeff[18]*mag*(3.0*x2+y2);
distort:dsspos.c:    fy = wcs->x_coeff[1]           + wcs->x_coeff[4]*xmm +
distort:dsspos.c:         wcs->x_coeff[5]*2.0*ymm   + wcs->x_coeff[6]*2.0*ymm +
distort:dsspos.c:         wcs->x_coeff[8]*x2        + wcs->x_coeff[9]*2.0*xy +
distort:dsspos.c:         wcs->x_coeff[10]*3.0*y2   + wcs->x_coeff[11]*2.0*xy +
distort:dsspos.c:         wcs->x_coeff[12]*4.0*xy*x2y2;
distort:dsspos.c:         wcs->x_coeff[17]*mag*2.0*ymm +
distort:dsspos.c:         wcs->x_coeff[18]*mag*2.0*xy;
distort:dsspos.c:    g = wcs->y_coeff[0]*ymm       + wcs->y_coeff[1]*xmm +
distort:dsspos.c:       wcs->y_coeff[2]            + wcs->y_coeff[3]*y2 +
distort:dsspos.c:       wcs->y_coeff[4]*xy         + wcs->y_coeff[5]*x2 +
distort:dsspos.c:       wcs->y_coeff[6]*x2y2       + wcs->y_coeff[7]*y3 +
distort:dsspos.c:       wcs->y_coeff[8]*y2x        + wcs->y_coeff[9]*x2y +
distort:dsspos.c:       wcs->y_coeff[10]*x3        + wcs->y_coeff[11]*ymm*x2y2 +
distort:dsspos.c:       wcs->y_coeff[12]*ymm*cjunk;
distort:dsspos.c:       wcs->y_coeff[13]*mag        + wcs->y_coeff[14]*mag*mag +
distort:dsspos.c:       wcs->y_coeff[15]*mag*mag*mag + wcs->y_coeff[16]*mag*ymm +
distort:dsspos.c:       wcs->y_coeff[17]*mag*x2y2 +
distort:dsspos.c:       wcs->y_coeff[18]*mag*ymm*x2y2 + wcs->y_coeff[19]*color;
distort:dsspos.c:    gx = wcs->y_coeff[1]           + wcs->y_coeff[4]*ymm +
distort:dsspos.c:         wcs->y_coeff[5]*2.0*xmm   + wcs->y_coeff[6]*2.0*xmm +
distort:dsspos.c:         wcs->y_coeff[8]*y2       + wcs->y_coeff[9]*2.0*xy +
distort:dsspos.c:         wcs->y_coeff[10]*3.0*x2  + wcs->y_coeff[11]*2.0*xy +
distort:dsspos.c:         wcs->y_coeff[12]*4.0*xy*x2y2;
distort:dsspos.c:         wcs->y_coeff[17]*mag*2.0*xmm +
distort:dsspos.c:         wcs->y_coeff[18]*mag*ymm*2.0*xmm;
distort:dsspos.c:    gy = wcs->y_coeff[0]            + wcs->y_coeff[3]*2.0*ymm +
distort:dsspos.c:         wcs->y_coeff[4]*xmm        + wcs->y_coeff[6]*2.0*ymm +
distort:dsspos.c:         wcs->y_coeff[7]*3.0*y2     + wcs->y_coeff[8]*2.0*xy +
distort:dsspos.c:         wcs->y_coeff[9]*x2         + wcs->y_coeff[11]*(x2+3.0*y2) +
distort:dsspos.c:         wcs->y_coeff[12]*(5.0*y4 + 6.0*x2*y2 + x4);
distort:dsspos.c:         wcs->y_coeff[16]*mag       + wcs->y_coeff[17]*mag*2.0*ymm +
distort:dsspos.c:         wcs->y_coeff[18]*mag*(x2+3.0*y2);
distort:dsspos.c:  if (wcs->x_pixel_size == 0.0 || wcs->y_pixel_size == 0.0)
distort:dsspos.c:  x = (wcs->ppo_coeff[2] - xmm*1000.0) / wcs->x_pixel_size;
distort:dsspos.c:  y = (wcs->ppo_coeff[5] + ymm*1000.0) / wcs->y_pixel_size;
distort:dsspos.c:  *xpix = x - wcs->x_pixel_offset + 1.0 - 0.5;
distort:dsspos.c:  *ypix = y - wcs->y_pixel_offset + 1.0 - 0.5;
distort:dsspos.c:  if (*xpix < 0.5 || *xpix > wcs->nxpix+0.5)
distort:dsspos.c:  if (*ypix < 0.5 || *ypix > wcs->nypix+0.5)
distort:fitswcs.c:    if (wcs->xref < 0)
distort:fitswcs.c:	wcs->xref = 360.0 + wcs->xref;
distort:fitswcs.c:    hputra (header,"RA",wcs->xref);
distort:fitswcs.c:    hputdec (header,"DEC",wcs->yref);
distort:fitswcs.c:    hputr8 (header, "EQUINOX", wcs->equinox);
distort:fitswcs.c:	hputr8 (header, "EPOCH", wcs->equinox);
distort:fitswcs.c:	hputr8 (header, "EPOCH", wcs->equinox);
distort:fitswcs.c:    if (wcs->radecsys[0] == 'B' || wcs->radecsys[0] == 'b')
distort:fitswcs.c:    else if (wcs->radecsys[0] == 'I' || wcs->radecsys[0] == 'i')
distort:fitswcs.c:    else if (wcs->radecsys[0] == 'J' || wcs->radecsys[0] == 'j')
distort:fitswcs.c:	hputs (header, "RADECSYS", wcs->radecsys);
distort:fitswcs.c:    hputnr8 (header, "CRVAL1", 9, wcs->xref);
distort:fitswcs.c:    hputnr8 (header, "CRVAL2", 9, wcs->yref);
distort:fitswcs.c:    hputnr8 (header, "CRPIX1", 4, wcs->xrefpix);
distort:fitswcs.c:    hputnr8 (header, "CRPIX2", 4, wcs->yrefpix);
distort:fitswcs.c:    if (wcs->rotmat) {
distort:fitswcs.c:	hputnr8 (header, "CD1_1", 12, wcs->cd[0]);
distort:fitswcs.c:	hputnr8 (header, "CD1_2", 12, wcs->cd[1]);
distort:fitswcs.c:	hputnr8 (header, "CD2_1", 12, wcs->cd[2]);
distort:fitswcs.c:	hputnr8 (header, "CD2_2", 12, wcs->cd[3]);
distort:fitswcs.c:	hputnr8 (header, "CDELT1", 12, wcs->xinc);
distort:fitswcs.c:	hputnr8 (header, "CDELT2", 12, wcs->yinc);
distort:fitswcs.c:	hputnr8 (header, "CROTA1", 6, wcs->rot);
distort:fitswcs.c:	hputnr8 (header, "CROTA2", 6, wcs->rot);
distort:fitswcs.c:	hputnr8 (header, "CD1_1", 12, wcs->cd[0]);
distort:fitswcs.c:	hputnr8 (header, "CD1_2", 12, wcs->cd[1]);
distort:fitswcs.c:	hputnr8 (header, "CD2_1", 12, wcs->cd[2]);
distort:fitswcs.c:	hputnr8 (header, "CD2_2", 12, wcs->cd[3]);
distort:fitswcs.c:    if (-wcs->xinc != wcs->yinc) {
distort:fitswcs.c:	hputnr8 (header, "SECPIX1", 4, -wcs->xinc*3600.0);
distort:fitswcs.c:	hputnr8 (header, "SECPIX2", 4, wcs->yinc*3600.0);
distort:fitswcs.c:	hputnr8 (header, "SECPIX", 6, wcs->yinc*3600.0);
distort:fitswcs.c:    if (wcs->ncoeff1 > 0) {
distort:fitswcs.c:	for (i = 0; i < wcs->ncoeff1; i++) {
distort:fitswcs.c:	    hputr8 (header, keyword, wcs->x_coeff[i]);
distort:fitswcs.c:    if (wcs->ncoeff2 > 0) {
distort:fitswcs.c:	for (i = 0; i < wcs->ncoeff2; i++) {
distort:fitswcs.c:	    hputr8 (header, keyword, wcs->y_coeff[i]);
distort:fortwcs.c:	strcpy (radecsys, wcs->radecsys);
distort:fortwcs.c:	wcs->degout = *mode;
distort:fortwcs.c:	wcs->linmode = *mode;
distort:gscread.c:    int	sysout = wcs->syswcs;	/* Image coordinate system */
distort:gscread.c:    double eqout = wcs->equinox; /* Image coordinate equinox */
distort:gscread.c:    double epout = wcs->epoch;	/* Image epoch */
distort:imgetwcs.c:    *hp = (int) wcs->nypix;
distort:imgetwcs.c:    *wp = (int) wcs->nxpix;
distort:imgetwcs.c:    if (wcs->sysout < 1 || wcs->sysout == 6 || wcs->sysout == 10)
distort:imgetwcs.c:	wcs->degout = 1;
distort:imgetwcs.c:	*sysout = wcs->syswcs;
distort:imgetwcs.c:	*eqout = wcs->equinox;
distort:imgetwcs.c:    eq1 = wcs->equinox;
distort:imgetwcs.c:    if (wcs->coorflip) {
distort:imgetwcs.c:	ra1 = wcs->crval[1];
distort:imgetwcs.c:	dec1 = wcs->crval[0];
distort:imgetwcs.c:	ra1 = wcs->crval[0];
distort:imgetwcs.c:	dec1 = wcs->crval[1];
distort:imgetwcs.c:    if (verbose && (eq1 != *eqout || wcs->syswcs != *sysout)) {
distort:imgetwcs.c:	if (wcs->degout) {
distort:imgetwcs.c:	wcscstr (cstr, wcs->syswcs, wcs->equinox, wcs->epoch);
distort:imgetwcs.c:		 wcs->xrefpix, wcs->yrefpix, rstr, dstr, cstr);
distort:imgetwcs.c:    dx = wcs->nxpix;
distort:imgetwcs.c:    dy = wcs->nypix;
distort:imgetwcs.c:    if (wcs->syswcs > 0 && wcs->syswcs != 6 && wcs->syswcs != 10) {
distort:imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra1,&dec1,wcs->epoch);
distort:imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra2,&dec2,wcs->epoch);
distort:imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra3,&dec3,wcs->epoch);
distort:imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra4,&dec4,wcs->epoch);
distort:imgetwcs.c:    if (wcs->syswcs > 0 && wcs->syswcs != 6 && wcs->syswcs != 10)
distort:imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,cra,cdec,wcs->epoch);
distort:imgetwcs.c:    if (wcs->xref == -999.0 && wcs->yref == -999.0) {
distort:imgetwcs.c:	wcs->xref = *cra;
distort:imgetwcs.c:	wcs->cel.ref[0] = *cra;
distort:imgetwcs.c:	wcs->crval[0] = *cra;
distort:imgetwcs.c:	wcs->yref = *cdec;
distort:imgetwcs.c:	wcs->cel.ref[1] = *cdec;
distort:imgetwcs.c:	wcs->crval[1] = *cdec;
distort:imgetwcs.c:	if (wcs->xrefpix == 0.0 && wcs->yrefpix == 0.0) {
distort:imgetwcs.c:	    wcs->xrefpix = 0.5 + (double) wcs->nxpix * 0.5;
distort:imgetwcs.c:	    wcs->yrefpix = 0.5 + (double) wcs->nypix * 0.5;
distort:imgetwcs.c:	wcs->xinc = *dra * 2.0 / (double) wcs->nxpix;
distort:imgetwcs.c:	wcs->yinc = *ddec * 2.0 / (double) wcs->nypix;
distort:imgetwcs.c:	wcs->plate_fit = 0; */
distort:imgetwcs.c:    else if (wcs->syswcs != *sysout && wcs->equinox != *eqout) {
distort:imgetwcs.c:	wcscon (wcs->syswcs, *sysout, wcs->equinox, *eqout, &ra1, &dec1, wcs->epoch);
distort:imgetwcs.c:	if (wcs->coorflip) {
distort:imgetwcs.c:	    wcs->yref = ra1;
distort:imgetwcs.c:	    wcs->xref = dec1;
distort:imgetwcs.c:	    wcs->xref = ra1;
distort:imgetwcs.c:	    wcs->yref = dec1;
distort:imgetwcs.c:	pix2wcs (wcs, wcs->xrefpix-0.5, wcs->yrefpix, &ra1, &dec1);
distort:imgetwcs.c:	pix2wcs (wcs, wcs->xrefpix+0.5, wcs->yrefpix, &ra2, &dec2);
distort:imgetwcs.c:    wcs->crval[0] = wcs->xref;
distort:imgetwcs.c:    wcs->crval[1] = wcs->yref;
distort:imgetwcs.c:    if (wcs->coorflip) {
distort:imgetwcs.c:	wcs->cel.ref[0] = wcs->crval[1];
distort:imgetwcs.c:	wcs->cel.ref[1] = wcs->crval[0];
distort:imgetwcs.c:	wcs->cel.ref[0] = wcs->crval[0];
distort:imgetwcs.c:	wcs->cel.ref[1] = wcs->crval[1];
distort:imgetwcs.c:    if (wcs->syswcs > 0 && wcs->syswcs != 6 && wcs->syswcs != 10) {
distort:imgetwcs.c:	wcs->cel.flag = 0;
distort:imgetwcs.c:	wcs->wcsl.flag = 0;
distort:imgetwcs.c:	wcs->lin.flag = LINSET;
distort:imgetwcs.c:	wcs->wcsl.flag = WCSSET;
distort:imgetwcs.c:    wcs->equinox = *eqout;
distort:imgetwcs.c:    wcs->syswcs = *sysout;
distort:imgetwcs.c:    wcs->sysout = *sysout;
distort:imgetwcs.c:    wcs->eqout = *eqout;
distort:imgetwcs.c:    wcs->sysin = *sysout;
distort:imgetwcs.c:    wcs->eqin = *eqout;
distort:imgetwcs.c:    wcscstr (cstr,*sysout,*eqout,wcs->epoch);
distort:imgetwcs.c:    strcpy (wcs->radecsys, cstr);
distort:imgetwcs.c:    strcpy (wcs->radecout, cstr);
distort:imgetwcs.c:    strcpy (wcs->radecin, cstr);
distort:imgetwcs.c:    wcsininit (wcs, wcs->radecsys);
distort:imgetwcs.c:    wcsoutinit (wcs, wcs->radecsys);
distort:imgetwcs.c:    naxes = wcs->naxis;
distort:imgetwcs.c:	naxes = wcs->naxes;
distort:imgetwcs.c:	wcs->naxis = naxes;
distort:imgetwcs.c:	hputnr8 (header, "CDELT1", 9, wcs->xinc);
distort:imgetwcs.c:	    hputnr8 (header, "CDELT2", 9, wcs->yinc);
distort:imgetwcs.c:	    hputnr8 (header, "CROTA2", 9, wcs->rot);
distort:imgetwcs.c:	hputnr8 (header, "CD1_1", 9, wcs->cd[0]);
distort:imgetwcs.c:	    hputnr8 (header, "CD1_2", 9, wcs->cd[1]);
distort:imgetwcs.c:	    hputnr8 (header, "CD2_1", 9, wcs->cd[2]);
distort:imgetwcs.c:	    hputnr8 (header, "CD2_2", 9, wcs->cd[3]);
distort:imgetwcs.c:	if (wcs->degout) {
distort:imgetwcs.c:	wcscstr (cstr,*sysout,*eqout,wcs->epoch);
distort:imgetwcs.c:		wcs->xrefpix, wcs->yrefpix, rstr, dstr, cstr);
distort:imgetwcs.c:	if (wcs->degout) {
distort:imgetwcs.c:	wcscstr (cstr, *sysout, *eqout, wcs->epoch);
distort:imgetwcs.c:	if (wcs->degout) {
distort:imgetwcs.c: * Oct  6 2003	Change wcs->naxes to wcs->naxis to match WCSLIB 3.2
distort:imgetwcs.c: * Dec  3 2003	Add wcs->naxes back as an alternative
distort:imsetwcs.c:    refep = wcs->epoch;
distort:imsetwcs.c:	wcs->prjcode = WCS_TAN;
distort:imsetwcs.c:	if (wcs->ncoeff1 > 0)
distort:imsetwcs.c:		    wcs->ncoeff1, wcs->ncoeff2);
distort:imsetwcs.c:		    3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
distort:imsetwcs.c:	ra2str (rstr, 32, wcs->xref, 3);
distort:imsetwcs.c:	dec2str (dstr, 32, wcs->yref, 2);
distort:imsetwcs.c:		rstr,dstr, refcoor, wcs->xrefpix, wcs->yrefpix);
distort:imsetwcs.c:	ra = wcs->xref;
distort:imsetwcs.c:	dec = wcs->yref;
distort:imsetwcs.c:		    rstr,dstr, wcs->xrefpix, wcs->yrefpix);
distort:imsetwcs.c:		    rstr,dstr, wcs->xrefpix, wcs->yrefpix);
distort:imsetwcs.c:/*	setdcenter (wcs->xref, wcs->yref);
distort:imsetwcs.c:	setsys (wcs->syswcs);
distort:imsetwcs.c:	setrefpix (wcs->xrefpix, wcs->yrefpix);
distort:imsetwcs.c:	    setcd (wcs->cd);
distort:imsetwcs.c:	    setsecpix (-3600.0 * wcs->xinc);
distort:imsetwcs.c:	    setsecpix2 (3600.0 * wcs->yinc);
distort:imsetwcs.c:	    setrot (wcs->rot);
distort:imsetwcs.c:/*	setdcenter (wcs->xref, wcs->yref);
distort:imsetwcs.c:	setsys (wcs->syswcs);
distort:imsetwcs.c:	setrefpix (wcs->xrefpix, wcs->yrefpix);
distort:imsetwcs.c:	    setcd (wcs->cd);
distort:imsetwcs.c:	    setsecpix (-3600.0 * wcs->xinc);
distort:imsetwcs.c:	    setsecpix2 (3600.0 * wcs->yinc);
distort:imsetwcs.c:	    setrot (wcs->rot);
distort:imsetwcs.c:	x = 0.5 * wcs->nxpix;
distort:imsetwcs.c:	y = 0.5 * wcs->nypix;
distort:imsetwcs.c:	setsys (wcs->syswcs);
distort:imsetwcs.c:	setsecpix (-3600.0 * wcs->xinc);
distort:imsetwcs.c:	setsecpix2 (3600.0 * wcs->yinc);
distort:imsetwcs.c:	setrot (wcs->rot);
distort:imsetwcs.c: * Jun 11 2001	Set refep from wcs->epoch after WCS is set
distort:matchstar1.c:    wcs->xref = wcs->xref + (bestdx * wcs->xinc);
distort:matchstar1.c:    if (wcs->xref < 0.0) wcs->xref = 360.0 + wcs->xref;
distort:matchstar1.c:    wcs->yref = wcs->yref + (bestdy * wcs->yinc);
distort:matchstar1.c:    xref_p = wcs->xref;
distort:matchstar1.c:    yref_p = wcs->yref;
distort:matchstar1.c:    xrefpix = wcs->xrefpix;
distort:matchstar1.c:    yrefpix = wcs->yrefpix;
distort:matchstar1.c:    xref0 = wcs->xref;
distort:matchstar1.c:    yref0 = wcs->yref;
distort:matchstar1.c:    xinc0 = wcs->xinc;
distort:matchstar1.c:    yinc0 = wcs->yinc;
distort:matchstar1.c:    rot0 = wcs->rot;
distort:matchstar1.c:    xrefpix0 = wcs->xrefpix;
distort:matchstar1.c:    yrefpix0 = wcs->yrefpix;
distort:matchstar1.c:    cd0[0] = wcs->cd[0];
distort:matchstar1.c:    cd0[1] = wcs->cd[1];
distort:matchstar1.c:    cd0[2] = wcs->cd[2];
distort:matchstar1.c:    cd0[3] = wcs->cd[3];
distort:matchstar1.c:	ra2str (rastr, 16, wcs->xref, 3);
distort:matchstar1.c:	dec2str (decstr, 16, wcs->yref, 2);
distort:matchstar1.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
distort:matchstar1.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
distort:matchstar1.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:matchstar1.c:	xref_p = wcs->xref;
distort:matchstar1.c:	yref_p = wcs->yref;
distort:matchstar1.c:	xrefpix = wcs->xrefpix;
distort:matchstar1.c:	yrefpix = wcs->yrefpix;
distort:matchstar1.c:	    ra2str (rastr, 16, wcs->xref, 3);
distort:matchstar1.c:	    dec2str (decstr, 16, wcs->yref, 2);
distort:matchstar1.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
distort:matchstar1.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:matchstar1.c:/*    double equinox = wcs->equinox; */
distort:matchstar1.c:    xref_p = wcs->xref;
distort:matchstar1.c:    yref_p = wcs->yref;
distort:matchstar1.c:    xrefpix = wcs->xrefpix;
distort:matchstar1.c:    yrefpix = wcs->yrefpix;
distort:matchstar1.c:    xref0 = wcs->xref;
distort:matchstar1.c:    yref0 = wcs->yref;
distort:matchstar1.c:    xinc0 = wcs->xinc;
distort:matchstar1.c:    yinc0 = wcs->yinc;
distort:matchstar1.c:    rot0 = wcs->rot;
distort:matchstar1.c:    xrefpix0 = wcs->xrefpix;
distort:matchstar1.c:    yrefpix0 = wcs->yrefpix;
distort:matchstar1.c:    cd0[0] = wcs->cd[0];
distort:matchstar1.c:    cd0[1] = wcs->cd[1];
distort:matchstar1.c:    cd0[2] = wcs->cd[2];
distort:matchstar1.c:    cd0[3] = wcs->cd[3];
distort:matchstar1.c:	ra2str (rastr, 16, wcs->xref, 3);
distort:matchstar1.c:	dec2str (decstr, 16, wcs->yref, 2);
distort:matchstar1.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
distort:matchstar1.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
distort:matchstar1.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:matchstar1.c:	xref_p = wcs->xref;
distort:matchstar1.c:	yref_p = wcs->yref;
distort:matchstar1.c:	xrefpix = wcs->xrefpix;
distort:matchstar1.c:	yrefpix = wcs->yrefpix;
distort:matchstar1.c:	    ra2str (rastr, 16, wcs->xref, 3);
distort:matchstar1.c:	    dec2str (decstr, 16, wcs->yref, 2);
distort:matchstar1.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
distort:matchstar1.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:matchstar.c:	nbx = wcs->nxpix / tol2;
distort:matchstar.c:	nby = wcs->nypix / tol2;
distort:matchstar.c:    wcs->xref = wcs->xref + (bestdx * wcs->xinc);
distort:matchstar.c:    if (wcs->xref < 0.0) wcs->xref = 360.0 + wcs->xref;
distort:matchstar.c:    wcs->yref = wcs->yref + (bestdy * wcs->yinc);
distort:matchstar.c:    xref_p = wcs->xref;
distort:matchstar.c:    yref_p = wcs->yref;
distort:matchstar.c:    xrefpix = wcs->xrefpix;
distort:matchstar.c:    yrefpix = wcs->yrefpix;
distort:matchstar.c:    xref0 = wcs->xref;
distort:matchstar.c:    yref0 = wcs->yref;
distort:matchstar.c:    xinc0 = wcs->xinc;
distort:matchstar.c:    yinc0 = wcs->yinc;
distort:matchstar.c:    rot0 = wcs->rot;
distort:matchstar.c:    xrefpix0 = wcs->xrefpix;
distort:matchstar.c:    yrefpix0 = wcs->yrefpix;
distort:matchstar.c:    cd0[0] = wcs->cd[0];
distort:matchstar.c:    cd0[1] = wcs->cd[1];
distort:matchstar.c:    cd0[2] = wcs->cd[2];
distort:matchstar.c:    cd0[3] = wcs->cd[3];
distort:matchstar.c:	ra2str (rastr, 31, wcs->xref, 3);
distort:matchstar.c:	dec2str (decstr, 31, wcs->yref, 2);
distort:matchstar.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
distort:matchstar.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
distort:matchstar.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:matchstar.c:	xref_p = wcs->xref;
distort:matchstar.c:	yref_p = wcs->yref;
distort:matchstar.c:	xrefpix = wcs->xrefpix;
distort:matchstar.c:	yrefpix = wcs->yrefpix;
distort:matchstar.c:	    ra2str (rastr, 31, wcs->xref, 3);
distort:matchstar.c:	    dec2str (decstr, 31, wcs->yref, 2);
distort:matchstar.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
distort:matchstar.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:matchstar.c:/*    double equinox = wcs->equinox; */
distort:matchstar.c:    xref_p = wcs->xref;
distort:matchstar.c:    yref_p = wcs->yref;
distort:matchstar.c:    xrefpix = wcs->xrefpix;
distort:matchstar.c:    yrefpix = wcs->yrefpix;
distort:matchstar.c:    xref0 = wcs->xref;
distort:matchstar.c:    yref0 = wcs->yref;
distort:matchstar.c:    xinc0 = wcs->xinc;
distort:matchstar.c:    yinc0 = wcs->yinc;
distort:matchstar.c:    rot0 = wcs->rot;
distort:matchstar.c:    xrefpix0 = wcs->xrefpix;
distort:matchstar.c:    yrefpix0 = wcs->yrefpix;
distort:matchstar.c:    cd0[0] = wcs->cd[0];
distort:matchstar.c:    cd0[1] = wcs->cd[1];
distort:matchstar.c:    cd0[2] = wcs->cd[2];
distort:matchstar.c:    cd0[3] = wcs->cd[3];
distort:matchstar.c:	ra2str (rastr, 31, wcs->xref, 3);
distort:matchstar.c:	dec2str (decstr, 31, wcs->yref, 2);
distort:matchstar.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
distort:matchstar.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
distort:matchstar.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:matchstar.c:	xref_p = wcs->xref;
distort:matchstar.c:	yref_p = wcs->yref;
distort:matchstar.c:	xrefpix = wcs->xrefpix;
distort:matchstar.c:	yrefpix = wcs->yrefpix;
distort:matchstar.c:	    ra2str (rastr, 31, wcs->xref, 3);
distort:matchstar.c:	    dec2str (decstr, 31, wcs->yref, 2);
distort:matchstar.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
distort:matchstar.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
distort:NEWS:wcsinit.c:  Set wcs->naxes to actual number of image WCS axes, usually 2
distort:NEWS:In wcs.c, keep wcs->rot between 0 and 360 degrees (360.0 -> 0.0)
distort:NEWS:Add wcs->naxes back into wcs structure for backward compatibility; it
distort:NEWS:should always be equal to wcs->naxis.
distort:NEWS:Change wcs->naxes to wcs->naxis to prepare for WCSLIB 3.*
distort:platepos.c:    int ncoeff1 = wcs->ncoeff1;
distort:platepos.c:    int ncoeff2 = wcs->ncoeff2;
distort:platepos.c:    x = xpix - wcs->crpix[0];
distort:platepos.c:    y = ypix - wcs->crpix[1];
distort:platepos.c:    xi =  wcs->x_coeff[ 0]		+ wcs->x_coeff[ 1]*x +
distort:platepos.c:	  wcs->x_coeff[ 2]*y	+ wcs->x_coeff[ 3]*x2 +
distort:platepos.c:	  wcs->x_coeff[ 4]*y2	+ wcs->x_coeff[ 5]*x*y;
distort:platepos.c:	  xi = xi + wcs->x_coeff[ 6]*x3	+ wcs->x_coeff[ 7]*y3;
distort:platepos.c:	xi = xi + wcs->x_coeff[ 8]*x2*y	+ wcs->x_coeff[ 9]*x*y2 +
distort:platepos.c:		  wcs->x_coeff[10]*(r2)	+ wcs->x_coeff[11]*x*r2 +
distort:platepos.c:		  wcs->x_coeff[12]*y*r2;
distort:platepos.c:    eta = wcs->y_coeff[ 0]		+ wcs->y_coeff[ 1]*x +
distort:platepos.c:	  wcs->y_coeff[ 2]*y	+ wcs->y_coeff[ 3]*x2 +
distort:platepos.c:	  wcs->y_coeff[ 4]*y2	+ wcs->y_coeff[ 5]*x*y;
distort:platepos.c:	eta = eta + wcs->y_coeff[ 6]*x3	+ wcs->y_coeff[ 7]*y3;
distort:platepos.c:	eta = eta + wcs->y_coeff[ 8]*x2*y + wcs->y_coeff[ 9]*y2*x +
distort:platepos.c:		    wcs->y_coeff[10]*r2   + wcs->y_coeff[11]*x*r2 +
distort:platepos.c:		    wcs->y_coeff[12]*y*r2;
distort:platepos.c:    ra0 = degrad (wcs->crval[0]);
distort:platepos.c:    dec0 = degrad (wcs->crval[1]);
distort:platepos.c:    int	ncoeff1 = wcs->ncoeff1;
distort:platepos.c:    int	ncoeff2 = wcs->ncoeff2;
distort:platepos.c:    ra0 = degrad (wcs->crval[0]);
distort:platepos.c:    dec0 = degrad (wcs->crval[1]);
distort:platepos.c:    x = xi * wcs->dc[0] + eta * wcs->dc[1];
distort:platepos.c:    y = xi * wcs->dc[2] + eta * wcs->dc[3];
distort:platepos.c:    /* if (wcs->x_coeff[1] == 0.0)
distort:platepos.c:	x = xi - wcs->x_coeff[0];
distort:platepos.c:	x = (xi - wcs->x_coeff[0]) / wcs->x_coeff[1];
distort:platepos.c:    if (wcs->y_coeff[2] == 0.0)
distort:platepos.c:	y = eta - wcs->y_coeff[0];
distort:platepos.c:	y = (eta - wcs->y_coeff[0]) / wcs->y_coeff[2]; */
distort:platepos.c:	f = wcs->x_coeff[0]	+ wcs->x_coeff[1]*x +
distort:platepos.c:	    wcs->x_coeff[2]*y	+ wcs->x_coeff[3]*x2 +
distort:platepos.c:	    wcs->x_coeff[4]*y2	+ wcs->x_coeff[5]*xy;
distort:platepos.c:	fx = wcs->x_coeff[1]	+ wcs->x_coeff[3]*2.0*x +
distort:platepos.c:	     wcs->x_coeff[5]*y;
distort:platepos.c:	fy = wcs->x_coeff[2]	+ wcs->x_coeff[4]*2.0*y +
distort:platepos.c:	     wcs->x_coeff[5]*x;
distort:platepos.c:	    f = f + wcs->x_coeff[6]*x3	+ wcs->x_coeff[7]*y3;
distort:platepos.c:	    fx = fx + wcs->x_coeff[6]*3.0*x2;
distort:platepos.c:	    fy = fy + wcs->x_coeff[7]*3.0*y2;
distort:platepos.c:		wcs->x_coeff[8]*x2y	+ wcs->x_coeff[9]*y2x +
distort:platepos.c:		wcs->x_coeff[10]*r2 + wcs->x_coeff[11]*x*r2 +
distort:platepos.c:		wcs->x_coeff[12]*y*r2;
distort:platepos.c:	    fx = fx +	wcs->x_coeff[8]*2.0*xy + 
distort:platepos.c:			wcs->x_coeff[9]*y2 +
distort:platepos.c:	 		wcs->x_coeff[10]*2.0*x +
distort:platepos.c:			wcs->x_coeff[11]*(3.0*x2+y2) +
distort:platepos.c:			wcs->x_coeff[12]*2.0*xy;
distort:platepos.c:	    fy = fy +	wcs->x_coeff[8]*x2 +
distort:platepos.c:			wcs->x_coeff[9]*2.0*xy +
distort:platepos.c:			wcs->x_coeff[10]*2.0*y +
distort:platepos.c:			wcs->x_coeff[11]*2.0*xy +
distort:platepos.c:			wcs->x_coeff[12]*(3.0*y2+x2);
distort:platepos.c:	g = wcs->y_coeff[0]	+ wcs->y_coeff[1]*x +
distort:platepos.c:	    wcs->y_coeff[2]*y	+ wcs->y_coeff[3]*x2 +
distort:platepos.c:	    wcs->y_coeff[4]*y2	+ wcs->y_coeff[5]*xy;
distort:platepos.c:	gx = wcs->y_coeff[1]	+ wcs->y_coeff[3]*2.0*x +
distort:platepos.c:	     wcs->y_coeff[5]*y;
distort:platepos.c:	gy = wcs->y_coeff[2]	+ wcs->y_coeff[4]*2.0*y +
distort:platepos.c:	     wcs->y_coeff[5]*x;
distort:platepos.c:	    g = g + wcs->y_coeff[6]*x3	+ wcs->y_coeff[7]*y3;
distort:platepos.c:	    gx = gx + wcs->y_coeff[6]*3.0*x2;
distort:platepos.c:	    gy = gy + wcs->y_coeff[7]*3.0*y2;
distort:platepos.c:		wcs->y_coeff[8]*x2y	+ wcs->y_coeff[9]*y2x +
distort:platepos.c:		wcs->y_coeff[10]*r2	+ wcs->y_coeff[11]*x*r2 +
distort:platepos.c:		wcs->y_coeff[12]*y*r2;
distort:platepos.c:	    gx = gx +	wcs->y_coeff[8]*2.0*xy + 
distort:platepos.c:			wcs->y_coeff[9]*y2 +
distort:platepos.c:	 		wcs->y_coeff[10]*2.0*x +
distort:platepos.c:			wcs->y_coeff[11]*(3.0*x2+y2) +
distort:platepos.c:			wcs->y_coeff[12]*2.0*xy;
distort:platepos.c:	    gy = gy +	wcs->y_coeff[8]*x2 +
distort:platepos.c:			wcs->y_coeff[9]*2.0*xy +
distort:platepos.c:			wcs->y_coeff[10]*2.0*y +
distort:platepos.c:			wcs->y_coeff[11]*2.0*xy +
distort:platepos.c:			wcs->y_coeff[12]*(3.0*y2+x2);
distort:platepos.c:    *xpix = x + wcs->crpix[0];
distort:platepos.c:    *ypix = y + wcs->crpix[1];
distort:platepos.c:    if (*xpix < 0.5 || *xpix > wcs->nxpix+0.5)
distort:platepos.c:    if (*ypix < 0.5 || *ypix > wcs->nypix+0.5)
distort:platepos.c:    wcs->ncoeff1 = ncoeff1;
distort:platepos.c:    wcs->ncoeff2 = ncoeff2;
distort:platepos.c:    wcs->prjcode = WCS_PLT;
distort:platepos.c:	    wcs->x_coeff[i] = coeff[i];
distort:platepos.c:	    wcs->x_coeff[i] = 0.0;
distort:platepos.c:	    wcs->y_coeff[i] = coeff[ncoeff1+i];
distort:platepos.c:	    wcs->y_coeff[i] = 0.0;
distort:platepos.c:    *ncoeff1 = wcs->ncoeff1;
distort:platepos.c:    *ncoeff2 = wcs->ncoeff2;
distort:platepos.c:	coeff[i] = wcs->x_coeff[i];
distort:platepos.c:	coeff[*ncoeff1+i] = wcs->y_coeff[i];
distort:platepos.c:    for (i = 0; i < wcs->ncoeff1; i++) {
distort:platepos.c:	hputnr8 (header, keyword, -15, wcs->x_coeff[i]);
distort:platepos.c:    for (i = 0; i < wcs->ncoeff2; i++) {
distort:platepos.c:	hputnr8 (header, keyword, -15, wcs->y_coeff[i]);
distort:tabread.c:    sysout = wcs->syswcs;
distort:tabread.c:    eqout = wcs->equinox;
distort:tabread.c:    epout = wcs->epoch;
distort:temp:    wcs->wcschar = mchar;
distort:temp:	wcs->wcsname = (char *) calloc (strlen (wcsname)+2, 1);
distort:temp:	strcpy (wcs->wcsname, wcsname);
distort:temp:    wcs->cel.flag = 0;
distort:temp:    wcs->lin.flag = 0;
distort:temp:    wcs->wcsl.flag = 0;
distort:temp:    wcs->wcsl.cubeface = -1;
distort:temp:    wcs->ncoeff1 = 0;
distort:temp:    wcs->ncoeff2 = 0;
distort:temp:    wcs->rotmat = 0;
distort:temp:    wcs->rot = 0.0;
distort:temp:    wcs->naxis = naxes;
distort:temp:    wcs->naxes = naxes;
distort:temp:    wcs->lin.naxis = naxes;
distort:temp:    wcs->nxpix = 0;
distort:temp:    hgetr8 (hstring, "NAXIS1", &wcs->nxpix);
distort:temp:    if (wcs->nxpix < 1)
distort:temp:	hgetr8 (hstring, "IMAGEW", &wcs->nxpix);
distort:temp:    if (wcs->nxpix < 1) {
distort:temp:    wcs->nypix = 0;
distort:temp:    hgetr8 (hstring, "NAXIS2", &wcs->nypix);
distort:temp:    if (wcs->nypix < 1)
distort:temp:	hgetr8 (hstring, "IMAGEH", &wcs->nypix);
distort:temp:    if (naxes > 1 && wcs->nypix < 1) {
distort:temp:	    if (i == 0 && wcs->nxpix > 1) {
distort:temp:			 keyword, wcs->nxpix); */
distort:temp:		j = wcs->nxpix;
distort:temp:	    else if (i == 1 && wcs->nypix > 1) {
distort:temp:			 keyword, wcs->nypix); */
distort:temp:		j = wcs->nypix;
distort:temp:    wcs->naxes = nax;
distort:temp:    wcs->naxis = nax;
distort:temp:    hgets (hstring, "INSTRUME", 16, wcs->instrument);
distort:temp:    hgeti4 (hstring, "DETECTOR", &wcs->detector);
distort:temp:    wcs->wcsproj = getdefwcs();
distort:temp:    wcs->logwcs = 0;
distort:temp:    hgeti4 (hstring, "DC-FLAG", &wcs->logwcs);
distort:temp:    for (i = 0; i < 81; i++) wcs->pc[i] = 0.0;
distort:temp:    for (i = 0; i < naxes; i++) wcs->pc[(i*naxes)+i] = 1.0;
distort:temp:    for (i = 0; i < 9; i++) wcs->cdelt[i] = 0.0;
distort:temp:    for (i = 0; i < naxes; i++) wcs->cdelt[i] = 1.0;
distort:temp:	if ((wcs->wcs = wcsinitn (hstring, wcsname)) == NULL) {
distort:temp:	depwcs = wcs->wcs;
distort:temp:	depwcs->wcsdep = wcs;
distort:temp:	wcs->wcs = NULL;
distort:temp:    wcs->radvel = 0.0;
distort:temp:    wcs->zvel = 0.0;
distort:temp:    if (hgetr8c (hstring, "VSOURCE", &mchar, &wcs->radvel))
distort:temp:	wcs->zvel = wcs->radvel / cvel;
distort:temp:    else if (hgetr8c (hstring, "ZSOURCE", &mchar, &wcs->zvel))
distort:temp:	wcs->radvel = wcs->zvel * cvel;
distort:temp:    else if (hgetr8 (hstring, "VELOCITY", &wcs->radvel))
distort:temp:	wcs->zvel = wcs->radvel / cvel;
distort:temp:	wcs->prj.p[i] = 0.0;
distort:temp:	strcpy (wcs->ctype[0], ctype1);
distort:temp:	strcpy (wcs->ctype[1], ctype2);
distort:temp:	strcpy (wcs->ctype[2], "");
distort:temp:	hgetsc (hstring, "CTYPE3", &mchar, 9, wcs->ctype[2]);
distort:temp:	strcpy (wcs->ctype[3], "");
distort:temp:	hgetsc (hstring, "CTYPE4", &mchar, 9, wcs->ctype[3]);
distort:temp:	if (wcs->prjcode == WCS_LIN) {
distort:temp:	    if (!hgetsc (hstring, "CUNIT1", &mchar, 16, wcs->units[0])) {
distort:temp:		if (!mgetstr (hstring, "WAT1", "units", 16, wcs->units[0])) {
distort:temp:		    wcs->units[0][0] = 0;
distort:temp:	    if (!strcmp (wcs->units[0], "pixel"))
distort:temp:		wcs->prjcode = WCS_PIX;
distort:temp:		if (!hgetsc (hstring, "CUNIT2", &mchar, 16, wcs->units[1])) {
distort:temp:		    if (!mgetstr (hstring, "WAT2", "units", 16, wcs->units[1])) {
distort:temp:			wcs->units[1][0] = 0;
distort:temp:		if (!strcmp (wcs->units[0], "pixel"))
distort:temp:		    wcs->prjcode = WCS_PIX;
distort:temp:	wcs->crpix[0] = 1.0;
distort:temp:	hgetr8c (hstring, "CRPIX1", &mchar, &wcs->crpix[0]);
distort:temp:	wcs->crpix[1] = 1.0;
distort:temp:	hgetr8c (hstring, "CRPIX2", &mchar, &wcs->crpix[1]);
distort:temp:	wcs->xrefpix = wcs->crpix[0];
distort:temp:	wcs->yrefpix = wcs->crpix[1];
distort:temp:	wcs->crval[0] = 0.0;
distort:temp:	hgetr8c (hstring, "CRVAL1", &mchar, &wcs->crval[0]);
distort:temp:	wcs->crval[1] = 0.0;
distort:temp:	hgetr8c (hstring, "CRVAL2", &mchar, &wcs->crval[1]);
distort:temp:	if (wcs->syswcs == WCS_NPOLE)
distort:temp:	    wcs->crval[1] = 90.0 - wcs->crval[1];
distort:temp:	if (wcs->syswcs == WCS_SPA)
distort:temp:	    wcs->crval[1] = wcs->crval[1] - 90.0;
distort:temp:	wcs->xref = wcs->crval[0];
distort:temp:	wcs->yref = wcs->crval[1];
distort:temp:	if (wcs->coorflip) {
distort:temp:	    wcs->cel.ref[0] = wcs->crval[1];
distort:temp:	    wcs->cel.ref[1] = wcs->crval[0];
distort:temp:	    wcs->cel.ref[0] = wcs->crval[0];
distort:temp:	    wcs->cel.ref[1] = wcs->crval[1];
distort:temp:	wcs->longpole = 999.0;
distort:temp:	hgetr8c (hstring, "LONPOLE", &mchar, &wcs->longpole);
distort:temp:	wcs->cel.ref[2] = wcs->longpole;
distort:temp:	wcs->latpole = 999.0;
distort:temp:	hgetr8c (hstring, "LATPOLE", &mchar, &wcs->latpole);
distort:temp:	wcs->cel.ref[3] = wcs->latpole;
distort:temp:	wcs->lin.crpix = wcs->crpix;
distort:temp:	wcs->lin.cdelt = wcs->cdelt;
distort:temp:	wcs->lin.pc = wcs->pc;
distort:temp:	wcs->prj.r0 = 0.0;
distort:temp:	hgetr8c (hstring, "PROJR0", &mchar, &wcs->prj.r0);
distort:temp:	    hgetr8c (hstring, keyword, &mchar, &wcs->prj.p[i]);
distort:temp:	if (wcs->prjcode == WCS_AZP || wcs->prjcode == WCS_SIN ||
distort:temp:	    wcs->prjcode == WCS_COP || wcs->prjcode == WCS_COE ||
distort:temp:	    wcs->prjcode == WCS_COD || wcs->prjcode == WCS_COO) {
distort:temp:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:temp:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
distort:temp:	else if (wcs->prjcode == WCS_SZP) {
distort:temp:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:temp:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
distort:temp:	    if (wcs->prj.p[3] == 0.0)
distort:temp:		wcs->prj.p[3] = 90.0;
distort:temp:	    hgetr8c (hstring, pvkey3, &mchar, &wcs->prj.p[3]);
distort:temp:	else if (wcs->prjcode == WCS_CEA) {
distort:temp:	    if (wcs->prj.p[1] == 0.0)
distort:temp:		wcs->prj.p[1] = 1.0;
distort:temp:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:temp:	else if (wcs->prjcode == WCS_CYP) {
distort:temp:	    if (wcs->prj.p[1] == 0.0)
distort:temp:		wcs->prj.p[1] = 1.0;
distort:temp:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:temp:	    if (wcs->prj.p[2] == 0.0)
distort:temp:		wcs->prj.p[2] = 1.0;
distort:temp:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
distort:temp:	else if (wcs->prjcode == WCS_AIR) {
distort:temp:	    if (wcs->prj.p[1] == 0.0)
distort:temp:		wcs->prj.p[1] = 90.0;
distort:temp:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:temp:	else if (wcs->prjcode == WCS_BON) {
distort:temp:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:temp:	else if (wcs->prjcode == WCS_ZPN) {
distort:temp:		hgetr8c (hstring, keyword, &mchar, &wcs->prj.p[i]);
distort:temp:	if (wcs->prjcode == WCS_TNX) {
distort:temp:		wcs->ctype[0][6] = 'A';
distort:temp:		wcs->ctype[0][7] = 'N';
distort:temp:		wcs->ctype[1][6] = 'A';
distort:temp:		wcs->ctype[1][7] = 'N';
distort:temp:		wcs->prjcode = WCS_TAN;
distort:temp:	if (wcs->prjcode == WCS_ZPX) {
distort:temp:		wcs->ctype[0][7] = 'N';
distort:temp:		wcs->ctype[1][7] = 'N';
distort:temp:		wcs->prjcode = WCS_ZPN;
distort:temp:	if (wcs->prjcode == WCS_TPV) {
distort:temp:	    wcs->ctype[0][6] = 'A';
distort:temp:	    wcs->ctype[0][7] = 'N';
distort:temp:	    wcs->ctype[1][6] = 'A';
distort:temp:	    wcs->ctype[1][7] = 'N';
distort:temp:	    wcs->prjcode = WCS_TAN;
distort:temp:	if (wcs->wcsproj > 0)
distort:temp:	wcs->ncoeff1 = 0;
distort:temp:	wcs->ncoeff2 = 0;
distort:temp:	if (wcs->wcsproj != WCS_OLD &&
distort:temp:	    wcs->prjcode = WCS_PLT;
distort:temp:	    (void)strcpy (wcs->ptype, "PLATE");
distort:temp:		wcs->x_coeff[i] = 0.0;
distort:temp:		if (hgetr8 (hcoeff, keyword, &wcs->x_coeff[i]))
distort:temp:		    wcs->ncoeff1 = i + 1;
distort:temp:		wcs->y_coeff[i] = 0.0;
distort:temp:		if (hgetr8 (hcoeff, keyword, &wcs->y_coeff[i]))
distort:temp:		    wcs->ncoeff2 = i + 1;
distort:temp:	    platepos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
distort:temp:	    platepos (wcs->crpix[0], wcs->crpix[1]+1.0, wcs, &ra1, &dec1);
distort:temp:	    wcs->yinc = dec1 - dec0;
distort:temp:	    wcs->xinc = -wcs->yinc;
distort:temp:	    wcs->wcson = 1;
distort:temp:	    rot = degrad (wcs->rot);
distort:temp:	    platepos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
distort:temp:	    platepos (wcs->crpix[0]+cos(rot),
distort:temp:		      wcs->crpix[1]+sin(rot), wcs, &ra1, &dec1);
distort:temp:	    wcs->cdelt[0] = -wcsdist (ra0, dec0, ra1, dec1);
distort:temp:	    wcs->xinc = wcs->cdelt[0];
distort:temp:	    platepos (wcs->crpix[0]+sin(rot),
distort:temp:		      wcs->crpix[1]+cos(rot), wcs, &ra1, &dec1);
distort:temp:	    wcs->cdelt[1] = wcsdist (ra0, dec0, ra1, dec1);
distort:temp:	    wcs->yinc = wcs->cdelt[1];
distort:temp:	    wcs->cd[0] = cd[0];
distort:temp:	    wcs->cd[1] = cd[1];
distort:temp:	    wcs->cd[2] = cd[2];
distort:temp:	    wcs->cd[3] = cd[3];
distort:temp:	    (void) matinv (2, wcs->cd, wcs->dc);
distort:temp:	    wcs->rotmat = 1;
distort:temp:	    if (cdelt1 == 0.0 || (wcs->nypix > 1 && cdelt2 == 0.0)) {
distort:temp:	    if (cdelt2 == 0.0 && wcs->nypix > 1)
distort:temp:	    wcs->cdelt[2] = 1.0;
distort:temp:	    wcs->cdelt[3] = 1.0;
distort:temp:		wcs->pc[i] = 0.0;
distort:temp:	    wcs->xinc = 1.0;
distort:temp:	    wcs->yinc = 1.0;
distort:temp:	    wcs->cdelt[0] = 1.0;
distort:temp:	    wcs->cdelt[1] = 1.0;
distort:temp:	    wcs->rot = 0.0;
distort:temp:	    wcs->rotmat = 0;
distort:temp:	if (wcs->prjcode == WCS_TAN && wcs->naxis == 2) { 
distort:temp:	    if (wcs->inv_x) {
distort:temp:		poly_end(wcs->inv_x);
distort:temp:		wcs->inv_x = NULL;
distort:temp:	    if (wcs->inv_y) {
distort:temp:		poly_end(wcs->inv_y);
distort:temp:		wcs->inv_y = NULL;
distort:temp:	    wcs->pvfail = 0;
distort:temp:		wcs->projppv[i] = 0.0;
distort:temp:		wcs->prj.ppv[i] = 0.0;
distort:temp:		    if (hgetr8c(hstring, keyword,&mchar, &wcs->projppv[j+k*MAXPV]) == 0) {
distort:temp:			wcs->projppv[j+k*MAXPV] = 0.0;
distort:temp:	    if (n > 0 && wcs->distcode != DISTORT_SIRTF) {
distort:temp:		    wcs->prj.ppv[k] = wcs->projppv[k+wcs->wcsl.lat*MAXPV];
distort:temp:		    wcs->prj.ppv[k+MAXPV] = wcs->projppv[k+wcs->wcsl.lng*MAXPV];
distort:temp:		    if (!n && (wcs->prj.ppv[k] || wcs->prj.ppv[k+MAXPV]))  {
distort:temp:		wcs->cel.flag = 0;
distort:temp:	if (!strncmp (wcs->ptype,"LINEAR",6) ||
distort:temp:	    !strncmp (wcs->ptype,"PIXEL",5)) {
distort:temp:	    wcs->degout = -1;
distort:temp:	    wcs->ndec = 5;
distort:temp:	    wcs->epoch = 1900.0 + (mjd - 15019.81352) / 365.242198781;
distort:temp:	else if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
distort:temp:	    if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
distort:temp:		if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
distort:temp:		    wcs->epoch = wcs->equinox;
distort:temp:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:temp:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:temp:	wcs->wcson = 1;
distort:temp:	wcs->prjcode = WCS_DSS;
distort:temp:	wcs->plate_ra = hrrad (ra_hours);
distort:temp:	wcs->plate_dec = degrad (dec_deg);
distort:temp:	hgetr8 (hstring,"EQUINOX",&wcs->equinox);
distort:temp:	    strcpy (wcs->radecsys,"FK4");
distort:temp:	    strcpy (wcs->radecsys,"FK5");
distort:temp:	wcs->epoch = wcs->equinox;
distort:temp:	hgetr8 (hstring,"EPOCH",&wcs->epoch);
distort:temp:	(void)sprintf (wcs->center,"%2.0f:%2.0f:%5.3f %c%2.0f:%2.0f:%5.3f %s",
distort:temp:		       rah,ram,ras,decsign,decd,decm,decs,wcs->radecsys);
distort:temp:	hgetr8 (hstring,"PLTSCALE",&wcs->plate_scale);
distort:temp:	hgetr8 (hstring,"XPIXELSZ",&wcs->x_pixel_size);
distort:temp:	hgetr8 (hstring,"YPIXELSZ",&wcs->y_pixel_size);
distort:temp:	hgetr8 (hstring,"CNPIX1",&wcs->x_pixel_offset);
distort:temp:	hgetr8 (hstring,"CNPIX2",&wcs->y_pixel_offset);
distort:temp:	    wcs->ppo_coeff[i] = 0.0;
distort:temp:	    hgetr8 (hcoeff,keyword,&wcs->ppo_coeff[i]);
distort:temp:	    wcs->x_coeff[i] = 0.0;
distort:temp:	    hgetr8 (hcoeff, keyword, &wcs->x_coeff[i]);
distort:temp:	    wcs->y_coeff[i] = 0.0;
distort:temp:	    hgetr8 (hcoeff, keyword, &wcs->y_coeff[i]);
distort:temp:	wcs->wcson = 1;
distort:temp:	(void)strcpy (wcs->c1type, "RA");
distort:temp:	(void)strcpy (wcs->c2type, "DEC");
distort:temp:	(void)strcpy (wcs->ptype, "DSS");
distort:temp:	wcs->degout = 0;
distort:temp:	wcs->ndec = 3;
distort:temp:	strcpy (wcs->ctype[0], "RA---DSS");
distort:temp:	strcpy (wcs->ctype[1], "DEC--DSS");
distort:temp:	wcs->crpix[0] = 0.5 * wcs->nxpix;
distort:temp:	wcs->crpix[1] = 0.5 * wcs->nypix;
distort:temp:	wcs->xrefpix = wcs->crpix[0];
distort:temp:	wcs->yrefpix = wcs->crpix[1];
distort:temp:	dsspos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
distort:temp:	wcs->crval[0] = ra0;
distort:temp:	wcs->crval[1] = dec0;
distort:temp:	wcs->xref = wcs->crval[0];
distort:temp:	wcs->yref = wcs->crval[1];
distort:temp:	dsspos (wcs->crpix[0], wcs->crpix[1]+1.0, wcs, &ra1, &dec1);
distort:temp:	wcs->yinc = dec1 - dec0;
distort:temp:	wcs->xinc = -wcs->yinc;
distort:temp:	wcs->wcson = 1;
distort:temp:	rot = degrad (wcs->rot);
distort:temp:	dsspos (wcs->crpix[0]+cos(rot),
distort:temp:		wcs->crpix[1]+sin(rot), wcs, &ra1, &dec1);
distort:temp:	wcs->cdelt[0] = -wcsdist (ra0, dec0, ra1, dec1);
distort:temp:	dsspos (wcs->crpix[0]+sin(rot),
distort:temp:		wcs->crpix[1]+cos(rot), wcs, &ra1, &dec1);
distort:temp:	wcs->cdelt[1] = wcsdist (ra0, dec0, ra1, dec1);
distort:temp:	wcsdeltset (wcs, wcs->cdelt[0], wcs->cdelt[1], wcs->rot);
distort:temp:	if (wcs->rot == 0.)
distort:temp:	wcs->crpix[0] = 0.5 + (wcs->nxpix * 0.5);
distort:temp:	wcs->crpix[1] = 0.5 + (wcs->nypix * 0.5);
distort:temp:	    hgetr8 (hstring,"CRPIX1",&wcs->crpix[0]);
distort:temp:	    hgetr8 (hstring,"CRPIX2",&wcs->crpix[1]);
distort:temp:	    wcs->crpix[0] = dxrefpix - (double) (ix1 - 1);
distort:temp:	    wcs->crpix[1] = dyrefpix - (double) (iy1 - 1);
distort:temp:	wcs->xrefpix = wcs->crpix[0];
distort:temp:	wcs->yrefpix = wcs->crpix[1];
distort:temp:	wcs->crval[0] = -999.0;
distort:temp:	if (!hgetra (hstring,"RA",&wcs->crval[0])) {
distort:temp:	wcs->crval[1] = -999.0;
distort:temp:	if (!hgetdec (hstring,"DEC",&wcs->crval[1])) {
distort:temp:	wcs->xref = wcs->crval[0];
distort:temp:	wcs->yref = wcs->crval[1];
distort:temp:	wcs->coorflip = 0;
distort:temp:	wcs->cel.ref[0] = wcs->crval[0];
distort:temp:	wcs->cel.ref[1] = wcs->crval[1];
distort:temp:	wcs->cel.ref[2] = 999.0;
distort:temp:	if (!hgetr8 (hstring,"LONPOLE",&wcs->cel.ref[2]))
distort:temp:	    hgetr8 (hstring,"LONGPOLE",&wcs->cel.ref[2]);
distort:temp:	wcs->cel.ref[3] = 999.0;
distort:temp:	hgetr8 (hstring,"LATPOLE",&wcs->cel.ref[3]);
distort:temp:	    wcs->epoch = 1900.0 + (mjd - 15019.81352) / 365.242198781;
distort:temp:	else if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
distort:temp:	    if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
distort:temp:		if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
distort:temp:		    wcs->epoch = wcs->equinox;
distort:temp:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:temp:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:temp:	wcs->coorflip = 0;
distort:temp:	wcs->degout = 0;
distort:temp:	wcs->ndec = 3;
distort:temp:	wcs->wcson = 1;
distort:temp:    wcs->lin.crpix = wcs->crpix;
distort:temp:    wcs->lin.cdelt = wcs->cdelt;
distort:temp:    wcs->lin.pc = wcs->pc;
distort:temp:    wcs->printsys = 1;
distort:temp:    wcs->tabsys = 0;
distort:temp:    wcs->linmode = 0;
distort:temp:    lng = wcs->wcsl.lng;
distort:temp:    lat = wcs->wcsl.lat;
distort:temp:    if (wcs->naxis != NAXISPV) {
distort:temp:    if (strcmp(wcs->wcsl.pcode, "TAN") != 0) {
distort:temp:    if ((wcs->projppv[1+lng*MAXPV] == 0) &&
distort:temp:	(wcs->projppv[1+lat*MAXPV] == 0)) {
distort:temp:    if (wcs->wcs != NULL) {
distort:temp:	pix2wcs(wcs->wcs,0,0,&xmin,&ymin);
distort:temp:	pix2wcs(wcs->wcs,wcs->nxpix,wcs->nypix,&xmax,&ymax);
distort:temp:	xmax = wcs->nxpix;
distort:temp:	ymax = wcs->nypix;
distort:temp:	    if (linrev(raw, &wcs->lin, pixin)) {
distort:temp:			 wcs->wcsl.pcode);
distort:temp:	    raw_to_pv (&wcs->prj,pixin[lng],pixin[lat], outpost, outpost+1);
distort:temp:    linrev(rawmin, &wcs->lin, pixin);
distort:temp:    linfwd(pixin, &wcs->lin, raw);
distort:temp:		 wcs->wcsl.pcode);
distort:temp:	wcs->pvfail = 1;
distort:temp:    wcs->prj.inv_x = wcs->inv_x = poly;
distort:temp:    linrev(rawmin, &wcs->lin, pixin);
distort:temp:    linfwd(pixin, &wcs->lin, raw);
distort:temp:		 wcs->wcsl.pcode);
distort:temp:	wcs->pvfail = 1;
distort:temp:    wcs->prj.inv_y = wcs->inv_y = poly;
distort:temp:    if (strlen (wcs->radecsys) == 0 || wcs->prjcode == WCS_LIN)
distort:temp:	strcpy (wcs->radecsys, "LINEAR");
distort:temp:    if (wcs->prjcode == WCS_PIX)
distort:temp:	strcpy (wcs->radecsys, "PIXEL");
distort:temp:    wcs->syswcs = wcscsys (wcs->radecsys);
distort:temp:    if (wcs->syswcs == WCS_B1950)
distort:temp:	strcpy (wcs->radecout, "FK4");
distort:temp:    else if (wcs->syswcs == WCS_J2000)
distort:temp:	strcpy (wcs->radecout, "FK5");
distort:temp:	strcpy (wcs->radecout, wcs->radecsys);
distort:temp:    wcs->sysout = wcscsys (wcs->radecout);
distort:temp:    wcs->eqout = wcs->equinox;
distort:temp:    strcpy (wcs->radecin, wcs->radecsys);
distort:temp:    wcs->sysin = wcscsys (wcs->radecin);
distort:temp:    wcs->eqin = wcs->equinox;
distort:temp:	wcs->equinox = atof (eqstring+1);
distort:temp:	wcs->equinox = atof (eqstring+1);
distort:temp:	hgetr8 (hstring, eqkey, &wcs->equinox);
distort:temp:	    wcs->equinox = 1950.0;
distort:temp:            hgetr8 (hstring,"EPOCH",&wcs->equinox);
distort:temp:	    wcs->equinox = 1950.0;
distort:temp:	    wcs->equinox = 2000.0;
distort:temp:	    wcs->equinox = 2000.0;
distort:temp:	    wcs->equinox = 2000.0;
distort:temp:	    wcs->equinox = 2000.0;
distort:temp:	wcs->equinox = 2000.0;
distort:temp:	if (!strncmp (wcs->c1type, "RA",2) || !strncmp (wcs->c1type,"DEC",3))
distort:temp:    if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
distort:temp:	if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
distort:temp:	    if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
distort:temp:		wcs->epoch = wcs->equinox;
distort:temp:		wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:temp:		wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:temp:    if (wcs->epoch == 0.0)
distort:temp:	wcs->epoch = wcs->equinox;
distort:temp:	strcpy (wcs->radecsys,systring);
distort:temp:	    if (!strncmp (wcs->radecsys,"FK4",3))
distort:temp:		wcs->equinox = 1950.0;
distort:temp:	    else if (!strncmp (wcs->radecsys,"FK5",3))
distort:temp:		wcs->equinox = 2000.0;
distort:temp:	    else if (!strncmp (wcs->radecsys,"ICRS",4))
distort:temp:		wcs->equinox = 2000.0;
distort:temp:	    else if (!strncmp (wcs->radecsys,"GAL",3) && ieq == 0)
distort:temp:		wcs->equinox = 2000.0;
distort:temp:    else if (wcs->syswcs != WCS_NPOLE) {
distort:temp:	    strcpy (wcs->radecsys,"FK5");
distort:temp:	    strcpy (wcs->radecsys,"FK4");
distort:temp:    if (wcs->c1type[0] == 'G')
distort:temp:	strcpy (wcs->radecsys,"GALACTIC");
distort:temp:    else if (wcs->c1type[0] == 'E')
distort:temp:	strcpy (wcs->radecsys,"ECLIPTIC");
distort:temp:    else if (wcs->c1type[0] == 'S')
distort:temp:	strcpy (wcs->radecsys,"SGALACTC");
distort:temp:    else if (wcs->c1type[0] == 'H')
distort:temp:	strcpy (wcs->radecsys,"HELIOECL");
distort:temp:    else if (wcs->c1type[0] == 'A')
distort:temp:	strcpy (wcs->radecsys,"ALTAZ");
distort:temp:    else if (wcs->c1type[0] == 'L')
distort:temp:	strcpy (wcs->radecsys,"LINEAR");
distort:temp:    wcs->syswcs = wcscsys (wcs->radecsys);
distort:temp: * Oct  1 2003	Rename wcs->naxes to wcs->naxis to match WCSLIB 3.2
distort:temp: * Dec  3 2003	Add back wcs->naxes for backward compatibility
distort:temp: * Feb 15 2007	Check for wcs->wcsproj > 0 instead of CTYPEi != LINEAR or PIXEL
distort:tmcread.c:    sysout = wcs->syswcs;
distort:tmcread.c:    eqout = wcs->equinox;
distort:tmcread.c:    epout = wcs->epoch;
distort:tnxpos.c:    if (wcs->longpole > 360.0) {
distort:tnxpos.c:	if (!igetr8 (str1, "longpole", &wcs->longpole)) {
distort:tnxpos.c:	    if (!igetr8 (str2, "longpole", &wcs->longpole))
distort:tnxpos.c:		wcs->longpole = 180.0;
distort:tnxpos.c:    if (!igetr8 (str1, "ro", &wcs->rodeg)) {
distort:tnxpos.c:	if (!igetr8 (str2, "ro", &wcs->rodeg))
distort:tnxpos.c:	    wcs->rodeg = 180.0 / PI;
distort:tnxpos.c:	    wcs->lngcor = NULL;
distort:tnxpos.c:	    wcs->lngcor = wf_gsopen (lngstr);
distort:tnxpos.c:	wcs->lngcor = wf_gsopen (lngstr);
distort:tnxpos.c:	    wcs->latcor = NULL;
distort:tnxpos.c:	    wcs->latcor = wf_gsopen (latstr);
distort:tnxpos.c:	wcs->latcor = wf_gsopen (latstr);
distort:tnxpos.c:    if (wcs->latcor == NULL && wcs->lngcor == NULL)
distort:tnxpos.c:    xpix = xpix - wcs->crpix[0];
distort:tnxpos.c:    ypix = ypix - wcs->crpix[1];
distort:tnxpos.c:    if (wcs->rotmat) {
distort:tnxpos.c:	x = xpix * wcs->cd[0] + ypix * wcs->cd[1];
distort:tnxpos.c:	y = xpix * wcs->cd[2] + ypix * wcs->cd[3];
distort:tnxpos.c:	if (wcs->cdelt[0] == 0.0 || wcs->cdelt[1] == 0.0) {
distort:tnxpos.c:	xs = xpix * wcs->cdelt[0];
distort:tnxpos.c:	ys = ypix * wcs->cdelt[1];
distort:tnxpos.c:	if (wcs->rot != 0.0) {
distort:tnxpos.c:	    double cosr = cos (degrad (wcs->rot));
distort:tnxpos.c:	    double sinr = sin (degrad (wcs->rot));
distort:tnxpos.c:    if (wcs->coorflip) {
distort:tnxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
distort:tnxpos.c:    longp = degrad(wcs->longpole);
distort:tnxpos.c:    if (wcs->lngcor != NULL)
distort:tnxpos.c:	xp = x + wf_gseval (wcs->lngcor, x, y);
distort:tnxpos.c:    if (wcs->latcor != NULL)
distort:tnxpos.c:	yp = y + wf_gseval (wcs->latcor, x, y);
distort:tnxpos.c:    theta = atan2 (wcs->rodeg, r);
distort:tnxpos.c:    ra =  wcs->crval[ira] + raddeg(dlng);
distort:tnxpos.c:    if (wcs->crval[ira] >= 0.0) {
distort:tnxpos.c:    if (wcs->coorflip) {
distort:tnxpos.c:    ra  = degrad (xpos - wcs->crval[ira]);
distort:tnxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
distort:tnxpos.c:    if (wcs->longpole == 999.0)
distort:tnxpos.c:	longp = degrad(wcs->longpole);
distort:tnxpos.c:	r = wcs->rodeg * cos (theta) / s;
distort:tnxpos.c:	if (wcs->lngcor == NULL && wcs->latcor == NULL) {
distort:tnxpos.c:	    if (wcs->coorflip) {
distort:tnxpos.c:		if (wcs->lngcor != NULL) {
distort:tnxpos.c:		    f = x + wf_gseval (wcs->lngcor, x, y) - xm;
distort:tnxpos.c:		    fx = wf_gsder (wcs->lngcor, x, y, 1, 0);
distort:tnxpos.c:		    fy = wf_gsder (wcs->lngcor, x, y, 0, 1);
distort:tnxpos.c:		if (wcs->latcor != NULL) {
distort:tnxpos.c:		    g = y + wf_gseval (wcs->latcor, x, y) - ym;
distort:tnxpos.c:		    gx = wf_gsder (wcs->latcor, x, y, 1, 0);
distort:tnxpos.c:		    gy = wf_gsder (wcs->latcor, x, y, 0, 1);
distort:tnxpos.c:	    if (wcs->coorflip) {
distort:tnxpos.c:    if (wcs->rotmat) {
distort:tnxpos.c:	*xpix = x * wcs->dc[0] + y * wcs->dc[1];
distort:tnxpos.c:	*ypix = x * wcs->dc[2] + y * wcs->dc[3];
distort:tnxpos.c:	if (wcs->rot!=0.0) {
distort:tnxpos.c:	    double cosr = cos (degrad (wcs->rot));
distort:tnxpos.c:	    double sinr = sin (degrad (wcs->rot));
distort:tnxpos.c:	if (wcs->xinc != 0.)
distort:tnxpos.c:	    *xpix = *xpix / wcs->xinc;
distort:tnxpos.c:	if (wcs->yinc != 0.)
distort:tnxpos.c:	    *ypix = *ypix / wcs->yinc;
distort:tnxpos.c:    *xpix = *xpix + wcs->xrefpix;
distort:tnxpos.c:    *ypix = *ypix + wcs->yrefpix;
distort:tnxpos.c:    if (wcs->lngcor != NULL)
distort:tnxpos.c:	wf_gsclose (wcs->lngcor);
distort:tnxpos.c:    if (wcs->latcor != NULL)
distort:tnxpos.c:	wf_gsclose (wcs->latcor);
distort:tnxpos.c:    wcs->prjcode = WCS_TNX;
distort:tnxpos.c:    wcs->lngcor = wf_gspset (xorder, yorder, xterms, coeff);
distort:tnxpos.c:    ycoeff = coeff + wcs->lngcor->ncoeff;
distort:tnxpos.c:    wcs->latcor = wf_gspset (xorder, yorder, xterms, ycoeff);
distort:tnxpos.c: * Dec 10 1999	Compute wcs->rot using wcsrotset() in tnxinit()
distort:ty2read.c:    sysout = wcs->syswcs;
distort:ty2read.c:    eqout = wcs->equinox;
distort:ty2read.c:    epout = wcs->epoch;
distort:uacread.c:    sysout = wcs->syswcs;
distort:uacread.c:    eqout = wcs->equinox;
distort:uacread.c:    epout = wcs->epoch;
distort:ubcread.c:    sysout = wcs->syswcs;
distort:ubcread.c:    eqout = wcs->equinox;
distort:ubcread.c:    epout = wcs->epoch;
distort:ucacread.c:    sysout = wcs->syswcs;
distort:ucacread.c:    eqout = wcs->equinox;
distort:ucacread.c:    epout = wcs->epoch;
distort:ujcread.c:    sysout = wcs->syswcs;
distort:ujcread.c:    eqout = wcs->equinox;
distort:ujcread.c:    epout = wcs->epoch;
distort:wcs.c:    if (wcs->wcs) {
distort:wcs.c:	wcsfree (wcs->wcs);
distort:wcs.c:	wcs->wcs = NULL;
distort:wcs.c:    if (wcs->wcsname != NULL)
distort:wcs.c:	free (wcs->wcsname);
distort:wcs.c:    if (wcs->lin.imgpix != NULL)
distort:wcs.c:	free (wcs->lin.imgpix);
distort:wcs.c:    if (wcs->lin.piximg != NULL)
distort:wcs.c:	free (wcs->lin.piximg);
distort:wcs.c:    if (wcs->inv_x != NULL)
distort:wcs.c:	poly_end (wcs->inv_x);
distort:wcs.c:    if (wcs->inv_y != NULL)
distort:wcs.c:	poly_end (wcs->inv_y);
distort:wcs.c:    wcs->cel.flag = 0;
distort:wcs.c:    wcs->lin.flag = 0;
distort:wcs.c:    wcs->wcsl.flag = 0;
distort:wcs.c:    wcs->naxis = 2;
distort:wcs.c:    wcs->naxes = 2;
distort:wcs.c:    wcs->lin.naxis = 2;
distort:wcs.c:    wcs->nxpix = nxpix;
distort:wcs.c:    wcs->nypix = nypix;
distort:wcs.c:    wcs->wcsproj = wcsproj0;
distort:wcs.c:    wcs->crpix[0] = xrpix;
distort:wcs.c:    wcs->crpix[1] = yrpix;
distort:wcs.c:    wcs->xrefpix = wcs->crpix[0];
distort:wcs.c:    wcs->yrefpix = wcs->crpix[1];
distort:wcs.c:    wcs->lin.crpix = wcs->crpix;
distort:wcs.c:    wcs->crval[0] = cra;
distort:wcs.c:    wcs->crval[1] = cdec;
distort:wcs.c:    wcs->xref = wcs->crval[0];
distort:wcs.c:    wcs->yref = wcs->crval[1];
distort:wcs.c:    wcs->cel.ref[0] = wcs->crval[0];
distort:wcs.c:    wcs->cel.ref[1] = wcs->crval[1];
distort:wcs.c:    wcs->cel.ref[2] = 999.0;
distort:wcs.c:    strcpy (wcs->c1type,"RA");
distort:wcs.c:    strcpy (wcs->c2type,"DEC");
distort:wcs.c:    strcpy (wcs->ptype,proj);
distort:wcs.c:    strcpy (wcs->ctype[0],"RA---");
distort:wcs.c:    strcpy (wcs->ctype[1],"DEC--");
distort:wcs.c:    strcat (wcs->ctype[0],proj);
distort:wcs.c:    strcat (wcs->ctype[1],proj);
distort:wcs.c:    if (wcstype (wcs, wcs->ctype[0], wcs->ctype[1])) {
distort:wcs.c:    wcs->lin.cdelt = wcs->cdelt;
distort:wcs.c:    wcs->lin.pc = wcs->pc;
distort:wcs.c:    wcs->equinox =  (double) equinox;
distort:wcs.c:	strcpy (wcs->radecsys,"FK5");
distort:wcs.c:	strcpy (wcs->radecsys,"FK4");
distort:wcs.c:	wcs->epoch = epoch;
distort:wcs.c:	wcs->epoch = 0.0;
distort:wcs.c:    wcs->wcson = 1;
distort:wcs.c:    wcs->syswcs = wcscsys (wcs->radecsys);
distort:wcs.c:    wcsoutinit (wcs, wcs->radecsys);
distort:wcs.c:    wcsininit (wcs, wcs->radecsys);
distort:wcs.c:    wcs->eqout = 0.0;
distort:wcs.c:    wcs->printsys = 1;
distort:wcs.c:    wcs->tabsys = 0;
distort:wcs.c:    wcs->cel.flag = 0;
distort:wcs.c:    wcs->lin.flag = 0;
distort:wcs.c:    wcs->wcsl.flag = 0;
distort:wcs.c:    wcs->naxis = 2;
distort:wcs.c:    wcs->naxes = 2;
distort:wcs.c:    wcs->lin.naxis = 2;
distort:wcs.c:    wcs->nxpix = naxis1;
distort:wcs.c:    wcs->nypix = naxis2;
distort:wcs.c:    wcs->wcsproj = wcsproj0;
distort:wcs.c:    wcs->crpix[0] = crpix1;
distort:wcs.c:    wcs->crpix[1] = crpix2;
distort:wcs.c:    wcs->xrefpix = wcs->crpix[0];
distort:wcs.c:    wcs->yrefpix = wcs->crpix[1];
distort:wcs.c:    wcs->lin.crpix = wcs->crpix;
distort:wcs.c:    if (wcs->latbase == 90)
distort:wcs.c:    else if (wcs->latbase == -90)
distort:wcs.c:    wcs->crval[0] = crval1;
distort:wcs.c:    wcs->crval[1] = crval2;
distort:wcs.c:    wcs->xref = wcs->crval[0];
distort:wcs.c:    wcs->yref = wcs->crval[1];
distort:wcs.c:    wcs->cel.ref[0] = wcs->crval[0];
distort:wcs.c:    wcs->cel.ref[1] = wcs->crval[1];
distort:wcs.c:    wcs->cel.ref[2] = 999.0;
distort:wcs.c:    wcs->lin.cdelt = wcs->cdelt;
distort:wcs.c:    wcs->lin.pc = wcs->pc;
distort:wcs.c:    wcs->equinox =  (double) equinox;
distort:wcs.c:	strcpy (wcs->radecsys,"FK5");
distort:wcs.c:	strcpy (wcs->radecsys,"FK4");
distort:wcs.c:	wcs->epoch = epoch;
distort:wcs.c:	wcs->epoch = 0.0;
distort:wcs.c:    wcs->wcson = 1;
distort:wcs.c:    strcpy (wcs->radecout, wcs->radecsys);
distort:wcs.c:    wcs->syswcs = wcscsys (wcs->radecsys);
distort:wcs.c:    wcsoutinit (wcs, wcs->radecsys);
distort:wcs.c:    wcsininit (wcs, wcs->radecsys);
distort:wcs.c:    wcs->eqout = 0.0;
distort:wcs.c:    wcs->printsys = 1;
distort:wcs.c:    wcs->tabsys = 0;
distort:wcs.c:    strcpy (wcs->ctype[0], ctype1);
distort:wcs.c:    strcpy (wcs->c1type, ctype1);
distort:wcs.c:    strcpy (wcs->ptype, ctype1);
distort:wcs.c:	wcs->prjcode = WCS_LIN;
distort:wcs.c:	wcs->prjcode = WCS_PIX;
distort:wcs.c:	wcs->prjcode = WCS_PIX;
distort:wcs.c:	wcs->c1type[0] = ctype1[0];
distort:wcs.c:	wcs->c1type[1] = ctype1[1];
distort:wcs.c:	    wcs->c1type[2] = 0;
distort:wcs.c:	    wcs->c1type[2] = ctype1[2];
distort:wcs.c:		wcs->c1type[3] = 0;
distort:wcs.c:		wcs->c1type[3] = ctype1[3];
distort:wcs.c:		wcs->c1type[4] = 0;
distort:wcs.c:	wcs->ptype[0] = ctype1[iproj];
distort:wcs.c:	wcs->ptype[1] = ctype1[iproj+1];
distort:wcs.c:	wcs->ptype[2] = ctype1[iproj+2];
distort:wcs.c:	wcs->ptype[3] = 0;
distort:wcs.c:	sprintf (wcs->ctype[0],"%-4s%4s",wcs->c1type,wcs->ptype);
distort:wcs.c:	    if (wcs->ctype[0][i] == ' ') wcs->ctype[0][i] = '-';
distort:wcs.c:	wcs->prjcode = 0;  /* default type is linear */
distort:wcs.c:	    if (!strncmp(wcs->ptype, ctypes[i], 3))
distort:wcs.c:		wcs->prjcode = i;
distort:wcs.c:	if (wcs->prjcode == WCS_NCP) {
distort:wcs.c:	    if (wcs->wcsproj == WCS_BEST)
distort:wcs.c:		wcs->wcsproj = WCS_OLD;
distort:wcs.c:	    else if (wcs->wcsproj == WCS_ALT)
distort:wcs.c:		wcs->wcsproj = WCS_NEW;
distort:wcs.c:	else if (wcs->prjcode == WCS_CAR) {
distort:wcs.c:	    if (wcs->wcsproj == WCS_BEST)
distort:wcs.c:		wcs->wcsproj = WCS_OLD;
distort:wcs.c:	    else if (wcs->wcsproj == WCS_ALT)
distort:wcs.c:		wcs->wcsproj = WCS_NEW;
distort:wcs.c:	else if (wcs->prjcode == WCS_COE) {
distort:wcs.c:	    if (wcs->wcsproj == WCS_BEST)
distort:wcs.c:		wcs->wcsproj = WCS_OLD;
distort:wcs.c:	    else if (wcs->wcsproj == WCS_ALT)
distort:wcs.c:		wcs->wcsproj = WCS_NEW;
distort:wcs.c:	else if (wcs->wcsproj == WCS_BEST) */
distort:wcs.c:	if (wcs->wcsproj == WCS_BEST)
distort:wcs.c:	    wcs->wcsproj = WCS_NEW;
distort:wcs.c:	else if (wcs->wcsproj == WCS_ALT)
distort:wcs.c:	    wcs->wcsproj = WCS_OLD;
distort:wcs.c:	/* if (wcs->wcsproj == WCS_OLD && (
distort:wcs.c:	    wcs->prjcode != WCS_STG && wcs->prjcode != WCS_AIT &&
distort:wcs.c:	    wcs->prjcode != WCS_MER && wcs->prjcode != WCS_GLS &&
distort:wcs.c:	    wcs->prjcode != WCS_ARC && wcs->prjcode != WCS_TAN &&
distort:wcs.c:	    wcs->prjcode != WCS_TNX && wcs->prjcode != WCS_SIN &&
distort:wcs.c:	    wcs->prjcode != WCS_PIX && wcs->prjcode != WCS_LIN &&
distort:wcs.c:	    wcs->prjcode != WCS_CAR && wcs->prjcode != WCS_COE &&
distort:wcs.c:	    wcs->prjcode != WCS_NCP && wcs->prjcode != WCS_ZPX))
distort:wcs.c:	    wcs->wcsproj = WCS_NEW; */
distort:wcs.c:	if (wcs->wcsproj == WCS_OLD && wcs->prjcode == WCS_TNX) {
distort:wcs.c:	    wcs->ctype[0][6] = 'A';
distort:wcs.c:	    wcs->ctype[0][7] = 'N';
distort:wcs.c:	    wcs->prjcode = WCS_TAN;
distort:wcs.c:	if (wcs->wcsproj == WCS_OLD && wcs->prjcode == WCS_ZPX) {
distort:wcs.c:	    wcs->ctype[0][6] = 'P';
distort:wcs.c:	    wcs->ctype[0][7] = 'N';
distort:wcs.c:	    wcs->prjcode = WCS_ZPN;
distort:wcs.c:	wcs->prjcode = WCS_LIN;
distort:wcs.c:	wcs->latbase = 90;
distort:wcs.c:	strcpy (wcs->radecsys,"NPOLE");
distort:wcs.c:	wcs->syswcs = WCS_NPOLE;
distort:wcs.c:	wcs->latbase = -90;
distort:wcs.c:	strcpy (wcs->radecsys,"SPA");
distort:wcs.c:	wcs->syswcs = WCS_SPA;
distort:wcs.c:	wcs->latbase = 0;
distort:wcs.c:    strcpy (wcs->ctype[1], ctype2);
distort:wcs.c:    strcpy (wcs->c2type, ctype2);
distort:wcs.c:	wcs->prjcode = WCS_LIN;
distort:wcs.c:	wcs->prjcode = WCS_PIX;
distort:wcs.c:	wcs->c2type[0] = ctype2[0];
distort:wcs.c:	wcs->c2type[1] = ctype2[1];
distort:wcs.c:	    wcs->c2type[2] = 0;
distort:wcs.c:	    wcs->c2type[2] = ctype2[2];
distort:wcs.c:		wcs->c2type[3] = 0;
distort:wcs.c:		wcs->c2type[3] = ctype2[3];
distort:wcs.c:		wcs->c2type[4] = 0;
distort:wcs.c:	wcs->ptype[0] = ctype2[iproj];
distort:wcs.c:	wcs->ptype[1] = ctype2[iproj+1];
distort:wcs.c:	wcs->ptype[2] = ctype2[iproj+2];
distort:wcs.c:	wcs->ptype[3] = 0;
distort:wcs.c:	    wcs->coorflip = 1;
distort:wcs.c:	    wcs->coorflip = 0;
distort:wcs.c:	    wcs->degout = 1;
distort:wcs.c:	    wcs->ndec = 5;
distort:wcs.c:	    wcs->degout = 0;
distort:wcs.c:	    wcs->ndec = 3;
distort:wcs.c:	sprintf (wcs->ctype[1],"%-4s%4s",wcs->c2type,wcs->ptype);
distort:wcs.c:	    if (wcs->ctype[1][i] == ' ') wcs->ctype[1][i] = '-';
distort:wcs.c:	wcs->prjcode = WCS_LIN;
distort:wcs.c:    wcs->cel.flag = 0;
distort:wcs.c:    wcs->lin.flag = 0;
distort:wcs.c:    wcs->wcsl.flag = 0;
distort:wcs.c:    wcs->crpix[0] = crpix1;
distort:wcs.c:    wcs->crpix[1] = crpix2;
distort:wcs.c:    wcs->xrefpix = wcs->crpix[0];
distort:wcs.c:    wcs->yrefpix = wcs->crpix[1];
distort:wcs.c:    wcs->lin.crpix = wcs->crpix;
distort:wcs.c:    wcs->crval[0] = crval1;
distort:wcs.c:    wcs->crval[1] = crval2;
distort:wcs.c:    wcs->xref = wcs->crval[0];
distort:wcs.c:    wcs->yref = wcs->crval[1];
distort:wcs.c:    if (wcs->coorflip) {
distort:wcs.c:	wcs->cel.ref[1] = wcs->crval[0];
distort:wcs.c:	wcs->cel.ref[0] = wcs->crval[1];
distort:wcs.c:	wcs->cel.ref[0] = wcs->crval[0];
distort:wcs.c:	wcs->cel.ref[1] = wcs->crval[1];
distort:wcs.c:    wcs->ncoeff1 = 0;
distort:wcs.c:    wcs->ncoeff2 = 0;
distort:wcs.c:	wcs->xinc = 1.0;
distort:wcs.c:	wcs->yinc = 1.0;
distort:wcs.c:    if (!strncmp (wcs->ptype,"LINEAR",6) ||
distort:wcs.c:	!strncmp (wcs->ptype,"PIXEL",5))
distort:wcs.c:	wcs->degout = -1;
distort:wcs.c:    wcs->wcson = 1;
distort:wcs.c:    if (wcs->equinox == equinox)
distort:wcs.c:    if (equinox == 2000.0 && wcs->equinox == 1950.0) {
distort:wcs.c:	if (wcs->coorflip) { 
distort:wcs.c:	    fk425e (&wcs->crval[1], &wcs->crval[0], wcs->epoch);
distort:wcs.c:	    wcs->cel.ref[1] = wcs->crval[0];
distort:wcs.c:	    wcs->cel.ref[0] = wcs->crval[1];
distort:wcs.c:	    fk425e (&wcs->crval[0], &wcs->crval[1], wcs->epoch);
distort:wcs.c:	    wcs->cel.ref[0] = wcs->crval[0];
distort:wcs.c:	    wcs->cel.ref[1] = wcs->crval[1];
distort:wcs.c:	wcs->xref = wcs->crval[0];
distort:wcs.c:	wcs->yref = wcs->crval[1];
distort:wcs.c:	wcs->equinox = 2000.0;
distort:wcs.c:	strcpy (wcs->radecsys, "FK5");
distort:wcs.c:	wcs->syswcs = WCS_J2000;
distort:wcs.c:	wcs->cel.flag = 0;
distort:wcs.c:	wcs->wcsl.flag = 0;
distort:wcs.c:    else if (equinox == 1950.0 && wcs->equinox == 2000.0) {
distort:wcs.c:	if (wcs->coorflip) { 
distort:wcs.c:	    fk524e (&wcs->crval[1], &wcs->crval[0], wcs->epoch);
distort:wcs.c:	    wcs->cel.ref[1] = wcs->crval[0];
distort:wcs.c:	    wcs->cel.ref[0] = wcs->crval[1];
distort:wcs.c:	    fk524e (&wcs->crval[0], &wcs->crval[1], wcs->epoch);
distort:wcs.c:	    wcs->cel.ref[0] = wcs->crval[0];
distort:wcs.c:	    wcs->cel.ref[1] = wcs->crval[1];
distort:wcs.c:	wcs->xref = wcs->crval[0];
distort:wcs.c:	wcs->yref = wcs->crval[1];
distort:wcs.c:	wcs->equinox = 1950.0;
distort:wcs.c:	strcpy (wcs->radecsys, "FK4");
distort:wcs.c:	wcs->syswcs = WCS_B1950;
distort:wcs.c:	wcs->cel.flag = 0;
distort:wcs.c:	wcs->wcsl.flag = 0;
distort:wcs.c:    wcsoutinit (wcs, wcs->radecsys);
distort:wcs.c:    wcsininit (wcs, wcs->radecsys);
distort:wcs.c:    wcs->rotmat = 1;
distort:wcs.c:    wcs->cd[0] = cd[0];
distort:wcs.c:    wcs->cd[1] = cd[1];
distort:wcs.c:    wcs->cd[2] = cd[2];
distort:wcs.c:    wcs->cd[3] = cd[3];
distort:wcs.c:    (void) matinv (2, wcs->cd, wcs->dc);
distort:wcs.c:    wcs->xinc = sqrt (cd[0]*cd[0] + cd[2]*cd[2]);
distort:wcs.c:    wcs->yinc = sqrt (cd[1]*cd[1] + cd[3]*cd[3]);
distort:wcs.c:    if (wcs->coorflip) {
distort:wcs.c:    wcs->wcson = 1;
distort:wcs.c:    wcs->cdelt[0] = wcs->xinc;
distort:wcs.c:    wcs->cdelt[1] = wcs->yinc;
distort:wcs.c:    naxes = wcs->naxis;
distort:wcs.c:    wcs->cdelt[0] = cdelt1;
distort:wcs.c:	wcs->cdelt[1] = cdelt2;
distort:wcs.c:	wcs->cdelt[1] = cdelt1;
distort:wcs.c:    wcs->xinc = wcs->cdelt[0];
distort:wcs.c:    wcs->yinc = wcs->cdelt[1];
distort:wcs.c:    pci = wcs->pc;
distort:wcs.c:    wcs->rotmat = 0;
distort:wcs.c:    wcs->rot = crota;
distort:wcs.c:    if (wcs->rot < 0.0)
distort:wcs.c:	wcs->rot = wcs->rot + 360.0;
distort:wcs.c:    if (wcs->rot >= 360.0)
distort:wcs.c:	wcs->rot = wcs->rot - 360.0;
distort:wcs.c:    crot = cos (degrad(wcs->rot));
distort:wcs.c:	srot = sin (-degrad(wcs->rot));
distort:wcs.c:	srot = sin (degrad(wcs->rot));
distort:wcs.c:    wcs->cd[0] = wcs->cdelt[0] * crot;
distort:wcs.c:    if (wcs->cdelt[0] < 0)
distort:wcs.c:	wcs->cd[1] = -fabs (wcs->cdelt[1]) * srot;
distort:wcs.c:	wcs->cd[1] = fabs (wcs->cdelt[1]) * srot;
distort:wcs.c:    if (wcs->cdelt[1] < 0)
distort:wcs.c:	wcs->cd[2] = fabs (wcs->cdelt[0]) * srot;
distort:wcs.c:	wcs->cd[2] = -fabs (wcs->cdelt[0]) * srot;
distort:wcs.c:    wcs->cd[3] = wcs->cdelt[1] * crot;
distort:wcs.c:    (void) matinv (2, wcs->cd, wcs->dc);
distort:wcs.c:    if (wcs->coorflip) {
distort:wcs.c:	if (wcs->cdelt[0] < 0 && wcs->cdelt[1] > 0) {
distort:wcs.c:	    wcs->imflip = 1;
distort:wcs.c:	    wcs->imrot = wcs->rot - 90.0;
distort:wcs.c:	    if (wcs->imrot < -180.0) wcs->imrot = wcs->imrot + 360.0;
distort:wcs.c:	    wcs->pa_north = wcs->rot;
distort:wcs.c:	    wcs->pa_east = wcs->rot - 90.0;
distort:wcs.c:	    if (wcs->pa_east < -180.0) wcs->pa_east = wcs->pa_east + 360.0;
distort:wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] < 0) {
distort:wcs.c:	    wcs->imflip = 1;
distort:wcs.c:	    wcs->imrot = wcs->rot + 90.0;
distort:wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
distort:wcs.c:	    wcs->pa_north = wcs->rot;
distort:wcs.c:	    wcs->pa_east = wcs->rot - 90.0;
distort:wcs.c:	    if (wcs->pa_east < -180.0) wcs->pa_east = wcs->pa_east + 360.0;
distort:wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] > 0) {
distort:wcs.c:	    wcs->imflip = 0;
distort:wcs.c:	    wcs->imrot = wcs->rot + 90.0;
distort:wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
distort:wcs.c:	    wcs->pa_north = wcs->imrot;
distort:wcs.c:	    wcs->pa_east = wcs->rot + 90.0;
distort:wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
distort:wcs.c:	else if (wcs->cdelt[0] < 0 && wcs->cdelt[1] < 0) {
distort:wcs.c:	    wcs->imflip = 0;
distort:wcs.c:	    wcs->imrot = wcs->rot - 90.0;
distort:wcs.c:	    if (wcs->imrot < -180.0) wcs->imrot = wcs->imrot + 360.0;
distort:wcs.c:	    wcs->pa_north = wcs->imrot;
distort:wcs.c:	    wcs->pa_east = wcs->rot + 90.0;
distort:wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
distort:wcs.c:	if (wcs->cdelt[0] < 0 && wcs->cdelt[1] > 0) {
distort:wcs.c:	    wcs->imflip = 0;
distort:wcs.c:	    wcs->imrot = wcs->rot;
distort:wcs.c:	    wcs->pa_north = wcs->rot + 90.0;
distort:wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
distort:wcs.c:	    wcs->pa_east = wcs->rot + 180.0;
distort:wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
distort:wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] < 0) {
distort:wcs.c:	    wcs->imflip = 0;
distort:wcs.c:	    wcs->imrot = wcs->rot + 180.0;
distort:wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
distort:wcs.c:	    wcs->pa_north = wcs->imrot + 90.0;
distort:wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
distort:wcs.c:	    wcs->pa_east = wcs->imrot + 180.0;
distort:wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
distort:wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] > 0) {
distort:wcs.c:	    wcs->imflip = 1;
distort:wcs.c:	    wcs->imrot = -wcs->rot;
distort:wcs.c:	    wcs->pa_north = wcs->imrot + 90.0;
distort:wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
distort:wcs.c:	    wcs->pa_east = wcs->rot;
distort:wcs.c:	else if (wcs->cdelt[0] < 0 && wcs->cdelt[1] < 0) {
distort:wcs.c:	    wcs->imflip = 1;
distort:wcs.c:	    wcs->imrot = wcs->rot + 180.0;
distort:wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
distort:wcs.c:	    wcs->pa_north = wcs->imrot + 90.0;
distort:wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
distort:wcs.c:	    wcs->pa_east = wcs->rot + 90.0;
distort:wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
distort:wcs.c:    naxes = wcs->naxis;
distort:wcs.c:	naxes = wcs->naxes;
distort:wcs.c:	wcs->naxis = naxes;
distort:wcs.c:    wcs->cdelt[0] = cdelt1;
distort:wcs.c:	wcs->cdelt[1] = cdelt2;
distort:wcs.c:	wcs->cdelt[1] = cdelt1;
distort:wcs.c:    wcs->xinc = wcs->cdelt[0];
distort:wcs.c:    wcs->yinc = wcs->cdelt[1];
distort:wcs.c:    pci = wcs->pc;
distort:wcs.c:	wcs->cd[0] = pc[0] * wcs->cdelt[0];
distort:wcs.c:	wcs->cd[1] = pc[1] * wcs->cdelt[0];
distort:wcs.c:	wcs->cd[2] = pc[naxes] * wcs->cdelt[1];
distort:wcs.c:	wcs->cd[3] = pc[naxes+1] * wcs->cdelt[1];
distort:wcs.c:	wcs->cd[0] = pc[0] * wcs->cdelt[0];
distort:wcs.c:	wcs->cd[1] = 0.0;
distort:wcs.c:	wcs->cd[2] = 0.0;
distort:wcs.c:	wcs->cd[3] = 1.0;
distort:wcs.c:    (void) matinv (2, wcs->cd, wcs->dc);
distort:wcs.c:    wcs->rotmat = 1;
distort:wcs.c:    (void)linset (&wcs->lin);
distort:wcs.c:    wcs->wcson = 1;
distort:wcs.c:    naxes = wcs->naxis;
distort:wcs.c:	naxes = wcs->naxes;
distort:wcs.c:	wcs->naxis = naxes;
distort:wcs.c:    if (wcs->lin.piximg == NULL)
distort:wcs.c:	wcs->lin.piximg = (double*)malloc(mem);
distort:wcs.c:    if (wcs->lin.piximg != NULL) {
distort:wcs.c:	if (wcs->lin.imgpix == NULL)
distort:wcs.c:	    wcs->lin.imgpix = (double*)malloc(mem);
distort:wcs.c:	if (wcs->lin.imgpix != NULL) {
distort:wcs.c:	    wcs->lin.flag = LINSET;
distort:wcs.c:		    wcs->lin.piximg[i] = wcs->cd[i];
distort:wcs.c:		    wcs->lin.piximg[i] = 0.0;
distort:wcs.c:		wcs->lin.piximg[0] = wcs->cd[0];
distort:wcs.c:		wcs->lin.piximg[1] = wcs->cd[1];
distort:wcs.c:		wcs->lin.piximg[3] = wcs->cd[2];
distort:wcs.c:		wcs->lin.piximg[4] = wcs->cd[3];
distort:wcs.c:		wcs->lin.piximg[8] = 1.0;
distort:wcs.c:		    wcs->lin.piximg[i] = 0.0;
distort:wcs.c:		wcs->lin.piximg[0] = wcs->cd[0];
distort:wcs.c:		wcs->lin.piximg[1] = wcs->cd[1];
distort:wcs.c:		wcs->lin.piximg[4] = wcs->cd[2];
distort:wcs.c:		wcs->lin.piximg[5] = wcs->cd[3];
distort:wcs.c:		wcs->lin.piximg[10] = 1.0;
distort:wcs.c:		wcs->lin.piximg[15] = 1.0;
distort:wcs.c:	    (void) matinv (naxes, wcs->lin.piximg, wcs->lin.imgpix);
distort:wcs.c:	    wcs->lin.crpix = wcs->crpix;
distort:wcs.c:	    wcs->lin.cdelt = wcs->cdelt;
distort:wcs.c:	    wcs->lin.pc = wcs->pc;
distort:wcs.c:	    wcs->lin.flag = LINSET;
distort:wcs.c:    if (wcs->nxpix < 1.5 || wcs->nypix < 1.5) {
distort:wcs.c:	wcs->imrot = wcs->rot;
distort:wcs.c:	wcs->pa_north = wcs->rot + 90.0;
distort:wcs.c:	wcs->pa_east = wcs->rot + 180.0;
distort:wcs.c:    if (wcs->syswcs == WCS_LINEAR)
distort:wcs.c:    wcs->xinc = fabs (wcs->xinc);
distort:wcs.c:    wcs->yinc = fabs (wcs->yinc);
distort:wcs.c:    xc = wcs->xrefpix;
distort:wcs.c:    yc = wcs->yrefpix;
distort:wcs.c:    if (wcs->coorflip) {
distort:wcs.c:	wcs2pix (wcs, cra+wcs->yinc, cdec, &xe, &ye, &off);
distort:wcs.c:	wcs2pix (wcs, cra, cdec+wcs->xinc, &xn, &yn, &off);
distort:wcs.c:	wcs2pix (wcs, cra+wcs->xinc, cdec, &xe, &ye, &off);
distort:wcs.c:	wcs2pix (wcs, cra, cdec+wcs->yinc, &xn, &yn, &off);
distort:wcs.c:    wcs->pa_north = raddeg (atan2 (yn-yc, xn-xc));
distort:wcs.c:    if (wcs->pa_north < -90.0)
distort:wcs.c:	wcs->pa_north = wcs->pa_north + 360.0;
distort:wcs.c:    wcs->pa_east = raddeg (atan2 (ye-yc, xe-xc));
distort:wcs.c:    if (wcs->pa_east < -90.0)
distort:wcs.c:	wcs->pa_east = wcs->pa_east + 360.0;
distort:wcs.c:    if (wcs->pa_north < -90.0)
distort:wcs.c:	wcs->imrot = 270.0 + wcs->pa_north;
distort:wcs.c:	wcs->imrot = wcs->pa_north - 90.0;
distort:wcs.c:    if (wcs->coorflip) {
distort:wcs.c:	wcs->rot = wcs->imrot + 90.0;
distort:wcs.c:	if (wcs->rot < 0.0)
distort:wcs.c:	    wcs->rot = wcs->rot + 360.0;
distort:wcs.c:	wcs->rot = wcs->imrot;
distort:wcs.c:    if (wcs->rot < 0.0)
distort:wcs.c:	wcs->rot = wcs->rot + 360.0;
distort:wcs.c:    if (wcs->rot >= 360.0)
distort:wcs.c:	wcs->rot = wcs->rot - 360.0;
distort:wcs.c:    wcs->imflip = 0;
distort:wcs.c:    if (wcs->pa_east - wcs->pa_north < -80.0 &&
distort:wcs.c:	wcs->pa_east - wcs->pa_north > -100.0)
distort:wcs.c:	wcs->imflip = 1;
distort:wcs.c:    if (wcs->pa_east - wcs->pa_north < 280.0 &&
distort:wcs.c:	wcs->pa_east - wcs->pa_north > 260.0)
distort:wcs.c:	wcs->imflip = 1;
distort:wcs.c:    if (wcs->pa_north - wcs->pa_east > 80.0 &&
distort:wcs.c:	wcs->pa_north - wcs->pa_east < 100.0)
distort:wcs.c:	wcs->imflip = 1;
distort:wcs.c:    if (wcs->coorflip) {
distort:wcs.c:	if (wcs->imflip)
distort:wcs.c:	    wcs->yinc = -wcs->yinc;
distort:wcs.c:	if (!wcs->imflip)
distort:wcs.c:	    wcs->xinc = -wcs->xinc;
distort:wcs.c:	return (wcs->wcson);
distort:wcs.c:	return (!wcs->wcson);
distort:wcs.c:    wcs->crval[0] = rra;
distort:wcs.c:    wcs->crval[1] = rdec;
distort:wcs.c:    wcs->xref = wcs->crval[0];
distort:wcs.c:    wcs->yref = wcs->crval[1];
distort:wcs.c:    strcpy (wcs->radecsys,coorsys);
distort:wcs.c:    wcs->syswcs = wcscsys (coorsys);
distort:wcs.c:    if (wcs->syswcs == WCS_B1950)
distort:wcs.c:	wcs->equinox = 1950.0;
distort:wcs.c:	wcs->equinox = 2000.0;
distort:wcs.c:	if (wcs->prjcode == WCS_DSS)
distort:wcs.c:	    (void)fprintf (stderr,"WCS plate center  %s\n", wcs->center);
distort:wcs.c:	xpix = 0.5 * wcs->nxpix;
distort:wcs.c:	ypix = 0.5 * wcs->nypix;
distort:wcs.c:		     wcs->ctype[0],wcs->ctype[1],wcstring,wcs->ptype,xpix,ypix);
distort:wcs.c:	(void) pix2wcs (wcs,wcs->nxpix,ypix,&xpos2,&ypos2);
distort:wcs.c:	if (wcs->syswcs == WCS_LINEAR) {
distort:wcs.c:	    (void)fprintf (stderr, "WCS width = %.5f %s ",width, wcs->units[0]);
distort:wcs.c:	    (void)fprintf (stderr, "WCS width = %.3f %s ",width, wcs->units[0]);
distort:wcs.c:	secpixw = width / (wcs->nxpix - 1.0);
distort:wcs.c:	(void) pix2wcs (wcs,xpix,wcs->nypix,&xpos2,&ypos2);
distort:wcs.c:	if (wcs->syswcs == WCS_LINEAR) {
distort:wcs.c:	    (void)fprintf (stderr, " height = %.5f %s ",height, wcs->units[1]);
distort:wcs.c:	    (void)fprintf (stderr, " height = %.3f %s ",height, wcs->units[1]);
distort:wcs.c:	secpixh = height / (wcs->nypix - 1.0);
distort:wcs.c:	if (wcs->syswcs == WCS_LINEAR) {
distort:wcs.c:			    wcs->xinc,wcs->units[0],wcs->yinc,wcs->units[1]);
distort:wcs.c:	    if (wcs->xinc != 0.0 && wcs->yinc != 0.0)
distort:wcs.c:		secpix = (fabs(wcs->xinc) + fabs(wcs->yinc)) * 0.5 * 3600.0;
distort:wcs.c:	    else if (wcs->xinc != 0.0 || wcs->yinc != 0.0)
distort:wcs.c:		secpix = (fabs(wcs->xinc) + fabs(wcs->yinc)) * 3600.0;
distort:wcs.c:	xcpix = (0.5 * wcs->nxpix) + 0.5;
distort:wcs.c:	ycpix = (0.5 * wcs->nypix) + 0.5;
distort:wcs.c:	xpix = wcs->nxpix + 0.499999;
distort:wcs.c:	if (strncmp (wcs->ptype,"LINEAR",6) &&
distort:wcs.c:	    strncmp (wcs->ptype,"PIXEL",5)) {
distort:wcs.c:	ypix = wcs->nypix + 0.5;
distort:wcs.c:	if (strncmp (wcs->ptype,"LINEAR",6) &&
distort:wcs.c:	    strncmp (wcs->ptype,"PIXEL",5))
distort:wcs.c:	(void) pix2wcs (wcs,1.0,wcs->nypix,&xpos2,&ypos2);
distort:wcs.c:	(void) pix2wcs (wcs,wcs->nxpix,1.0,&xpos3,&ypos3);
distort:wcs.c:	(void) pix2wcs (wcs,wcs->nxpix,wcs->nypix,&xpos4,&ypos4);
distort:wcs.c:	if (wcs->syswcs != WCS_LINEAR && wcs->syswcs != WCS_XY) {
distort:wcs.c:	    if (wcs->command_format[i] != NULL)
distort:wcs.c:		free (wcs->command_format[i]);
distort:wcs.c:	    wcs->command_format[i] = (char *) calloc (lcom+2, 1);
distort:wcs.c:	    if (wcs->command_format[i] == NULL)
distort:wcs.c:		    wcs->command_format[i][icom] = ' ';
distort:wcs.c:		    wcs->command_format[i][icom] = command[icom];
distort:wcs.c:	    wcs->command_format[i][lcom] = 0;
distort:wcs.c:    if (wcs->command_format[i] != NULL)
distort:wcs.c:	strcpy (comform, wcs->command_format[i]);
distort:wcs.c:	sysout = wcs->syswcs;
distort:wcs.c:	strcpy (wcs->radecout, wcs->radecsys);
distort:wcs.c:	wcs->eqout = wcs->equinox;
distort:wcs.c:	    if (wcs->eqout != 1950.0) {
distort:wcs.c:		wcs->radecout[0] = 'B';
distort:wcs.c:		sprintf (wcs->radecout+1,"%.4f", wcs->equinox);
distort:wcs.c:		i = strlen(wcs->radecout) - 1;
distort:wcs.c:		if (wcs->radecout[i] == '0')
distort:wcs.c:		    wcs->radecout[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecout) - 1;
distort:wcs.c:		if (wcs->radecout[i] == '0')
distort:wcs.c:		    wcs->radecout[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecout) - 1;
distort:wcs.c:		if (wcs->radecout[i] == '0')
distort:wcs.c:		    wcs->radecout[i] = (char)0;
distort:wcs.c:		strcpy (wcs->radecout, "B1950");
distort:wcs.c:	    if (wcs->eqout != 2000.0) {
distort:wcs.c:		wcs->radecout[0] = 'J';
distort:wcs.c:		sprintf (wcs->radecout+1,"%.4f", wcs->equinox);
distort:wcs.c:		i = strlen(wcs->radecout) - 1;
distort:wcs.c:		if (wcs->radecout[i] == '0')
distort:wcs.c:		    wcs->radecout[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecout) - 1;
distort:wcs.c:		if (wcs->radecout[i] == '0')
distort:wcs.c:		    wcs->radecout[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecout) - 1;
distort:wcs.c:		if (wcs->radecout[i] == '0')
distort:wcs.c:		    wcs->radecout[i] = (char)0;
distort:wcs.c:		strcpy (wcs->radecout, "J2000");
distort:wcs.c:	if (sysout != wcs->syswcs &&
distort:wcs.c:	    (wcs->syswcs == WCS_LINEAR || wcs->syswcs == WCS_ALTAZ))
distort:wcs.c:	strcpy (wcs->radecout, coorsys);
distort:wcs.c:	wcs->eqout = wcsceq (coorsys);
distort:wcs.c:    wcs->sysout = sysout;
distort:wcs.c:    if (wcs->wcson) {
distort:wcs.c:	if (wcs->sysout == WCS_GALACTIC || wcs->sysout == WCS_ECLIPTIC ||
distort:wcs.c:	    wcs->sysout == WCS_PLANET) {
distort:wcs.c:	    wcs->degout = 1;
distort:wcs.c:	    wcs->ndec = 5;
distort:wcs.c:	else if (wcs->sysout == WCS_ALTAZ) {
distort:wcs.c:	    wcs->degout = 1;
distort:wcs.c:	    wcs->ndec = 5;
distort:wcs.c:	else if (wcs->sysout == WCS_NPOLE || wcs->sysout == WCS_SPA) {
distort:wcs.c:	    wcs->degout = 1;
distort:wcs.c:	    wcs->ndec = 5;
distort:wcs.c:	    wcs->degout = 0;
distort:wcs.c:	    wcs->ndec = 3;
distort:wcs.c:	return(wcs->radecout);
distort:wcs.c:	wcs->sysin = wcs->syswcs;
distort:wcs.c:	strcpy (wcs->radecin, wcs->radecsys);
distort:wcs.c:	wcs->eqin = wcs->equinox;
distort:wcs.c:	if (wcs->sysin == WCS_B1950) {
distort:wcs.c:	    if (wcs->eqin != 1950.0) {
distort:wcs.c:		wcs->radecin[0] = 'B';
distort:wcs.c:		sprintf (wcs->radecin+1,"%.4f", wcs->equinox);
distort:wcs.c:		i = strlen(wcs->radecin) - 1;
distort:wcs.c:		if (wcs->radecin[i] == '0')
distort:wcs.c:		    wcs->radecin[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecin) - 1;
distort:wcs.c:		if (wcs->radecin[i] == '0')
distort:wcs.c:		    wcs->radecin[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecin) - 1;
distort:wcs.c:		if (wcs->radecin[i] == '0')
distort:wcs.c:		    wcs->radecin[i] = (char)0;
distort:wcs.c:		strcpy (wcs->radecin, "B1950");
distort:wcs.c:	else if (wcs->sysin == WCS_J2000) {
distort:wcs.c:	    if (wcs->eqin != 2000.0) {
distort:wcs.c:		wcs->radecin[0] = 'J';
distort:wcs.c:		sprintf (wcs->radecin+1,"%.4f", wcs->equinox);
distort:wcs.c:		i = strlen(wcs->radecin) - 1;
distort:wcs.c:		if (wcs->radecin[i] == '0')
distort:wcs.c:		    wcs->radecin[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecin) - 1;
distort:wcs.c:		if (wcs->radecin[i] == '0')
distort:wcs.c:		    wcs->radecin[i] = (char)0;
distort:wcs.c:		i = strlen(wcs->radecin) - 1;
distort:wcs.c:		if (wcs->radecin[i] == '0')
distort:wcs.c:		    wcs->radecin[i] = (char)0;
distort:wcs.c:		strcpy (wcs->radecin, "J2000");
distort:wcs.c:    wcs->sysin = sysin;
distort:wcs.c:    wcs->eqin = wcsceq (coorsys);
distort:wcs.c:    strcpy (wcs->radecin, coorsys);
distort:wcs.c:	return (wcs->radecin);
distort:wcs.c:    old = wcs->degout;
distort:wcs.c:    wcs->degout = new;
distort:wcs.c:    if (new == 1 && old == 0 && wcs->ndec == 3)
distort:wcs.c:	wcs->ndec = 6;
distort:wcs.c:    if (new == 0 && old == 1 && wcs->ndec == 5)
distort:wcs.c:	wcs->ndec = 3;
distort:wcs.c:	wcs->ndec = ndec;
distort:wcs.c:    return (wcs->ndec);
distort:wcs.c:	return (wcs->radecsys);
distort:wcs.c:	wcs->linmode = mode;
distort:wcs.c:	if (wcs->offscl) {
distort:wcs.c:	else if (wcs->degout == 1) {
distort:wcs.c:	    minlength = 9 + (2 * wcs->ndec);
distort:wcs.c:		deg2str (rastr, 32, xpos, wcs->ndec);
distort:wcs.c:		deg2str (decstr, 32, ypos, wcs->ndec);
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	else if (wcs->degout == 0) {
distort:wcs.c:	    minlength = 18 + (2 * wcs->ndec);
distort:wcs.c:		if (wcs->sysout == WCS_J2000 || wcs->sysout == WCS_B1950) {
distort:wcs.c:		    ra2str (rastr, 32, xpos, wcs->ndec);
distort:wcs.c:		    dec2str (decstr, 32, ypos, wcs->ndec-1);
distort:wcs.c:		    dec2str (rastr, 32, xpos, wcs->ndec);
distort:wcs.c:		    dec2str (decstr, 32, ypos, wcs->ndec);
distort:wcs.c:		if (wcs->tabsys) {
distort:wcs.c:		if (wcs->tabsys) {
distort:wcs.c:	if (wcs->sysout == WCS_GALACTIC) {
distort:wcs.c:	    if (lstr > 9 && wcs->printsys) {
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	else if (wcs->sysout == WCS_ECLIPTIC) {
distort:wcs.c:	    if (lstr > 9 && wcs->printsys) {
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	else if (wcs->sysout == WCS_PLANET) {
distort:wcs.c:	    if (lstr > 9 && wcs->printsys) {
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	else if (wcs->sysout == WCS_ALTAZ) {
distort:wcs.c:	    if (lstr > 7 && wcs->printsys) {
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	else if (wcs->sysout == WCS_NPOLE) {
distort:wcs.c:	    if (lstr > 7 && wcs->printsys) {
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	else if (wcs->sysout == WCS_SPA) {
distort:wcs.c:	    if (lstr > 7 && wcs->printsys) {
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	else if (wcs->sysout==WCS_B1950 || wcs->sysout==WCS_J2000) {
distort:wcs.c:	    if (lstr > (int) strlen(wcs->radecout)+1 && wcs->printsys) {
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:		strcat (wcstring, wcs->radecout);
distort:wcs.c:	    num2str (rastr, xpos, 0, wcs->ndec);
distort:wcs.c:	    num2str (decstr, ypos, 0, wcs->ndec);
distort:wcs.c:	    lunits = strlen (wcs->units[0]) + strlen (wcs->units[1]) + 2;
distort:wcs.c:	    if (wcs->syswcs == WCS_LINEAR && wcs->linmode == 1) {
distort:wcs.c:		    if (strlen (wcs->units[0]) > 0) {
distort:wcs.c:			strcat (rastr, wcs->units[0]);
distort:wcs.c:		    if (strlen (wcs->units[1]) > 0) {
distort:wcs.c:			strcat (decstr, wcs->units[1]);
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:		if (wcs->tabsys)
distort:wcs.c:	    if (wcs->syswcs == WCS_LINEAR && wcs->linmode != 1 &&
distort:wcs.c:	    if (wcs->syswcs == WCS_LINEAR && wcs->linmode == 2 &&
distort:wcs.c:		if (strlen (wcs->units[0]) > 0) {
distort:wcs.c:		    strcat (wcstring, wcs->units[0]);
distort:wcs.c:		if (strlen (wcs->units[1]) > 0) {
distort:wcs.c:		    strcat (wcstring, wcs->units[1]);
distort:wcs.c:    wcs->xpix = xpix;
distort:wcs.c:    wcs->ypix = ypix;
distort:wcs.c:    wcs->zpix = zpix;
distort:wcs.c:    wcs->offscl = 0;
distort:wcs.c:    if (wcs->wcs != NULL) {
distort:wcs.c:	pix2wcs (wcs->wcs, xpix, ypix, &xpi, &ypi);
distort:wcs.c:    if (wcs->prjcode == WCS_DSS) {
distort:wcs.c:	    wcs->offscl = 1;
distort:wcs.c:    else if (wcs->prjcode == WCS_PLT) {
distort:wcs.c:	    wcs->offscl = 1;
distort:wcs.c:    else if (wcs->prjcode == WCS_TNX) {
distort:wcs.c:	    wcs->offscl = 1;
distort:wcs.c:    else if (wcs->prjcode == WCS_ZPX) {
distort:wcs.c:	    wcs->offscl = 1;
distort:wcs.c:    else if (wcs->wcsproj == WCS_OLD || wcs->prjcode <= 0) {
distort:wcs.c:	    wcs->offscl = 1;
distort:wcs.c:	wcs->offscl = 1;
distort:wcs.c:    if (wcs->offscl) {
distort:wcs.c:        if (wcs->prjcode > 0) {
distort:wcs.c:	    eqin = wcs->equinox;
distort:wcs.c:	    eqout = wcs->eqout;
distort:wcs.c:	    wcscon (wcs->syswcs,wcs->sysout,eqin,eqout,&xp,&yp,wcs->epoch);
distort:wcs.c:	if (wcs->latbase == 90)
distort:wcs.c:	else if (wcs->latbase == -90)
distort:wcs.c:	wcs->xpos = xp;
distort:wcs.c:	wcs->ypos = yp;
distort:wcs.c:    if (wcs->sysout > 0 && wcs->sysout != 6 && wcs->sysout != 10) {
distort:wcs.c:    wcsc2pix (wcs, xpos, ypos, wcs->radecin, xpix, ypix, offscl);
distort:wcs.c:    if (wcs->latbase == 90)
distort:wcs.c:    else if (wcs->latbase == -90)
distort:wcs.c:	sysin = wcs->syswcs;
distort:wcs.c:	eqin = wcs->equinox;
distort:wcs.c:    wcs->zpix = 1.0;
distort:wcs.c:	eqout = wcs->equinox;
distort:wcs.c:	wcscon (sysin, wcs->syswcs, eqin, eqout, &xp, &yp, wcs->epoch);
distort:wcs.c:    if (wcs->prjcode == WCS_DSS) {
distort:wcs.c:    else if (wcs->prjcode == WCS_PLT) {
distort:wcs.c:    else if (wcs->prjcode == WCS_TNX) {
distort:wcs.c:    else if (wcs->prjcode == WCS_ZPX) {
distort:wcs.c:    else if (wcs->wcsproj == WCS_OLD || wcs->prjcode <= 0) {
distort:wcs.c:    if (wcs->wcs != NULL) {
distort:wcs.c:	wcsc2pix (wcs->wcs, xpi, ypi, NULL, xpix, ypix, offscl);
distort:wcs.c:	    else if (*xpix > wcs->nxpix + 0.5 || *ypix > wcs->nypix + 0.5)
distort:wcs.c:    wcs->offscl = *offscl;
distort:wcs.c:    wcs->xpos = xpos;
distort:wcs.c:    wcs->ypos = ypos;
distort:wcs.c:    wcs->xpix = *xpix;
distort:wcs.c:    wcs->ypix = *ypix;
distort:wcs.c:    if (wcs->prjcode == WCS_CSC || wcs->prjcode == WCS_QSC ||
distort:wcs.c:	wcs->prjcode == WCS_TSC)
distort:wcs.c:    offscl = wcsrev ((void *)&wcs->ctype, &wcs->wcsl, pixcrd, &wcs->lin, imgcrd,
distort:wcs.c:		    &wcs->prj, &phi, &theta, wcs->crval, &wcs->cel, wcscrd);
distort:wcs.c:	*xpos = wcscrd[wcs->wcsl.lng];
distort:wcs.c:	*ypos = wcscrd[wcs->wcsl.lat];
distort:wcs.c:    if (wcs->wcsl.flag != WCSSET) {
distort:wcs.c:	if (wcsset (wcs->lin.naxis, (void *)&wcs->ctype, &wcs->wcsl) )
distort:wcs.c:    wcscrd[wcs->wcsl.lng] = xpos;
distort:wcs.c:    wcscrd[wcs->wcsl.lat] = ypos;
distort:wcs.c:    offscl = wcsfwd ((void *)&wcs->ctype, &wcs->wcsl, wcscrd, wcs->crval, &wcs->cel,
distort:wcs.c:		     &phi, &theta, &wcs->prj, imgcrd, &wcs->lin, pixcrd);
distort:wcs.c:	if (wcs->prjcode == WCS_CSC || wcs->prjcode == WCS_QSC ||
distort:wcs.c:	    wcs->prjcode == WCS_TSC)
distort:wcs.c:	    wcs->zpix = pixcrd[2] - 1.0;
distort:wcs.c:	    wcs->zpix = pixcrd[2];
distort:wcs.c:    return ((int) wcs->zpix);
distort:wcs.c:	    wcs->command_format[i] = NULL;
distort:wcs.c:	    if (wcs->command_format[i] != NULL) {
distort:wcs.c:		free (wcs->command_format[i]);
distort:wcs.c: * Nov  5 1996	Set wcs->crot to 1 if rotation matrix is used
distort:wcs.c: * Jul 30 1998	Set wcs->naxes and lin.naxis in wcsxinit() and wcskinit()
distort:wcs.c: * Feb 24 2000	If coorsys is null in wcsc2pix, wcs->radecin is assumed
distort:wcs.c: * Oct  1 2003	Rename wcs->naxes to wcs->naxis to match WCSLIB 3.2
distort:wcs.c: * Dec  3 2003	Add back wcs->naxes for compatibility
distort:wcs.c: * Nov  1 2004	Keep wcs->rot between 0 and 360
distort:wcs.h:/* Projections (1-26 are WCSLIB) (values for wcs->prjcode) */
distort:wcs.h:/* Distortion codes (values for wcs->distcode) */
distort:wcs.h: * Feb 20 2001	Add wcs->wcs to main data structure
distort:wcs.h: * Apr  9 2002	Add wcs->wcsdep for pointer to WCS depending on this WCS
distort:wcs.h: * Apr 26 2002	Add wcs->wcsname and wcs->wcschar to identify WCS structure
distort:wcs.h: * May  9 2002	Add wcs->radvel and wcs->zvel for radial velocity in km/sec
distort:wcs.h: * Apr  1 2003	Add wcs->distort Distort structure for distortion correction
distort:wcs.h: * Oct  1 2003	Rename wcs->naxes to wcs->naxis to match WCSLIB 3.2
distort:wcs.h: * Dec  3 2003	Add back wcs->naxes for backward compatibility
distort:wcsinit.c:    wcs->wcschar = mchar;
distort:wcsinit.c:	wcs->wcsname = (char *) calloc (strlen (wcsname)+2, 1);
distort:wcsinit.c:	strcpy (wcs->wcsname, wcsname);
distort:wcsinit.c:    wcs->cel.flag = 0;
distort:wcsinit.c:    wcs->lin.flag = 0;
distort:wcsinit.c:    wcs->wcsl.flag = 0;
distort:wcsinit.c:    wcs->wcsl.cubeface = -1;
distort:wcsinit.c:    wcs->ncoeff1 = 0;
distort:wcsinit.c:    wcs->ncoeff2 = 0;
distort:wcsinit.c:    wcs->rotmat = 0;
distort:wcsinit.c:    wcs->rot = 0.0;
distort:wcsinit.c:    wcs->naxis = naxes;
distort:wcsinit.c:    wcs->naxes = naxes;
distort:wcsinit.c:    wcs->lin.naxis = naxes;
distort:wcsinit.c:    wcs->nxpix = 0;
distort:wcsinit.c:    hgetr8 (hstring, "NAXIS1", &wcs->nxpix);
distort:wcsinit.c:    if (wcs->nxpix < 1)
distort:wcsinit.c:	hgetr8 (hstring, "IMAGEW", &wcs->nxpix);
distort:wcsinit.c:    if (wcs->nxpix < 1) {
distort:wcsinit.c:    wcs->nypix = 0;
distort:wcsinit.c:    hgetr8 (hstring, "NAXIS2", &wcs->nypix);
distort:wcsinit.c:    if (wcs->nypix < 1)
distort:wcsinit.c:	hgetr8 (hstring, "IMAGEH", &wcs->nypix);
distort:wcsinit.c:    if (naxes > 1 && wcs->nypix < 1) {
distort:wcsinit.c:	    if (i == 0 && wcs->nxpix > 1) {
distort:wcsinit.c:			 keyword, wcs->nxpix); */
distort:wcsinit.c:		j = wcs->nxpix;
distort:wcsinit.c:	    else if (i == 1 && wcs->nypix > 1) {
distort:wcsinit.c:			 keyword, wcs->nypix); */
distort:wcsinit.c:		j = wcs->nypix;
distort:wcsinit.c:    wcs->naxes = nax;
distort:wcsinit.c:    wcs->naxis = nax;
distort:wcsinit.c:    hgets (hstring, "INSTRUME", 16, wcs->instrument);
distort:wcsinit.c:    hgeti4 (hstring, "DETECTOR", &wcs->detector);
distort:wcsinit.c:    wcs->wcsproj = getdefwcs();
distort:wcsinit.c:    wcs->logwcs = 0;
distort:wcsinit.c:    hgeti4 (hstring, "DC-FLAG", &wcs->logwcs);
distort:wcsinit.c:    for (i = 0; i < 81; i++) wcs->pc[i] = 0.0;
distort:wcsinit.c:    for (i = 0; i < naxes; i++) wcs->pc[(i*naxes)+i] = 1.0;
distort:wcsinit.c:    for (i = 0; i < 9; i++) wcs->cdelt[i] = 0.0;
distort:wcsinit.c:    for (i = 0; i < naxes; i++) wcs->cdelt[i] = 1.0;
distort:wcsinit.c:	if ((wcs->wcs = wcsinitn (hstring, wcsname)) == NULL) {
distort:wcsinit.c:	depwcs = wcs->wcs;
distort:wcsinit.c:	depwcs->wcsdep = wcs;
distort:wcsinit.c:	wcs->wcs = NULL;
distort:wcsinit.c:    wcs->radvel = 0.0;
distort:wcsinit.c:    wcs->zvel = 0.0;
distort:wcsinit.c:    if (hgetr8c (hstring, "VSOURCE", &mchar, &wcs->radvel))
distort:wcsinit.c:	wcs->zvel = wcs->radvel / cvel;
distort:wcsinit.c:    else if (hgetr8c (hstring, "ZSOURCE", &mchar, &wcs->zvel))
distort:wcsinit.c:	wcs->radvel = wcs->zvel * cvel;
distort:wcsinit.c:    else if (hgetr8 (hstring, "VELOCITY", &wcs->radvel))
distort:wcsinit.c:	wcs->zvel = wcs->radvel / cvel;
distort:wcsinit.c:	wcs->prj.p[i] = 0.0;
distort:wcsinit.c:	strcpy (wcs->ctype[0], ctype1);
distort:wcsinit.c:	strcpy (wcs->ctype[1], ctype2);
distort:wcsinit.c:	strcpy (wcs->ctype[2], "");
distort:wcsinit.c:	hgetsc (hstring, "CTYPE3", &mchar, 9, wcs->ctype[2]);
distort:wcsinit.c:	strcpy (wcs->ctype[3], "");
distort:wcsinit.c:	hgetsc (hstring, "CTYPE4", &mchar, 9, wcs->ctype[3]);
distort:wcsinit.c:	if (wcs->prjcode == WCS_LIN) {
distort:wcsinit.c:	    if (!hgetsc (hstring, "CUNIT1", &mchar, 16, wcs->units[0])) {
distort:wcsinit.c:		if (!mgetstr (hstring, "WAT1", "units", 16, wcs->units[0])) {
distort:wcsinit.c:		    wcs->units[0][0] = 0;
distort:wcsinit.c:	    if (!strcmp (wcs->units[0], "pixel"))
distort:wcsinit.c:		wcs->prjcode = WCS_PIX;
distort:wcsinit.c:		if (!hgetsc (hstring, "CUNIT2", &mchar, 16, wcs->units[1])) {
distort:wcsinit.c:		    if (!mgetstr (hstring, "WAT2", "units", 16, wcs->units[1])) {
distort:wcsinit.c:			wcs->units[1][0] = 0;
distort:wcsinit.c:		if (!strcmp (wcs->units[0], "pixel"))
distort:wcsinit.c:		    wcs->prjcode = WCS_PIX;
distort:wcsinit.c:	wcs->crpix[0] = 1.0;
distort:wcsinit.c:	hgetr8c (hstring, "CRPIX1", &mchar, &wcs->crpix[0]);
distort:wcsinit.c:	wcs->crpix[1] = 1.0;
distort:wcsinit.c:	hgetr8c (hstring, "CRPIX2", &mchar, &wcs->crpix[1]);
distort:wcsinit.c:	wcs->xrefpix = wcs->crpix[0];
distort:wcsinit.c:	wcs->yrefpix = wcs->crpix[1];
distort:wcsinit.c:	wcs->crval[0] = 0.0;
distort:wcsinit.c:	hgetr8c (hstring, "CRVAL1", &mchar, &wcs->crval[0]);
distort:wcsinit.c:	wcs->crval[1] = 0.0;
distort:wcsinit.c:	hgetr8c (hstring, "CRVAL2", &mchar, &wcs->crval[1]);
distort:wcsinit.c:	if (wcs->syswcs == WCS_NPOLE)
distort:wcsinit.c:	    wcs->crval[1] = 90.0 - wcs->crval[1];
distort:wcsinit.c:	if (wcs->syswcs == WCS_SPA)
distort:wcsinit.c:	    wcs->crval[1] = wcs->crval[1] - 90.0;
distort:wcsinit.c:	wcs->xref = wcs->crval[0];
distort:wcsinit.c:	wcs->yref = wcs->crval[1];
distort:wcsinit.c:	if (wcs->coorflip) {
distort:wcsinit.c:	    wcs->cel.ref[0] = wcs->crval[1];
distort:wcsinit.c:	    wcs->cel.ref[1] = wcs->crval[0];
distort:wcsinit.c:	    wcs->cel.ref[0] = wcs->crval[0];
distort:wcsinit.c:	    wcs->cel.ref[1] = wcs->crval[1];
distort:wcsinit.c:	wcs->longpole = 999.0;
distort:wcsinit.c:	hgetr8c (hstring, "LONPOLE", &mchar, &wcs->longpole);
distort:wcsinit.c:	wcs->cel.ref[2] = wcs->longpole;
distort:wcsinit.c:	wcs->latpole = 999.0;
distort:wcsinit.c:	hgetr8c (hstring, "LATPOLE", &mchar, &wcs->latpole);
distort:wcsinit.c:	wcs->cel.ref[3] = wcs->latpole;
distort:wcsinit.c:	wcs->lin.crpix = wcs->crpix;
distort:wcsinit.c:	wcs->lin.cdelt = wcs->cdelt;
distort:wcsinit.c:	wcs->lin.pc = wcs->pc;
distort:wcsinit.c:	wcs->prj.r0 = 0.0;
distort:wcsinit.c:	hgetr8c (hstring, "PROJR0", &mchar, &wcs->prj.r0);
distort:wcsinit.c:	    hgetr8c (hstring, keyword, &mchar, &wcs->prj.p[i]);
distort:wcsinit.c:	if (wcs->prjcode == WCS_AZP || wcs->prjcode == WCS_SIN ||
distort:wcsinit.c:	    wcs->prjcode == WCS_COP || wcs->prjcode == WCS_COE ||
distort:wcsinit.c:	    wcs->prjcode == WCS_COD || wcs->prjcode == WCS_COO) {
distort:wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:wcsinit.c:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
distort:wcsinit.c:	else if (wcs->prjcode == WCS_SZP) {
distort:wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:wcsinit.c:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
distort:wcsinit.c:	    if (wcs->prj.p[3] == 0.0)
distort:wcsinit.c:		wcs->prj.p[3] = 90.0;
distort:wcsinit.c:	    hgetr8c (hstring, pvkey3, &mchar, &wcs->prj.p[3]);
distort:wcsinit.c:	else if (wcs->prjcode == WCS_CEA) {
distort:wcsinit.c:	    if (wcs->prj.p[1] == 0.0)
distort:wcsinit.c:		wcs->prj.p[1] = 1.0;
distort:wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:wcsinit.c:	else if (wcs->prjcode == WCS_CYP) {
distort:wcsinit.c:	    if (wcs->prj.p[1] == 0.0)
distort:wcsinit.c:		wcs->prj.p[1] = 1.0;
distort:wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:wcsinit.c:	    if (wcs->prj.p[2] == 0.0)
distort:wcsinit.c:		wcs->prj.p[2] = 1.0;
distort:wcsinit.c:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
distort:wcsinit.c:	else if (wcs->prjcode == WCS_AIR) {
distort:wcsinit.c:	    if (wcs->prj.p[1] == 0.0)
distort:wcsinit.c:		wcs->prj.p[1] = 90.0;
distort:wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:wcsinit.c:	else if (wcs->prjcode == WCS_BON) {
distort:wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
distort:wcsinit.c:	else if (wcs->prjcode == WCS_ZPN) {
distort:wcsinit.c:		hgetr8c (hstring, keyword, &mchar, &wcs->prj.p[i]);
distort:wcsinit.c:	if (wcs->prjcode == WCS_TNX) {
distort:wcsinit.c:		wcs->ctype[0][6] = 'A';
distort:wcsinit.c:		wcs->ctype[0][7] = 'N';
distort:wcsinit.c:		wcs->ctype[1][6] = 'A';
distort:wcsinit.c:		wcs->ctype[1][7] = 'N';
distort:wcsinit.c:		wcs->prjcode = WCS_TAN;
distort:wcsinit.c:	if (wcs->prjcode == WCS_ZPX) {
distort:wcsinit.c:		wcs->ctype[0][7] = 'N';
distort:wcsinit.c:		wcs->ctype[1][7] = 'N';
distort:wcsinit.c:		wcs->prjcode = WCS_ZPN;
distort:wcsinit.c:	if (wcs->prjcode == WCS_TPV) {
distort:wcsinit.c:	    wcs->ctype[0][6] = 'A';
distort:wcsinit.c:	    wcs->ctype[0][7] = 'N';
distort:wcsinit.c:	    wcs->ctype[1][6] = 'A';
distort:wcsinit.c:	    wcs->ctype[1][7] = 'N';
distort:wcsinit.c:	    wcs->prjcode = WCS_TAN;
distort:wcsinit.c:	if (wcs->wcsproj > 0)
distort:wcsinit.c:	wcs->ncoeff1 = 0;
distort:wcsinit.c:	wcs->ncoeff2 = 0;
distort:wcsinit.c:	if (wcs->wcsproj != WCS_OLD &&
distort:wcsinit.c:	    wcs->prjcode = WCS_PLT;
distort:wcsinit.c:	    (void)strcpy (wcs->ptype, "PLATE");
distort:wcsinit.c:		wcs->x_coeff[i] = 0.0;
distort:wcsinit.c:		if (hgetr8 (hcoeff, keyword, &wcs->x_coeff[i]))
distort:wcsinit.c:		    wcs->ncoeff1 = i + 1;
distort:wcsinit.c:		wcs->y_coeff[i] = 0.0;
distort:wcsinit.c:		if (hgetr8 (hcoeff, keyword, &wcs->y_coeff[i]))
distort:wcsinit.c:		    wcs->ncoeff2 = i + 1;
distort:wcsinit.c:	    platepos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
distort:wcsinit.c:	    platepos (wcs->crpix[0], wcs->crpix[1]+1.0, wcs, &ra1, &dec1);
distort:wcsinit.c:	    wcs->yinc = dec1 - dec0;
distort:wcsinit.c:	    wcs->xinc = -wcs->yinc;
distort:wcsinit.c:	    wcs->wcson = 1;
distort:wcsinit.c:	    rot = degrad (wcs->rot);
distort:wcsinit.c:	    platepos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
distort:wcsinit.c:	    platepos (wcs->crpix[0]+cos(rot),
distort:wcsinit.c:		      wcs->crpix[1]+sin(rot), wcs, &ra1, &dec1);
distort:wcsinit.c:	    wcs->cdelt[0] = -wcsdist (ra0, dec0, ra1, dec1);
distort:wcsinit.c:	    wcs->xinc = wcs->cdelt[0];
distort:wcsinit.c:	    platepos (wcs->crpix[0]+sin(rot),
distort:wcsinit.c:		      wcs->crpix[1]+cos(rot), wcs, &ra1, &dec1);
distort:wcsinit.c:	    wcs->cdelt[1] = wcsdist (ra0, dec0, ra1, dec1);
distort:wcsinit.c:	    wcs->yinc = wcs->cdelt[1];
distort:wcsinit.c:	    wcs->cd[0] = cd[0];
distort:wcsinit.c:	    wcs->cd[1] = cd[1];
distort:wcsinit.c:	    wcs->cd[2] = cd[2];
distort:wcsinit.c:	    wcs->cd[3] = cd[3];
distort:wcsinit.c:	    (void) matinv (2, wcs->cd, wcs->dc);
distort:wcsinit.c:	    wcs->rotmat = 1;
distort:wcsinit.c:	    if (cdelt1 == 0.0 || (wcs->nypix > 1 && cdelt2 == 0.0)) {
distort:wcsinit.c:	    if (cdelt2 == 0.0 && wcs->nypix > 1)
distort:wcsinit.c:	    wcs->cdelt[2] = 1.0;
distort:wcsinit.c:	    wcs->cdelt[3] = 1.0;
distort:wcsinit.c:		wcs->pc[i] = 0.0;
distort:wcsinit.c:	    wcs->xinc = 1.0;
distort:wcsinit.c:	    wcs->yinc = 1.0;
distort:wcsinit.c:	    wcs->cdelt[0] = 1.0;
distort:wcsinit.c:	    wcs->cdelt[1] = 1.0;
distort:wcsinit.c:	    wcs->rot = 0.0;
distort:wcsinit.c:	    wcs->rotmat = 0;
distort:wcsinit.c:	if (wcs->prjcode == WCS_TAN && wcs->naxis == 2) { 
distort:wcsinit.c:	    if (wcs->inv_x) {
distort:wcsinit.c:		poly_end(wcs->inv_x);
distort:wcsinit.c:		wcs->inv_x = NULL;
distort:wcsinit.c:	    if (wcs->inv_y) {
distort:wcsinit.c:		poly_end(wcs->inv_y);
distort:wcsinit.c:		wcs->inv_y = NULL;
distort:wcsinit.c:	    wcs->pvfail = 0;
distort:wcsinit.c:		wcs->projppv[i] = 0.0;
distort:wcsinit.c:		wcs->prj.ppv[i] = 0.0;
distort:wcsinit.c:		    if (hgetr8c(hstring, keyword,&mchar, &wcs->projppv[j+k*MAXPV]) == 0) {
distort:wcsinit.c:			wcs->projppv[j+k*MAXPV] = 0.0;
distort:wcsinit.c:		    wcs->prj.ppv[k] = wcs->projppv[k+wcs->wcsl.lat*MAXPV];
distort:wcsinit.c:		    wcs->prj.ppv[k+MAXPV] = wcs->projppv[k+wcs->wcsl.lng*MAXPV];
distort:wcsinit.c:		    if (!n && (wcs->prj.ppv[k] || wcs->prj.ppv[k+MAXPV]))  {
distort:wcsinit.c:		wcs->cel.flag = 0;
distort:wcsinit.c:	if (!strncmp (wcs->ptype,"LINEAR",6) ||
distort:wcsinit.c:	    !strncmp (wcs->ptype,"PIXEL",5)) {
distort:wcsinit.c:	    wcs->degout = -1;
distort:wcsinit.c:	    wcs->ndec = 5;
distort:wcsinit.c:	    wcs->epoch = 1900.0 + (mjd - 15019.81352) / 365.242198781;
distort:wcsinit.c:	else if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
distort:wcsinit.c:	    if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
distort:wcsinit.c:		if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
distort:wcsinit.c:		    wcs->epoch = wcs->equinox;
distort:wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:wcsinit.c:	wcs->wcson = 1;
distort:wcsinit.c:	wcs->prjcode = WCS_DSS;
distort:wcsinit.c:	wcs->plate_ra = hrrad (ra_hours);
distort:wcsinit.c:	wcs->plate_dec = degrad (dec_deg);
distort:wcsinit.c:	hgetr8 (hstring,"EQUINOX",&wcs->equinox);
distort:wcsinit.c:	    strcpy (wcs->radecsys,"FK4");
distort:wcsinit.c:	    strcpy (wcs->radecsys,"FK5");
distort:wcsinit.c:	wcs->epoch = wcs->equinox;
distort:wcsinit.c:	hgetr8 (hstring,"EPOCH",&wcs->epoch);
distort:wcsinit.c:	(void)sprintf (wcs->center,"%2.0f:%2.0f:%5.3f %c%2.0f:%2.0f:%5.3f %s",
distort:wcsinit.c:		       rah,ram,ras,decsign,decd,decm,decs,wcs->radecsys);
distort:wcsinit.c:	hgetr8 (hstring,"PLTSCALE",&wcs->plate_scale);
distort:wcsinit.c:	hgetr8 (hstring,"XPIXELSZ",&wcs->x_pixel_size);
distort:wcsinit.c:	hgetr8 (hstring,"YPIXELSZ",&wcs->y_pixel_size);
distort:wcsinit.c:	hgetr8 (hstring,"CNPIX1",&wcs->x_pixel_offset);
distort:wcsinit.c:	hgetr8 (hstring,"CNPIX2",&wcs->y_pixel_offset);
distort:wcsinit.c:	    wcs->ppo_coeff[i] = 0.0;
distort:wcsinit.c:	    hgetr8 (hcoeff,keyword,&wcs->ppo_coeff[i]);
distort:wcsinit.c:	    wcs->x_coeff[i] = 0.0;
distort:wcsinit.c:	    hgetr8 (hcoeff, keyword, &wcs->x_coeff[i]);
distort:wcsinit.c:	    wcs->y_coeff[i] = 0.0;
distort:wcsinit.c:	    hgetr8 (hcoeff, keyword, &wcs->y_coeff[i]);
distort:wcsinit.c:	wcs->wcson = 1;
distort:wcsinit.c:	(void)strcpy (wcs->c1type, "RA");
distort:wcsinit.c:	(void)strcpy (wcs->c2type, "DEC");
distort:wcsinit.c:	(void)strcpy (wcs->ptype, "DSS");
distort:wcsinit.c:	wcs->degout = 0;
distort:wcsinit.c:	wcs->ndec = 3;
distort:wcsinit.c:	strcpy (wcs->ctype[0], "RA---DSS");
distort:wcsinit.c:	strcpy (wcs->ctype[1], "DEC--DSS");
distort:wcsinit.c:	wcs->crpix[0] = 0.5 * wcs->nxpix;
distort:wcsinit.c:	wcs->crpix[1] = 0.5 * wcs->nypix;
distort:wcsinit.c:	wcs->xrefpix = wcs->crpix[0];
distort:wcsinit.c:	wcs->yrefpix = wcs->crpix[1];
distort:wcsinit.c:	dsspos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
distort:wcsinit.c:	wcs->crval[0] = ra0;
distort:wcsinit.c:	wcs->crval[1] = dec0;
distort:wcsinit.c:	wcs->xref = wcs->crval[0];
distort:wcsinit.c:	wcs->yref = wcs->crval[1];
distort:wcsinit.c:	dsspos (wcs->crpix[0], wcs->crpix[1]+1.0, wcs, &ra1, &dec1);
distort:wcsinit.c:	wcs->yinc = dec1 - dec0;
distort:wcsinit.c:	wcs->xinc = -wcs->yinc;
distort:wcsinit.c:	wcs->wcson = 1;
distort:wcsinit.c:	rot = degrad (wcs->rot);
distort:wcsinit.c:	dsspos (wcs->crpix[0]+cos(rot),
distort:wcsinit.c:		wcs->crpix[1]+sin(rot), wcs, &ra1, &dec1);
distort:wcsinit.c:	wcs->cdelt[0] = -wcsdist (ra0, dec0, ra1, dec1);
distort:wcsinit.c:	dsspos (wcs->crpix[0]+sin(rot),
distort:wcsinit.c:		wcs->crpix[1]+cos(rot), wcs, &ra1, &dec1);
distort:wcsinit.c:	wcs->cdelt[1] = wcsdist (ra0, dec0, ra1, dec1);
distort:wcsinit.c:	wcsdeltset (wcs, wcs->cdelt[0], wcs->cdelt[1], wcs->rot);
distort:wcsinit.c:	if (wcs->rot == 0.)
distort:wcsinit.c:	wcs->crpix[0] = 0.5 + (wcs->nxpix * 0.5);
distort:wcsinit.c:	wcs->crpix[1] = 0.5 + (wcs->nypix * 0.5);
distort:wcsinit.c:	    hgetr8 (hstring,"CRPIX1",&wcs->crpix[0]);
distort:wcsinit.c:	    hgetr8 (hstring,"CRPIX2",&wcs->crpix[1]);
distort:wcsinit.c:	    wcs->crpix[0] = dxrefpix - (double) (ix1 - 1);
distort:wcsinit.c:	    wcs->crpix[1] = dyrefpix - (double) (iy1 - 1);
distort:wcsinit.c:	wcs->xrefpix = wcs->crpix[0];
distort:wcsinit.c:	wcs->yrefpix = wcs->crpix[1];
distort:wcsinit.c:	wcs->crval[0] = -999.0;
distort:wcsinit.c:	if (!hgetra (hstring,"RA",&wcs->crval[0])) {
distort:wcsinit.c:	wcs->crval[1] = -999.0;
distort:wcsinit.c:	if (!hgetdec (hstring,"DEC",&wcs->crval[1])) {
distort:wcsinit.c:	wcs->xref = wcs->crval[0];
distort:wcsinit.c:	wcs->yref = wcs->crval[1];
distort:wcsinit.c:	wcs->coorflip = 0;
distort:wcsinit.c:	wcs->cel.ref[0] = wcs->crval[0];
distort:wcsinit.c:	wcs->cel.ref[1] = wcs->crval[1];
distort:wcsinit.c:	wcs->cel.ref[2] = 999.0;
distort:wcsinit.c:	if (!hgetr8 (hstring,"LONPOLE",&wcs->cel.ref[2]))
distort:wcsinit.c:	    hgetr8 (hstring,"LONGPOLE",&wcs->cel.ref[2]);
distort:wcsinit.c:	wcs->cel.ref[3] = 999.0;
distort:wcsinit.c:	hgetr8 (hstring,"LATPOLE",&wcs->cel.ref[3]);
distort:wcsinit.c:	    wcs->epoch = 1900.0 + (mjd - 15019.81352) / 365.242198781;
distort:wcsinit.c:	else if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
distort:wcsinit.c:	    if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
distort:wcsinit.c:		if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
distort:wcsinit.c:		    wcs->epoch = wcs->equinox;
distort:wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:wcsinit.c:	wcs->coorflip = 0;
distort:wcsinit.c:	wcs->degout = 0;
distort:wcsinit.c:	wcs->ndec = 3;
distort:wcsinit.c:	wcs->wcson = 1;
distort:wcsinit.c:    wcs->lin.crpix = wcs->crpix;
distort:wcsinit.c:    wcs->lin.cdelt = wcs->cdelt;
distort:wcsinit.c:    wcs->lin.pc = wcs->pc;
distort:wcsinit.c:    wcs->printsys = 1;
distort:wcsinit.c:    wcs->tabsys = 0;
distort:wcsinit.c:    wcs->linmode = 0;
distort:wcsinit.c:    lng = wcs->wcsl.lng;
distort:wcsinit.c:    lat = wcs->wcsl.lat;
distort:wcsinit.c:    if (wcs->naxis != NAXISPV) {
distort:wcsinit.c:    if (strcmp(wcs->wcsl.pcode, "TAN") != 0) {
distort:wcsinit.c:    if ((wcs->projppv[1+lng*MAXPV] == 0) &&
distort:wcsinit.c:	(wcs->projppv[1+lat*MAXPV] == 0)) {
distort:wcsinit.c:    if (wcs->wcs != NULL) {
distort:wcsinit.c:	pix2wcs(wcs->wcs,0,0,&xmin,&ymin);
distort:wcsinit.c:	pix2wcs(wcs->wcs,wcs->nxpix,wcs->nypix,&xmax,&ymax);
distort:wcsinit.c:	xmax = wcs->nxpix;
distort:wcsinit.c:	ymax = wcs->nypix;
distort:wcsinit.c:	    if (linrev(raw, &wcs->lin, pixin)) {
distort:wcsinit.c:			 wcs->wcsl.pcode);
distort:wcsinit.c:	    raw_to_pv (&wcs->prj,pixin[lng],pixin[lat], outpost, outpost+1);
distort:wcsinit.c:    linrev(rawmin, &wcs->lin, pixin);
distort:wcsinit.c:    linfwd(pixin, &wcs->lin, raw);
distort:wcsinit.c:		 wcs->wcsl.pcode);
distort:wcsinit.c:	wcs->pvfail = 1;
distort:wcsinit.c:    wcs->prj.inv_x = wcs->inv_x = poly;
distort:wcsinit.c:    linrev(rawmin, &wcs->lin, pixin);
distort:wcsinit.c:    linfwd(pixin, &wcs->lin, raw);
distort:wcsinit.c:		 wcs->wcsl.pcode);
distort:wcsinit.c:	wcs->pvfail = 1;
distort:wcsinit.c:    wcs->prj.inv_y = wcs->inv_y = poly;
distort:wcsinit.c:    if (strlen (wcs->radecsys) == 0 || wcs->prjcode == WCS_LIN)
distort:wcsinit.c:	strcpy (wcs->radecsys, "LINEAR");
distort:wcsinit.c:    if (wcs->prjcode == WCS_PIX)
distort:wcsinit.c:	strcpy (wcs->radecsys, "PIXEL");
distort:wcsinit.c:    wcs->syswcs = wcscsys (wcs->radecsys);
distort:wcsinit.c:    if (wcs->syswcs == WCS_B1950)
distort:wcsinit.c:	strcpy (wcs->radecout, "FK4");
distort:wcsinit.c:    else if (wcs->syswcs == WCS_J2000)
distort:wcsinit.c:	strcpy (wcs->radecout, "FK5");
distort:wcsinit.c:	strcpy (wcs->radecout, wcs->radecsys);
distort:wcsinit.c:    wcs->sysout = wcscsys (wcs->radecout);
distort:wcsinit.c:    wcs->eqout = wcs->equinox;
distort:wcsinit.c:    strcpy (wcs->radecin, wcs->radecsys);
distort:wcsinit.c:    wcs->sysin = wcscsys (wcs->radecin);
distort:wcsinit.c:    wcs->eqin = wcs->equinox;
distort:wcsinit.c:	wcs->equinox = atof (eqstring+1);
distort:wcsinit.c:	wcs->equinox = atof (eqstring+1);
distort:wcsinit.c:	hgetr8 (hstring, eqkey, &wcs->equinox);
distort:wcsinit.c:	    wcs->equinox = 1950.0;
distort:wcsinit.c:            hgetr8 (hstring,"EPOCH",&wcs->equinox);
distort:wcsinit.c:	    wcs->equinox = 1950.0;
distort:wcsinit.c:	    wcs->equinox = 2000.0;
distort:wcsinit.c:	    wcs->equinox = 2000.0;
distort:wcsinit.c:	    wcs->equinox = 2000.0;
distort:wcsinit.c:	    wcs->equinox = 2000.0;
distort:wcsinit.c:	wcs->equinox = 2000.0;
distort:wcsinit.c:	if (!strncmp (wcs->c1type, "RA",2) || !strncmp (wcs->c1type,"DEC",3))
distort:wcsinit.c:    if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
distort:wcsinit.c:	if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
distort:wcsinit.c:	    if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
distort:wcsinit.c:		wcs->epoch = wcs->equinox;
distort:wcsinit.c:		wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:wcsinit.c:		wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
distort:wcsinit.c:    if (wcs->epoch == 0.0)
distort:wcsinit.c:	wcs->epoch = wcs->equinox;
distort:wcsinit.c:	strcpy (wcs->radecsys,systring);
distort:wcsinit.c:	    if (!strncmp (wcs->radecsys,"FK4",3))
distort:wcsinit.c:		wcs->equinox = 1950.0;
distort:wcsinit.c:	    else if (!strncmp (wcs->radecsys,"FK5",3))
distort:wcsinit.c:		wcs->equinox = 2000.0;
distort:wcsinit.c:	    else if (!strncmp (wcs->radecsys,"ICRS",4))
distort:wcsinit.c:		wcs->equinox = 2000.0;
distort:wcsinit.c:	    else if (!strncmp (wcs->radecsys,"GAL",3) && ieq == 0)
distort:wcsinit.c:		wcs->equinox = 2000.0;
distort:wcsinit.c:    else if (wcs->syswcs != WCS_NPOLE) {
distort:wcsinit.c:	    strcpy (wcs->radecsys,"FK5");
distort:wcsinit.c:	    strcpy (wcs->radecsys,"FK4");
distort:wcsinit.c:    if (wcs->c1type[0] == 'G')
distort:wcsinit.c:	strcpy (wcs->radecsys,"GALACTIC");
distort:wcsinit.c:    else if (wcs->c1type[0] == 'E')
distort:wcsinit.c:	strcpy (wcs->radecsys,"ECLIPTIC");
distort:wcsinit.c:    else if (wcs->c1type[0] == 'S')
distort:wcsinit.c:	strcpy (wcs->radecsys,"SGALACTC");
distort:wcsinit.c:    else if (wcs->c1type[0] == 'H')
distort:wcsinit.c:	strcpy (wcs->radecsys,"HELIOECL");
distort:wcsinit.c:    else if (wcs->c1type[0] == 'A')
distort:wcsinit.c:	strcpy (wcs->radecsys,"ALTAZ");
distort:wcsinit.c:    else if (wcs->c1type[0] == 'L')
distort:wcsinit.c:	strcpy (wcs->radecsys,"LINEAR");
distort:wcsinit.c:    wcs->syswcs = wcscsys (wcs->radecsys);
distort:wcsinit.c: * Oct  1 2003	Rename wcs->naxes to wcs->naxis to match WCSLIB 3.2
distort:wcsinit.c: * Dec  3 2003	Add back wcs->naxes for backward compatibility
distort:wcsinit.c: * Feb 15 2007	Check for wcs->wcsproj > 0 instead of CTYPEi != LINEAR or PIXEL
distort:wcslib.c:*                        World coordinates.  world[wcs->lng] and
distort:wcslib.c:*                        world[wcs->lat] are the celestial longitude and
distort:wcslib.c:*      imgcrd   double[] Image coordinate.  imgcrd[wcs->lng] and
distort:wcslib.c:*                        imgcrd[wcs->lat] are the projected x-, and
distort:wcslib.c:*                        also returned in imgcrd[wcs->cubeface].
distort:wcslib.c:*      imgcrd   double[] Image coordinate.  imgcrd[wcs->lng] and
distort:wcslib.c:*                        imgcrd[wcs->lat] are the projected x-, and
distort:wcslib.c:*      world    double[] World coordinates.  world[wcs->lng] and
distort:wcslib.c:*                        world[wcs->lat] are the celestial longitude and
distort:wcslib.c:*                              world[wcs->lng], latitude returned in
distort:wcslib.c:*                              world[wcs->lat].
distort:wcslib.c:*                              world[wcs->lat], longitude returned in
distort:wcslib.c:*                              world[wcs->lng].
distort:wcslib.c:*      world    double[] World coordinates.  world[wcs->lng] and
distort:wcslib.c:*                        world[wcs->lat] are the celestial longitude and
distort:wcslib.c:*      imgcrd   double[] Image coordinate.  imgcrd[wcs->lng] and
distort:wcslib.c:*                        imgcrd[wcs->lat] are the projected x-, and
distort:wcslib.c:   strcpy(wcs->pcode, "");
distort:wcslib.c:   wcs->lng = -1;
distort:wcslib.c:   wcs->lat = -1;
distort:wcslib.c:   wcs->cubeface = -1;
distort:wcslib.c:            if (wcs->cubeface == -1) {
distort:wcslib.c:               wcs->cubeface = j;
distort:wcslib.c:      if (strcmp(wcs->pcode, "") == 0) {
distort:wcslib.c:         sprintf(wcs->pcode, "%.3s", &ctype[j][5]);
distort:wcslib.c:            wcs->lng = j;
distort:wcslib.c:            strcpy(wcs->lngtyp, "RA");
distort:wcslib.c:            strcpy(wcs->lattyp, "DEC");
distort:wcslib.c:            ndx = &wcs->lat;
distort:wcslib.c:            sprintf(requir, "DEC--%s", wcs->pcode);
distort:wcslib.c:            wcs->lat = j;
distort:wcslib.c:            strcpy(wcs->lngtyp, "RA");
distort:wcslib.c:            strcpy(wcs->lattyp, "DEC");
distort:wcslib.c:            ndx = &wcs->lng;
distort:wcslib.c:            sprintf(requir, "RA---%s", wcs->pcode);
distort:wcslib.c:            wcs->lng = j;
distort:wcslib.c:            sprintf(wcs->lngtyp, "%cLON", ctype[j][0]);
distort:wcslib.c:            sprintf(wcs->lattyp, "%cLAT", ctype[j][0]);
distort:wcslib.c:            ndx = &wcs->lat;
distort:wcslib.c:            sprintf(requir, "%s-%s", wcs->lattyp, wcs->pcode);
distort:wcslib.c:            wcs->lat = j;
distort:wcslib.c:            sprintf(wcs->lngtyp, "%cLON", ctype[j][0]);
distort:wcslib.c:            sprintf(wcs->lattyp, "%cLAT", ctype[j][0]);
distort:wcslib.c:            ndx = &wcs->lng;
distort:wcslib.c:            sprintf(requir, "%s-%s", wcs->lngtyp, wcs->pcode);
distort:wcslib.c:            wcs->lng = j;
distort:wcslib.c:            sprintf(wcs->lngtyp, "%c%cLN", ctype[j][0], ctype[j][1]);
distort:wcslib.c:            sprintf(wcs->lattyp, "%c%cLT", ctype[j][0], ctype[j][1]);
distort:wcslib.c:            ndx = &wcs->lat;
distort:wcslib.c:            sprintf(requir, "%s-%s", wcs->lattyp, wcs->pcode);
distort:wcslib.c:            wcs->lat = j;
distort:wcslib.c:            sprintf(wcs->lngtyp, "%c%cLN", ctype[j][0], ctype[j][1]);
distort:wcslib.c:            sprintf(wcs->lattyp, "%c%cLT", ctype[j][0], ctype[j][1]);
distort:wcslib.c:            ndx = &wcs->lng;
distort:wcslib.c:            sprintf(requir, "%s-%s", wcs->lngtyp, wcs->pcode);
distort:wcslib.c:   if (strncmp(wcs->pcode, "GLS", 3) == 0) {
distort:wcslib.c:      strcpy(wcs->pcode, "SFL");
distort:wcslib.c:   if (strcmp(wcs->pcode, "")) {
distort:wcslib.c:      wcs->flag = WCSSET;
distort:wcslib.c:      wcs->flag = 999;
distort:wcslib.c:   if (wcs->flag != WCSSET) {
distort:wcslib.c:      if (j == wcs->lng) continue;
distort:wcslib.c:      if (j == wcs->lat) continue;
distort:wcslib.c:   if (wcs->flag != 999) {
distort:wcslib.c:      if (strcmp(wcs->pcode, "NCP") == 0) {
distort:wcslib.c:         strcpy(wcs->pcode, "SIN");
distort:wcslib.c:      if ((err = celfwd(wcs->pcode, world[wcs->lng], world[wcs->lat], cel,
distort:wcslib.c:                   phi, theta, prj, &imgcrd[wcs->lng], &imgcrd[wcs->lat]))) {
distort:wcslib.c:      if (wcs->cubeface != -1) {
distort:wcslib.c:         if (imgcrd[wcs->lat] < -0.5*offset) {
distort:wcslib.c:            imgcrd[wcs->lat] += offset;
distort:wcslib.c:            imgcrd[wcs->cubeface] = 5.0;
distort:wcslib.c:         } else if (imgcrd[wcs->lat] > 0.5*offset) {
distort:wcslib.c:            imgcrd[wcs->lat] -= offset;
distort:wcslib.c:            imgcrd[wcs->cubeface] = 0.0;
distort:wcslib.c:         } else if (imgcrd[wcs->lng] > 2.5*offset) {
distort:wcslib.c:            imgcrd[wcs->lng] -= 3.0*offset;
distort:wcslib.c:            imgcrd[wcs->cubeface] = 4.0;
distort:wcslib.c:         } else if (imgcrd[wcs->lng] > 1.5*offset) {
distort:wcslib.c:            imgcrd[wcs->lng] -= 2.0*offset;
distort:wcslib.c:            imgcrd[wcs->cubeface] = 3.0;
distort:wcslib.c:         } else if (imgcrd[wcs->lng] > 0.5*offset) {
distort:wcslib.c:            imgcrd[wcs->lng] -= offset;
distort:wcslib.c:            imgcrd[wcs->cubeface] = 2.0;
distort:wcslib.c:            imgcrd[wcs->cubeface] = 1.0;
distort:wcslib.c:   if (wcs->flag != WCSSET) {
distort:wcslib.c:      if (j == wcs->lng) continue;
distort:wcslib.c:      if (j == wcs->lat) continue;
distort:wcslib.c:   if (wcs->flag != 999) {
distort:wcslib.c:      if (wcs->cubeface != -1) {
distort:wcslib.c:         face = (int)(imgcrd[wcs->cubeface] + 0.5);
distort:wcslib.c:         if (fabs(imgcrd[wcs->cubeface]-face) > 1e-10) {
distort:wcslib.c:            imgcrd[wcs->lat] += offset;
distort:wcslib.c:            imgcrd[wcs->lng] += offset;
distort:wcslib.c:            imgcrd[wcs->lng] += offset*2;
distort:wcslib.c:            imgcrd[wcs->lng] += offset*3;
distort:wcslib.c:            imgcrd[wcs->lat] -= offset;
distort:wcslib.c:      if (strcmp(wcs->pcode, "NCP") == 0) {
distort:wcslib.c:         strcpy(wcs->pcode, "SIN");
distort:wcslib.c:      if ((err = celrev(wcs->pcode, imgcrd[wcs->lng], imgcrd[wcs->lat], prj,
distort:wcslib.c:                   phi, theta, cel, &world[wcs->lng], &world[wcs->lat]))) {
distort:wcslib.c:   if (wcs->flag != WCSSET) {
distort:wcslib.c:         world[wcs->lat] = lat0;
distort:wcslib.c:         world[wcs->lat] = lat1;
distort:wcslib.c:               world[wcs->lat] = lat0;
distort:wcslib.c:                  world[wcs->lat] = lat;
distort:wcslib.c:               world[wcs->lat] = lat0;
distort:wcslib.c:               world[wcs->lat] = lat1;
distort:wcslib.c:                  world[wcs->lat] = lat0m;
distort:wcslib.c:                  world[wcs->lat] = lat1m;
distort:wcslib.c:         world[wcs->lng] = lng0;
distort:wcslib.c:         world[wcs->lng] = lng1;
distort:wcslib.c:               world[wcs->lng] = lng0;
distort:wcslib.c:                  world[wcs->lng] = lng;
distort:wcslib.c:               world[wcs->lng] = lng0;
distort:wcslib.c:               world[wcs->lng] = lng1;
distort:wcslib.c:                  world[wcs->lng] = lng0m;
distort:wcslib.c:                  world[wcs->lng] = lng1m;
distort:wcslib.c:         if (fabs(fmod(world[wcs->lng]-lng,360.0)) > tol) continue;
distort:wcslib.c:         world[wcs->lat] = lat;
distort:wcslib.c:         if (fabs(world[wcs->lat]-lat) > tol) continue;
distort:wcslib.c:         world[wcs->lng] = lng;
distort:wcslib.c:      lng = world[wcs->lng];
distort:wcslib.c:      lat = world[wcs->lat];
distort:wcslib.c:      world[wcs->lng] = -180.0;
distort:wcslib.c:      world[wcs->lat] = *theta;
distort:wcslib.c:         world[wcs->lng] = lng;
distort:wcslib.c:         world[wcs->lat] = lat;
distort:wcslib.c:         world[wcs->lng] = phi1;
distort:wcslib.c:            world[wcs->lng] = lng;
distort:wcslib.c:            world[wcs->lat] = lat;
distort:wcslib.c:         world[wcs->lng] = phi0 + lambda*dphi;
distort:wcslib.c:            world[wcs->lng] = lng;
distort:wcslib.c:            world[wcs->lat] = lat;
distort:wcslib.c:            phi0 = world[wcs->lng];
distort:wcslib.c:            phi1 = world[wcs->lng];
distort:worldpos.c:  int itype = wcs->prjcode;
distort:worldpos.c:  xref = wcs->xref;
distort:worldpos.c:  yref = wcs->yref;
distort:worldpos.c:  xrefpix = wcs->xrefpix;
distort:worldpos.c:  yrefpix = wcs->yrefpix;
distort:worldpos.c:  xinc = wcs->xinc;
distort:worldpos.c:  yinc = wcs->yinc;
distort:worldpos.c:  rot = degrad (wcs->rot);
distort:worldpos.c:  if (wcs->rotmat) {
distort:worldpos.c:    tx = dx * wcs->cd[0] + dy * wcs->cd[1];
distort:worldpos.c:    dy = dx * wcs->cd[2] + dy * wcs->cd[3];
distort:worldpos.c:  if (wcs->coorflip) {
distort:worldpos.c:  if (wcs->coorflip) {
distort:worldpos.c:  xref = wcs->xref;
distort:worldpos.c:  yref = wcs->yref;
distort:worldpos.c:  xrefpix = wcs->xrefpix;
distort:worldpos.c:  yrefpix = wcs->yrefpix;
distort:worldpos.c:  xinc = wcs->xinc;
distort:worldpos.c:  yinc = wcs->yinc;
distort:worldpos.c:  rot = degrad (wcs->rot);
distort:worldpos.c:  itype = wcs->prjcode;
distort:worldpos.c:    if (wcs->coorflip) {
distort:worldpos.c:	if (wcs->rotmat)
distort:worldpos.c:	    l = rap * an * (1.0 - ansq/6.0) * (wcs->cd[0] / fabs(wcs->cd[0]));
distort:worldpos.c:  if (wcs->coorflip) {
distort:worldpos.c:  if (wcs->rotmat) {
distort:worldpos.c:    tx = dx * wcs->dc[0] + dy * wcs->dc[1];
distort:worldpos.c:    dy = dx * wcs->dc[2] + dy * wcs->dc[3];
distort:worldpos.c:    if (*xpix > wcs->nxpix) {
distort:worldpos.c:      if (x <= wcs->nxpix) *xpix = x;
distort:zpxpos.c:    if (wcs->longpole > 360.0) {
distort:zpxpos.c:	if (!igetr8 (str1, "longpole", &wcs->longpole)) {
distort:zpxpos.c:	    if (!igetr8 (str2, "longpole", &wcs->longpole))
distort:zpxpos.c:		wcs->longpole = 180.0;
distort:zpxpos.c:    if (!igetr8 (str1, "ro", &wcs->rodeg)) {
distort:zpxpos.c:	if (!igetr8 (str2, "ro", &wcs->rodeg))
distort:zpxpos.c:	    wcs->rodeg = 180.0 / PI;
distort:zpxpos.c:	if (!igetr8 (str1, key, &wcs->prj.p[i]))
distort:zpxpos.c:	    wcs->prj.p[i] = 0.0;
distort:zpxpos.c:	    wcs->lngcor = NULL;
distort:zpxpos.c:	    wcs->lngcor = wf_gsopen (lngstr);
distort:zpxpos.c:	wcs->lngcor = wf_gsopen (lngstr);
distort:zpxpos.c:	    wcs->latcor = NULL;
distort:zpxpos.c:	    wcs->latcor = wf_gsopen (latstr);
distort:zpxpos.c:	wcs->latcor = wf_gsopen (latstr);
distort:zpxpos.c:    for (i = 9; i >= 0 && wcs->prj.p[i] == 0.; i--);
distort:zpxpos.c:    wcs->zpnp = i;
distort:zpxpos.c:	d1 = wcs->prj.p[1];
distort:zpxpos.c:	    for (j = wcs->zpnp; j >= 1; j--) {
distort:zpxpos.c:		d2 = d2 * zd2 + j * wcs->prj.p[j];
distort:zpxpos.c:		for (j = wcs->zpnp; j >= 1; j--) {
distort:zpxpos.c:		    d = d * zd + j * wcs->prj.p[j];
distort:zpxpos.c:	for (j = wcs->zpnp; j >= 0; j--)
distort:zpxpos.c:	    r = r * zd + wcs->prj.p[j];
distort:zpxpos.c:	wcs->zpzd = zd;
distort:zpxpos.c:	wcs->zpr = r;
distort:zpxpos.c:    if (wcs->latcor == NULL && wcs->lngcor == NULL)
distort:zpxpos.c:    xpix = xpix - wcs->crpix[0];
distort:zpxpos.c:    ypix = ypix - wcs->crpix[1];
distort:zpxpos.c:    if (wcs->rotmat) {
distort:zpxpos.c:	x = xpix * wcs->cd[0] + ypix * wcs->cd[1];
distort:zpxpos.c:	y = xpix * wcs->cd[2] + ypix * wcs->cd[3];
distort:zpxpos.c:	if (wcs->cdelt[0] == 0.0 || wcs->cdelt[1] == 0.0) {
distort:zpxpos.c:	xs = xpix * wcs->cdelt[0];
distort:zpxpos.c:	ys = ypix * wcs->cdelt[1];
distort:zpxpos.c:	if (wcs->rot != 0.0) {
distort:zpxpos.c:	    double cosr = cos (degrad (wcs->rot));
distort:zpxpos.c:	    double sinr = sin (degrad (wcs->rot));
distort:zpxpos.c:    if (wcs->coorflip) {
distort:zpxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
distort:zpxpos.c:    longp = degrad(wcs->longpole);
distort:zpxpos.c:    k = wcs->zpnp;
distort:zpxpos.c:    if (wcs->lngcor != NULL)
distort:zpxpos.c:	xp = x + wf_gseval (wcs->lngcor, x, y);
distort:zpxpos.c:    if (wcs->latcor != NULL)
distort:zpxpos.c:	yp = y + wf_gseval (wcs->latcor, x, y);
distort:zpxpos.c:    r = sqrt (x * x + y * y) / wcs->rodeg;
distort:zpxpos.c:        zd = (r - wcs->prj.p[0]) / wcs->prj.p[1];
distort:zpxpos.c:        a = wcs->prj.p[2];
distort:zpxpos.c:        b = wcs->prj.p[1];
distort:zpxpos.c:        c = wcs->prj.p[0] - r;
distort:zpxpos.c:	r1 = wcs->prj.p[0];
distort:zpxpos.c:	zd2 = wcs->zpzd;
distort:zpxpos.c:	r2 = wcs->zpr;
distort:zpxpos.c:		    rt = (rt * zd) + wcs->prj.p[i];
distort:zpxpos.c:    ra =  wcs->crval[ira] + raddeg(dlng);
distort:zpxpos.c:    if (wcs->crval[ira] >= 0.0) {
distort:zpxpos.c:    if (wcs->coorflip) {
distort:zpxpos.c:    ra  = degrad (xpos - wcs->crval[ira]);
distort:zpxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
distort:zpxpos.c:    if (wcs->longpole == 999.0)
distort:zpxpos.c:	longp = degrad(wcs->longpole);
distort:zpxpos.c:        r = r * s + wcs->prj.p[i];
distort:zpxpos.c:    r = wcs->rodeg * r;
distort:zpxpos.c:    if (wcs->lngcor == NULL && wcs->latcor == NULL) {
distort:zpxpos.c:	if (wcs->coorflip) {
distort:zpxpos.c:	    if (wcs->lngcor != NULL) {
distort:zpxpos.c:		f = x + wf_gseval (wcs->lngcor, x, y) - xm;
distort:zpxpos.c:		fx = wf_gsder (wcs->lngcor, x, y, 1, 0);
distort:zpxpos.c:		fy = wf_gsder (wcs->lngcor, x, y, 0, 1);
distort:zpxpos.c:	    if (wcs->latcor != NULL) {
distort:zpxpos.c:		g = y + wf_gseval (wcs->latcor, x, y) - ym;
distort:zpxpos.c:		gx = wf_gsder (wcs->latcor, x, y, 1, 0);
distort:zpxpos.c:		gy = wf_gsder (wcs->latcor, x, y, 0, 1);
distort:zpxpos.c:	if (wcs->coorflip) {
distort:zpxpos.c:    if (wcs->rotmat) {
distort:zpxpos.c:	*xpix = x * wcs->dc[0] + y * wcs->dc[1];
distort:zpxpos.c:	*ypix = x * wcs->dc[2] + y * wcs->dc[3];
distort:zpxpos.c:	if (wcs->rot!=0.0) {
distort:zpxpos.c:	    double cosr = cos (degrad (wcs->rot));
distort:zpxpos.c:	    double sinr = sin (degrad (wcs->rot));
distort:zpxpos.c:	if (wcs->xinc != 0.)
distort:zpxpos.c:	    *xpix = *xpix / wcs->xinc;
distort:zpxpos.c:	if (wcs->yinc != 0.)
distort:zpxpos.c:	    *ypix = *ypix / wcs->yinc;
distort:zpxpos.c:    *xpix = *xpix + wcs->xrefpix;
distort:zpxpos.c:    *ypix = *ypix + wcs->yrefpix;
distort:zpxpos.c:    if (wcs->lngcor != NULL)
distort:zpxpos.c:	wf_gsclose (wcs->lngcor);
distort:zpxpos.c:    if (wcs->latcor != NULL)
distort:zpxpos.c:	wf_gsclose (wcs->latcor);
distort.c: *** Harvard-Smithsonian Center for Astrophysics
distort.c: *** Copyright (C) 2004-2007
distort.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
distort.c: * Subroutine:	pix2foc (wcs, x, y, u, v) pixel coordinates -> focal plane coordinates
distort.c: * Subroutine:	foc2pix (wcs, u, v, x, y) focal plane coordinates -> pixel coordinates
distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort.c:	if (wcs->wcsproj == WCS_OLD) {
distort.c:	    wcs->wcsproj = WCS_NEW;
distort.c:	    wcs->distort.a_order = 0;
distort.c:	    wcs->distort.b_order = 0;
distort.c:	    wcs->distort.ap_order = 0;
distort.c:	    wcs->distort.bp_order = 0;
distort.c:	    if (!hgeti4 (hstring, "A_ORDER", &wcs->distort.a_order)) {
distort.c:		m = wcs->distort.a_order;
distort.c:			wcs->distort.a[i][j] = 0.0;
distort.c:		    for (j = 0; j <= m-i; j++) {
distort.c:			hgetr8 (hstring, keyword, &wcs->distort.a[i][j]);
distort.c:	    if (!hgeti4 (hstring, "B_ORDER", &wcs->distort.b_order)) {
distort.c:		m = wcs->distort.b_order;
distort.c:			wcs->distort.b[i][j] = 0.0;
distort.c:		    for (j = 0; j <= m-i; j++) {
distort.c:			hgetr8 (hstring, keyword, &wcs->distort.b[i][j]);
distort.c:	    if (!hgeti4 (hstring, "AP_ORDER", &wcs->distort.ap_order)) {
distort.c:		m = wcs->distort.ap_order;
distort.c:			wcs->distort.ap[i][j] = 0.0;
distort.c:		    for (j = 0; j <= m-i; j++) {
distort.c:			hgetr8 (hstring, keyword, &wcs->distort.ap[i][j]);
distort.c:	    if (!hgeti4 (hstring, "BP_ORDER", &wcs->distort.bp_order)) {
distort.c:		m = wcs->distort.bp_order;
distort.c:			wcs->distort.bp[i][j] = 0.0;
distort.c:		    for (j = 0; j <= m-i; j++) {
distort.c:			hgetr8 (hstring, keyword, &wcs->distort.bp[i][j]);
distort.c:/* Delete all distortion-related fields.
distort.c: * return 0 if at least one such field is found, else -1.  */
distort.c:	    for (j = 0; j <= m-i; j++) {
distort.c:	    for (j = 0; j <= m-i; j++) {
distort.c:	    for (j = 0; j <= m-i; j++) {
distort.c:	    for (j = 0; j <= m-i; j++) {
distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort.c:	m = wcs->distort.ap_order;
distort.c:	n = wcs->distort.bp_order;
distort.c:	temp_x = x - wcs->xrefpix;
distort.c:	temp_y = y - wcs->yrefpix;
distort.c:	    s[j] = wcs->distort.ap[m-j][j];
distort.c:	    for (k = j-1; k >= 0; k--) {
distort.c:	   	s[j] = (temp_y * s[j]) + wcs->distort.ap[m-j][k];
distort.c:	for (i=m; i>=1; i--){
distort.c:	    sum = (temp_x * sum) + s[m-i+1];
distort.c:	    s[j] = wcs->distort.bp[n-j][j];
distort.c:	    for (k = j-1; k >= 0; k--) {
distort.c:		s[j] = temp_y*s[j] + wcs->distort.bp[n-j][k];
distort.c:	for (i = n; i >= 1; i--)
distort.c:	    sum = temp_x * sum + s[n-i+1];
distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort.c:	m = wcs->distort.a_order;
distort.c:	n = wcs->distort.b_order;
distort.c:	temp_u = u - wcs->xrefpix;
distort.c:	temp_v = v - wcs->yrefpix;
distort.c:	    s[j] = wcs->distort.a[m-j][j];
distort.c:	    for (k = j-1; k >= 0; k--) {
distort.c:		s[j] = (temp_v * s[j]) + wcs->distort.a[m-j][k];
distort.c:	for (i=m; i>=1; i--){
distort.c:	    sum = temp_u*sum + s[m-i+1];
distort.c:	    s[j] = wcs->distort.b[n-j][j];
distort.c:	    for (k=j-1; k>=0; k--) {
distort.c:		s[j] =temp_v*s[j] + wcs->distort.b[n-j][k];
distort.c:	for (i=n; i>=1; i--)
distort.c:	    sum = temp_u*sum + s[n-i+1];
distort.c:/* SETDISTCODE -- Set WCS distortion code from CTYPEi in FITS header */
distort.c:	wcs->distcode = DISTORT_NONE;
distort.c:	if (!strncmp (extension, "-SIP", 4))
distort.c:	    wcs->distcode = DISTORT_SIRTF;
distort.c:	    wcs->distcode = DISTORT_NONE;
distort.c:/* GETDISTCODE -- Return NULL if no distortion or code from wcs.h */
distort.c:    if (wcs->distcode == DISTORT_SIRTF) {
distort.c:	strcpy (dcode, "-SIP");
dsspos.c: *** Harvard-Smithsonian Center for Astrophysics
dsspos.c: *** Copyright (C) 1995-2002
dsspos.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
dsspos.c:  double cond2r = 1.745329252e-2;
dsspos.c:  x = xpix + wcs->x_pixel_offset - 1.0 + 0.5;
dsspos.c:  y = ypix + wcs->y_pixel_offset - 1.0 + 0.5;
dsspos.c:  xmm = (wcs->ppo_coeff[2] - x * wcs->x_pixel_size) / 1000.0;
dsspos.c:  ymm = (y * wcs->y_pixel_size - wcs->ppo_coeff[5]) / 1000.0;
dsspos.c:  xi =  wcs->x_coeff[ 0]*xmm	+ wcs->x_coeff[ 1]*ymm +
dsspos.c:	wcs->x_coeff[ 2]		+ wcs->x_coeff[ 3]*xmm2 +
dsspos.c:	wcs->x_coeff[ 4]*xmm*ymm	+ wcs->x_coeff[ 5]*ymm2 +
dsspos.c:	wcs->x_coeff[ 6]*(x2y2)	+ wcs->x_coeff[ 7]*xmm3 +
dsspos.c:	wcs->x_coeff[ 8]*xmm2*ymm	+ wcs->x_coeff[ 9]*xmm*ymm2 +
dsspos.c:	wcs->x_coeff[10]*ymm3	+ wcs->x_coeff[11]*xmm*(x2y2) +
dsspos.c:	wcs->x_coeff[12]*xmm*x2y2*x2y2;
dsspos.c:	+ wcs->x_coeff[13]*mag	+ wcs->x_coeff[14]*mag*mag +
dsspos.c:	wcs->x_coeff[15]*mag*mag*mag + wcs->x_coeff[16]*mag*xmm +
dsspos.c:	wcs->x_coeff[17]*mag*x2y2	+ wcs->x_coeff[18]*mag*xmm*x2y2 +
dsspos.c:	wcs->x_coeff[19]*color; */
dsspos.c:  eta =	wcs->y_coeff[ 0]*ymm	+ wcs->y_coeff[ 1]*xmm +
dsspos.c:	wcs->y_coeff[ 2]		+ wcs->y_coeff[ 3]*ymm2 +
dsspos.c:	wcs->y_coeff[ 4]*xmm*ymm	+ wcs->y_coeff[ 5]*xmm2 +
dsspos.c:	wcs->y_coeff[ 6]*(x2y2)	+ wcs->y_coeff[ 7]*ymm3 +
dsspos.c:	wcs->y_coeff[ 8]*ymm2*xmm	+ wcs->y_coeff[ 9]*ymm*xmm2 +
dsspos.c:	wcs->y_coeff[10]*xmm3	+ wcs->y_coeff[11]*ymm*(x2y2) +
dsspos.c:	wcs->y_coeff[12]*ymm*x2y2*x2y2;
dsspos.c:	+ wcs->y_coeff[13]*mag	+ wcs->y_coeff[14]*mag*mag +
dsspos.c:	wcs->y_coeff[15]*mag*mag*mag + wcs->y_coeff[16]*mag*ymm +
dsspos.c:	wcs->y_coeff[17]*mag*x2y2)	+ wcs->y_coeff[18]*mag*ymm*x2y2 +
dsspos.c:	wcs->y_coeff[19]*color; */
dsspos.c:  ctan = tan (wcs->plate_dec);
dsspos.c:  ccos = cos (wcs->plate_dec);
dsspos.c:  raoff = atan2 (xir / ccos, 1.0 - etar * ctan);
dsspos.c:  ra = raoff + wcs->plate_ra;
dsspos.c:  dec = atan (cos (raoff) * ((etar + ctan) / (1.0 - (etar * ctan))));
dsspos.c:  if (wcs->plate_dec == 0.0)
dsspos.c:    wcs->plate_dec = degrad (wcs->yref);
dsspos.c:  syplate = sin (wcs->plate_dec);
dsspos.c:  cyplate = cos (wcs->plate_dec);
dsspos.c:  if (wcs->plate_ra == 0.0)
dsspos.c:    wcs->plate_ra = degrad (wcs->yref);
dsspos.c:  sxdiff = sin (xr - wcs->plate_ra);
dsspos.c:  cxdiff = cos (xr - wcs->plate_ra);
dsspos.c:  eta = ((sypos * cyplate) - (cypos * syplate * cxdiff)) * conr2s / div;
dsspos.c:  if (wcs->plate_scale == 0.0)
dsspos.c:  xmm = xi / wcs->plate_scale;
dsspos.c:  ymm = eta / wcs->plate_scale;
dsspos.c:    f = wcs->x_coeff[0]*xmm      + wcs->x_coeff[1]*ymm +
dsspos.c:        wcs->x_coeff[2]          + wcs->x_coeff[3]*x2 +
dsspos.c:        wcs->x_coeff[4]*xy       + wcs->x_coeff[5]*y2 +
dsspos.c:        wcs->x_coeff[6]*x2y2     + wcs->x_coeff[7]*x3 +
dsspos.c:        wcs->x_coeff[8]*x2y      + wcs->x_coeff[9]*y2x +
dsspos.c:        wcs->x_coeff[10]*y3      + wcs->x_coeff[11]*xmm*x2y2 +
dsspos.c:        wcs->x_coeff[12]*xmm*cjunk;
dsspos.c:      + wcs->x_coeff[13]*mag +
dsspos.c:        wcs->x_coeff[14]*mag*mag   + wcs->x_coeff[15]*mag*mag*mag +
dsspos.c:        wcs->x_coeff[16]*mag*xmm   + wcs->x_coeff[17]*mag*(x2+y2) +
dsspos.c:        wcs->x_coeff[18]*mag*xmm*(x2+y2)  + wcs->x_coeff[19]*color;
dsspos.c:    fx = wcs->x_coeff[0]           + wcs->x_coeff[3]*2.0*xmm +
dsspos.c:         wcs->x_coeff[4]*ymm       + wcs->x_coeff[6]*2.0*xmm +
dsspos.c:         wcs->x_coeff[7]*3.0*x2    + wcs->x_coeff[8]*2.0*xy +
dsspos.c:         wcs->x_coeff[9]*y2        + wcs->x_coeff[11]*(3.0*x2+y2) +
dsspos.c:         wcs->x_coeff[12]*(5.0*x4 +6.0*x2*y2+y4);
dsspos.c:         wcs->x_coeff[16]*mag      + wcs->x_coeff[17]*mag*2.0*xmm +
dsspos.c:         wcs->x_coeff[18]*mag*(3.0*x2+y2);
dsspos.c:    fy = wcs->x_coeff[1]           + wcs->x_coeff[4]*xmm +
dsspos.c:         wcs->x_coeff[5]*2.0*ymm   + wcs->x_coeff[6]*2.0*ymm +
dsspos.c:         wcs->x_coeff[8]*x2        + wcs->x_coeff[9]*2.0*xy +
dsspos.c:         wcs->x_coeff[10]*3.0*y2   + wcs->x_coeff[11]*2.0*xy +
dsspos.c:         wcs->x_coeff[12]*4.0*xy*x2y2;
dsspos.c:         wcs->x_coeff[17]*mag*2.0*ymm +
dsspos.c:         wcs->x_coeff[18]*mag*2.0*xy;
dsspos.c:    g = wcs->y_coeff[0]*ymm       + wcs->y_coeff[1]*xmm +
dsspos.c:       wcs->y_coeff[2]            + wcs->y_coeff[3]*y2 +
dsspos.c:       wcs->y_coeff[4]*xy         + wcs->y_coeff[5]*x2 +
dsspos.c:       wcs->y_coeff[6]*x2y2       + wcs->y_coeff[7]*y3 +
dsspos.c:       wcs->y_coeff[8]*y2x        + wcs->y_coeff[9]*x2y +
dsspos.c:       wcs->y_coeff[10]*x3        + wcs->y_coeff[11]*ymm*x2y2 +
dsspos.c:       wcs->y_coeff[12]*ymm*cjunk;
dsspos.c:       wcs->y_coeff[13]*mag        + wcs->y_coeff[14]*mag*mag +
dsspos.c:       wcs->y_coeff[15]*mag*mag*mag + wcs->y_coeff[16]*mag*ymm +
dsspos.c:       wcs->y_coeff[17]*mag*x2y2 +
dsspos.c:       wcs->y_coeff[18]*mag*ymm*x2y2 + wcs->y_coeff[19]*color;
dsspos.c:    gx = wcs->y_coeff[1]           + wcs->y_coeff[4]*ymm +
dsspos.c:         wcs->y_coeff[5]*2.0*xmm   + wcs->y_coeff[6]*2.0*xmm +
dsspos.c:         wcs->y_coeff[8]*y2       + wcs->y_coeff[9]*2.0*xy +
dsspos.c:         wcs->y_coeff[10]*3.0*x2  + wcs->y_coeff[11]*2.0*xy +
dsspos.c:         wcs->y_coeff[12]*4.0*xy*x2y2;
dsspos.c:         wcs->y_coeff[17]*mag*2.0*xmm +
dsspos.c:         wcs->y_coeff[18]*mag*ymm*2.0*xmm;
dsspos.c:    gy = wcs->y_coeff[0]            + wcs->y_coeff[3]*2.0*ymm +
dsspos.c:         wcs->y_coeff[4]*xmm        + wcs->y_coeff[6]*2.0*ymm +
dsspos.c:         wcs->y_coeff[7]*3.0*y2     + wcs->y_coeff[8]*2.0*xy +
dsspos.c:         wcs->y_coeff[9]*x2         + wcs->y_coeff[11]*(x2+3.0*y2) +
dsspos.c:         wcs->y_coeff[12]*(5.0*y4 + 6.0*x2*y2 + x4);
dsspos.c:         wcs->y_coeff[16]*mag       + wcs->y_coeff[17]*mag*2.0*ymm +
dsspos.c:         wcs->y_coeff[18]*mag*(x2+3.0*y2);
dsspos.c:    f = f - xi;
dsspos.c:    g = g - eta;
dsspos.c:    dx = ((-f * gy) + (g * fy)) / ((fx * gy) - (fy * gx));
dsspos.c:    dy = ((-g * fx) + (f * gx)) / ((fx * gy) - (fy * gx));
dsspos.c:  if (wcs->x_pixel_size == 0.0 || wcs->y_pixel_size == 0.0)
dsspos.c:  x = (wcs->ppo_coeff[2] - xmm*1000.0) / wcs->x_pixel_size;
dsspos.c:  y = (wcs->ppo_coeff[5] + ymm*1000.0) / wcs->y_pixel_size;
dsspos.c:  *xpix = x - wcs->x_pixel_offset + 1.0 - 0.5;
dsspos.c:  *ypix = y - wcs->y_pixel_offset + 1.0 - 0.5;
dsspos.c:  if (*xpix < 0.5 || *xpix > wcs->nxpix+0.5)
dsspos.c:    return -1;
dsspos.c:  if (*ypix < 0.5 || *ypix > wcs->nypix+0.5)
dsspos.c:    return -1;
dsspos.c: * Oct 17 1995	Fix inverse routine (degrees -> radians)
Files:  Subroutines to extract values from IRAF multi-keyword header parameters
Files:  left-right reflection before the rotation.
Files:  findCoords to fit plate-tangent WCS to the image.
Files:  and magnitude range or list of star numbers.  Both IDR2 and All-Sky release
Files:  Constants used by star-finding and WCS-setting subroutines
fileutil.c: *** Harvard-Smithsonian Center for Astrophysics
fileutil.c: *** Copyright (C) 1999-2014
fileutil.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fileutil.c:/* GETFILELINES -- return number of lines in one file */
fileutil.c:/* GETFILEBUFF -- return entire file contents in one character string */
fileutil.c:		fprintf (stderr,"GETFILEBUFF: No room for %d-byte buffer\n",
fileutil.c:	fprintf (stderr,"GETFILEBUFF: File %s: no room for %d-byte buffer\n",
fileutil.c:/* GETFILESIZE -- return size of one file in bytes */
fileutil.c:        return (-1);
fileutil.c:        filesize = -1;
fileutil.c:/* ISIMLIST -- Return 1 if list of FITS or IRAF files, else 0 */
fileutil.c:/* ISIMLISTD -- Return 1 if list of FITS or IRAF files, else 0 */
fileutil.c:/* ISFILELIST -- Return 1 if list of readable files, else 0 */
fileutil.c:/* ISFILE -- Return 1 if file is a readable file, else 0 */
fileutil.c:/* NEXT_LINE -- Read the next line of an ASCII file, returning length */
fileutil.c:	lastchar = line + strlen (line) - 1;
fileutil.c:	    *lastchar-- = 0;
fileutil.c:/* FIRST_TOKEN -- Return first token from the next line of an ASCII file */
fileutil.c:	lastchar = token + strlen (token) - 1;
fileutil.c:	    *lastchar-- = 0;
fileutil.c:/* ISTIFF -- Return 1 if TIFF file, else 0 */
fileutil.c:/* ISJPEG -- Return 1 if JPEG file, else 0 */
fileutil.c:/* ISGIF -- Return 1 if GIF file, else 0 */
fileutil.c:/* -- SETOKEN -- tokenize a string for easy decoding */
fileutil.c:	tokens->lline = inew - string - 1;
fileutil.c:	tokens->lline = strlen (string);
fileutil.c:    tokens->line = string;
fileutil.c:	tokens->white[0] = (char) 9;	/* Tab */
fileutil.c:	tokens->white[1] = (char) 0;	/* NULL (end of string) */
fileutil.c:	tokens->nwhite = 2;
fileutil.c:	tokens->white[0] = '|';		/* Bar */
fileutil.c:	tokens->white[1] = (char) 0;	/* NULL (end of string) */
fileutil.c:	tokens->nwhite = 2;
fileutil.c:	tokens->nwhite = 4 + naddw;;
fileutil.c:	tokens->white[0] = ' ';		/* Space */
fileutil.c:	tokens->white[1] = (char) 9;	/* Tab */
fileutil.c:	tokens->white[2] = ',';		/* Comma */
fileutil.c:	tokens->white[3] = (char) 124;	/* Vertical bar */
fileutil.c:	tokens->white[4] = (char) 0;	/* Null (end of string) */
fileutil.c:	if (tokens->nwhite > 20)
fileutil.c:	    tokens->nwhite = 20;
fileutil.c:	    for (j = 4; j < tokens->nwhite; j++) {
fileutil.c:		tokens->white[j] = cwhite[i];
fileutil.c:    tokens->white[tokens->nwhite] = (char) 0;
fileutil.c:    tokens->ntok = 0;
fileutil.c:    tokens->itok = 0;
fileutil.c:    iq = string - 1;
fileutil.c:	tokens->tok1[i] = NULL;
fileutil.c:	tokens->ltok[i] = 0;
fileutil.c:    while (stri < string+tokens->lline) {
fileutil.c:	    tokens->ntok = tokens->ntok + 1;
fileutil.c:	    if (tokens->ntok > maxtokens) return (maxtokens);
fileutil.c:	    tokens->tok1[tokens->ntok] = stri + 1;
fileutil.c:	    tokens->ltok[tokens->ntok] = (iq - stri) - 1;
fileutil.c:	wtype = strchr (tokens->white, jch);
fileutil.c:	if (wtype > tokens->white + 3) {
fileutil.c:		tokens->ntok = tokens->ntok + 1;
fileutil.c:		if (tokens->ntok > maxtokens) return (maxtokens);
fileutil.c:		tokens->tok1[tokens->ntok] = str0;
fileutil.c:		tokens->ltok[tokens->ntok] = stri - str0;
fileutil.c:	    tokens->ntok = tokens->ntok + 1;
fileutil.c:	    if (tokens->ntok > maxtokens) return (maxtokens);
fileutil.c:	    tokens->tok1[tokens->ntok] = stri;
fileutil.c:	    tokens->ltok[tokens->ntok] = 1;
fileutil.c:		tokens->ntok = tokens->ntok + 1;
fileutil.c:		if (tokens->ntok > maxtokens) return (maxtokens);
fileutil.c:		tokens->tok1[tokens->ntok] = str0;
fileutil.c:		tokens->ltok[tokens->ntok] = stri - str0;
fileutil.c:	tokens->ntok = tokens->ntok + 1;
fileutil.c:	if (tokens->ntok > maxtokens)
fileutil.c:	tokens->tok1[tokens->ntok] = str0;
fileutil.c:	ltok = stri - str0 + 1;
fileutil.c:	tokens->ltok[tokens->ntok] = ltok;
fileutil.c:	jch = str0[ltok-1];
fileutil.c:	if (strchr (tokens->white, jch)) {
fileutil.c:	    ltok = ltok - 1;
fileutil.c:	    tokens->ltok[tokens->ntok] = ltok;
fileutil.c:	    tokens->ntok = tokens->ntok + 1;
fileutil.c:	    tokens->tok1[tokens->ntok] = str0 + ltok;
fileutil.c:	    tokens->ltok[tokens->ntok] = 0;
fileutil.c:    tokens->itok = 0;
fileutil.c:    return (tokens->ntok);
fileutil.c:/* NEXTOKEN -- get next token from tokenized string */
fileutil.c:    int maxc = maxchars - 1;
fileutil.c:    tokens->itok = tokens->itok + 1;
fileutil.c:    it = tokens->itok;
fileutil.c:    if (it > tokens->ntok)
fileutil.c:	it = tokens->ntok;
fileutil.c:    ltok = tokens->ltok[it];
fileutil.c:    strncpy (token, tokens->tok1[it], ltok);
fileutil.c:/* GETOKEN -- get specified token from tokenized string */
fileutil.c:			 * if <0, get whole string after token -itok
fileutil.c:    int maxc = maxchars - 1;
fileutil.c:	if (it > tokens->ntok)
fileutil.c:	    it = tokens->ntok;
fileutil.c:	ltok = tokens->ltok[it];
fileutil.c:	strncpy (token, tokens->tok1[it], ltok);
fileutil.c:	if (it < -tokens->ntok)
fileutil.c:	    it  = -tokens->ntok;
fileutil.c:	ltok = tokens->line + tokens->lline - tokens->tok1[-it];
fileutil.c:	strncpy (token, tokens->tok1[-it], ltok);
fileutil.c:	ltok = tokens->lline;
fileutil.c:	strncpy (token, tokens->tok1[1], ltok);
fileutil.c: * Jan  8 2002	Add sts2c() and stc2s() for space-replaced strings
findstar.c: *** Copyright (C) 1996-2007
findstar.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
findstar.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
findstar.c:static int nspix = NSTATPIX;	/* Stats are computed for +- this many pixels */
findstar.c:static int rnoise = RNOISE;	/* Mean noise is from center +- this many pixels */
findstar.c: * return number of stars (might well be 0 :-), or -1 if trouble.
findstar.c:	xborder2 = w - atoi (tx2);
findstar.c:	yborder2 = atoi (tx4) - h;
findstar.c:    x1 = (w / 2) - rnoise;
findstar.c:    y1 = (h / 2) - rnoise;
findstar.c:    for (sv = svlim - xborder2; sv < svlim; sv++)
findstar.c:	fprintf (stderr, "FindStar x=1-%d, %d-%d set to noise\n",
findstar.c:		 xborder1, w-xborder2+1, w);
findstar.c:	fprintf (stderr, "FindStar y=1-%d, %d-%d set to noise\n",
findstar.c:		 yborder1, h-yborder2+1, h);
findstar.c:    lwidth = w - xborder2 - xborder1 + 1;
findstar.c:    for (y = yborder1; y < h-yborder1; y++) {
findstar.c:	/* Get one line of the image minus the noise-filled borders */
findstar.c:	nextline = (w * (y-1)) + xborder1 - 1;
findstar.c:	for (x = xborder1; x < w-xborder2; x++) {
findstar.c:		ilp = x - (nspix / 2);
findstar.c:		    idy = iya[i] - sy;
findstar.c:			idy = -idy;
findstar.c:			idx = ixa[i] - sx;
findstar.c:			    idx = -idx;
findstar.c:		    (*xa)[nstars-1] = xai;
findstar.c:		    (*ya)[nstars-1] = yai;
findstar.c:		    ixa[nstars-1] = (int) (xai + 0.5);
findstar.c:		    iya[nstars-1] = (int) (yai + 0.5);
findstar.c:		    (*pa)[nstars-1] = (int) b;
findstar.c:		/* Outermost 1-pixel radial band is one sigma above background */
findstar.c:		    (*ba)[nstars-1] = bai;
findstar.c:			fprintf (stderr," %d: (%d %d) -> (%7.3f %7.3f)",
findstar.c:			fprintf (stderr," %8.1f -> %10.1f  %d -> %d    ",
findstar.c:	    *flux = -2.5 * log10 (*flux);
findstar.c: * If any are greater than pixel at x/y then return -1.
findstar.c:    pix1 = getpix (image,bitpix,w,h,bz,bs,x-1,y-1);
findstar.c:    pix2 = getpix (image,bitpix,w,h,bz,bs,x,y-1);
findstar.c:    pix3 = getpix (image,bitpix,w,h,bz,bs,x+1,y-1);
findstar.c:	return (-1);
findstar.c:    pix1 = getpix (image,bitpix,w,h,bz,bs,x-1,y+1);
findstar.c:	return (-1);
findstar.c:    pix1 = getpix (image,bitpix,w,h,bz,bs,x-1,y-1);
findstar.c:    pix2 = getpix (image,bitpix,w,h,bz,bs,x-1,y);
findstar.c:    pix3 = getpix (image,bitpix,w,h,bz,bs,x-1,y+1);
findstar.c:	return (-1);
findstar.c:    pix1 = getpix (image,bitpix,w,h,bz,bs,x+1,y-1);
findstar.c:	return (-1);
findstar.c:    pix1 = getpix (image,bitpix,w,h,bz,bs,x-1,y);
findstar.c:	return (-1);
findstar.c:    pix1 = getpix (image,bitpix,w,h,bz,bs,x,y-1);
findstar.c:	return (-1);
findstar.c:     * Scan in ever-greater circles until find one such that the mean at
findstar.c:	for (y = -r; y <= r; y++) { 
findstar.c:	    for (x = -r; x <= r; x++) {
findstar.c:	mean = (sum / np) - background;
findstar.c:    /* Find maximum of best-fit parabola in each direction.
findstar.c:    p1 = getpix (imp,bitpix,w,h,bz,bs,x0-1,y0);
findstar.c:    d = p3 - p22 + p1;
findstar.c:    *xp = (d == 0) ? x0 : x0 + 0.5 - (p3 - p2)/d;
findstar.c:    p1 = getpix (imp,bitpix,w,h,bz,bs,x0,y0-1);
findstar.c:    d = p3 - p22 + p1;
findstar.c:    *yp = (d == 0) ? y0 : y0 + 0.5 - (p3 - p2)/d;
findstar.c: * Return 0 if brightest pixel found within maxsteps, else -1 */
findstar.c:static int dx[8]={1,0,-1,1,-1,1,0,-1};
findstar.c:static int dy[8]={1,1,1,0,0,-1,-1,-1};
findstar.c:	if (abs(x-x0) > maxr || abs(y-y0) > maxr)
findstar.c:	    return (-1);
findstar.c:    pmin = -1.0e20;
findstar.c:		    sum += fabs (p - pmean);
findstar.c:	pmin = pmean - sd * starsig;
findstar.c:    pmin = -1.0e20;
findstar.c:    /* Iterate with sigma-clipping */
findstar.c:		sum += fabs (p - pmean);
findstar.c:	pmin = pmean - (sd * starsig);
findstar.c:    x1 = -r;
findstar.c:    if (x0-r < 0)
findstar.c:    y1 = -r;
findstar.c:    if (y0-r < 0)
findstar.c:		    sum += dp - background;
findstar.c:	rotate = rotate - 360;
findstar.c:    if (rotate < 45.0 && rotate > -45.0) {
findstar.c:	    x2 = xn - x1 - 1.0;
findstar.c:	    y2 = yn - y1 - 1.0;
findstar.c:	    x2 = yn - y1 - 1.0;
findstar.c:	    y2 = xn - x1 - 1.0;
findstar.c:	    x2 = yn - y1 - 1.0;
findstar.c:	    y2 = yn - y1 - 1.0;
findstar.c:	    x2 = xn - x1 - 1.0;
findstar.c:	    x2 = xn - x1 - 1.0;
findstar.c:	    y2 = yn - y1 - 1.0;
findstar.c:	    x2 = yn - y1 - 1.0;
findstar.c:	    y2 = xn - x1 - 1.0;
findstar.c:	    y2 = xn - x1 - 1.0;
findstar.c: * Jul 30 1998	Deal with too-small sigmas
findstar.c: * Jan 23 2003	Add setminpmqual() to setparm() for USNO-B1.0
findstar.c: * Jan 29 2003	Add setminid() to setparm() for USNO-B1.0
findstar.c: * Jun  2 2003	Fix bug to setcale(0) if bscale == 1, not 0 (J-B Marquette)
fitsfile1.h: *** Harvard-Smithsonian Center for Astrophysics
fitsfile1.h: *** Copyright (C) 1996-2007
fitsfile1.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fitsfile1.h:			 * Return file descriptor (-1 if unsuccessful) */
fitsfile1.h:    double getpix(	/* Read one pixel from any data type 2-D array (0,0)*/
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:			 *  16 = short, -16 = unsigned short, 32 = int
fitsfile1.h:			 * -32 = float, -64 = double */
fitsfile1.h:	int x,		/* Zero-based horizontal pixel number */
fitsfile1.h:	int y);		/* Zero-based vertical pixel number */
fitsfile1.h:    double getpix1(	/* Read one pixel from any data type 2-D array (1,1)*/
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	int x,		/* One-based horizontal pixel number */
fitsfile1.h:	int y);		/* One-based vertical pixel number */
fitsfile1.h:    void putpix(	/* Write one pixel to any data type 2-D array (0,0)*/
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	int x,		/* Zero-based horizontal pixel number */
fitsfile1.h:	int y,		/* Zero-based vertical pixel number */
fitsfile1.h:    void putpix1(	/* Write one pixel to any data type 2-D array (1,1) */
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	int x,		/* One-based horizontal pixel number */
fitsfile1.h:	int y,		/* One-based vertical pixel number */
fitsfile1.h:    void addpix(	/* Add to one pixel in any data type 2-D array (0,0)*/
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	int x,		/* Zero-based horizontal pixel number */
fitsfile1.h:	int y,		/* Zero-based vertical pixel number */
fitsfile1.h:    void addpix1(	/* Add to one pixel in any data type 2-D array (1,1)*/
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	int x,		/* One-based horizontal pixel number */
fitsfile1.h:	int y,		/* One-based vertical pixel number */
fitsfile1.h:    void movepix(	/* Move one pixel value between two 2-D arrays (0,0) */
fitsfile1.h:	int x1, y1);	/* Zero-based row and column for input pixel */
fitsfile1.h:	int x2, y2);	/* Zero-based row and column for output pixel */
fitsfile1.h:    void movepix1(	/* Move one pixel value between two 2-D arrays (1,1) */
fitsfile1.h:	int x1, y1);	/* One-based row and column for input pixel */
fitsfile1.h:	int x2, y2);	/* One-based row and column for output pixel */
fitsfile1.h:    void addvec(	/* Add constant to vector from 2-D array */
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:    void multvec(	/* Multiply vector from 2-D array by a constant */
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:    void getvec(	/* Read vector from 2-D array */
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:    void putvec(	/* Write vector into 2-D array */
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	int pix1,	/* Zero-based offset of first pixel to multiply */
fitsfile1.h:	char *image,	/* Image array as 1-D vector */
fitsfile1.h:	int pix1,	/* One-based offset of first pixel to multiply */
fitsfile1.h:/* Image pixel byte-swapping subroutines in imio.c */
fitsfile1.h:    void imswap2(	/* Swap bytes in a vector of 2-byte (short) integers */
fitsfile1.h:    void imswap4(	/* Reverse bytes in a vector of 4-byte numbers */
fitsfile1.h:    void imswap8(	/* Reverse bytes in a vector of 8-byte numbers */
fitsfile1.h:    int doy2tsi(	/* year and day of year to IRAF seconds since 1980-01-01 */
fitsfile1.h:    time_t doy2tsu(	/* year and day of year to Unix seconds since 1970-01-01 */
fitsfile1.h:			 * if time<0, it is time as -(fraction of a day)
fitsfile1.h:    int dt2tsi(		/* yyyy.ddmm and hh.mmsss to IRAF seconds since 1980-01-01 */
fitsfile1.h:    time_t dt2tsu(	/* yyyy.ddmm and hh.mmsss to Unix seconds since 1970-01-01 */
fitsfile1.h:	double  epoch,  /* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:	double  epoch,  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:    char *ep2fd(	/* Fractional year to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile1.h:    char *epb2fd(	/* Besselian epoch to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile1.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:    char *epj2fd(	/* Julian epoch to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile1.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:	double  epoch,	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:	double  epoch,  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:	double  epoch);  /* Besselian epoch (fractional 365.242198781-day years) */
fitsfile1.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile1.h:			 * dd-mm-yy (nonstandard use before 2000)
fitsfile1.h:			 * yyyy-mm-dd (FITS standard after 1999)
fitsfile1.h:			 * yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
fitsfile1.h:    double fd2ts(	/* FITS standard date to seconds since 1950-01-01 */
fitsfile1.h:    int fd2tsi(		/* FITS standard date to IRAF seconds since 1980-01-01 */
fitsfile1.h:    time_t fd2tsu(	/* FITS standard date to Unix seconds since 1970-01-01 */
fitsfile1.h:    char *jd2fd(	/* Julian Day to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile1.h:    time_t jd2tsu( /* Julian Day to Unix seconds since 1970-01-01T00:00 */
fitsfile1.h:    int jd2tsi( /* Julian Day to IRAF seconds since 1980-01-01T00:00 */
fitsfile1.h:    int lt2tsi();	/* Current local time to IRAF seconds since 1980-01-01T00:00 */
fitsfile1.h:    time_t lt2tsu();	/* Current local time to Unix seconds since 1970-01-01T00:00 */
fitsfile1.h:    double lt2ts();	/* Current local time to IRAF seconds since 1950-01-01T00:00 */
fitsfile1.h:    /* Convert from Modified Julian Day (JD - 2400000.5) */
fitsfile1.h:    char *mjd2fd(	/* Modified Julian Day to FITS date yyyy-mm-ddThh:mm:ss.ss */
fitsfile1.h:    /* Convert from seconds since 1950-01-01 0:00 (JPL Ephemeris time) */
fitsfile1.h:    char *ts2fd(	/* Seconds since 1950.0 to FITS date, yyyy-mm-ddT00:00:00.000 */
fitsfile1.h:    /* Convert from IRAF time (seconds since 1980-01-01 0:00 UT) */
fitsfile1.h:    char *tsi2fd(	/* Seconds since 1980-01-01 to FITS standard date string */
fitsfile1.h:    double tsi2ts( /* Seconds since 1980-01-01 to seconds since 1950-01-01 */
fitsfile1.h:    double tsi2ts( /* Seconds since 1980-01-01 to seconds since 1950-01-01 */
fitsfile1.h:    void tsi2dt( /* Seconds since 1980-01-01 to date yyyy.mmdd, time hh.mmssss */
fitsfile1.h:    /* Convert from Unix time (seconds since 1970-01-01 0:00 UT) */
fitsfile1.h:    void tsu2dt(	/* Seconds since 1970-01-01 to date yyyy.ddmm, time hh.mmsss */
fitsfile1.h:    char *tsu2fd(	/* Seconds since 1970-01-01 to FITS standard date string */
fitsfile1.h:    double tsu2ts( /* Seconds since 1970-01-01 to seconds since 1950-01-01 */
fitsfile1.h:    int tsu2tsi(	/* Seconds since 1970-01-01 to local seconds since 1980-01-01 */
fitsfile1.h:    int ut2tsi(	/* Current UT to IRAF seconds since 1980-01-01T00:00 */
fitsfile1.h:    time_t ut2tsu(	/* Current UT to Unix seconds since 1970-01-01T00:00 */
fitsfile1.h:    double ut2ts( /* Current UT to IRAF seconds since 1950-01-01T00:00 */
fitsfile1.h:			 *if time<0, it is time as -(fraction of a day) */
fitsfile1.h:    double ets2ts(	/* ET in seconds since 1950-01-01 to UT in same format */
fitsfile1.h:	double tsec);	/* ET in seconds since 1950-01-01 */
fitsfile1.h:    double ts2ets(	/* UT in seconds since 1950-01-01 to ET in same format */
fitsfile1.h:	double tsec);	/* UT in seconds since 1950-01-01 */
fitsfile1.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile1.h:    double utdt(	/* Compute difference between UT and dynamical time (ET-UT) */
fitsfile1.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile1.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile1.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile1.h:	char *string);	/* UT Date, LST as yyyy-mm-ddShh:mm:ss.ss */
fitsfile1.h:	char *string);	/* UT Date, GST as yyyy-mm-ddShh:mm:ss.ss */
fitsfile1.h:	char *string);	/* UT Date, MST as yyyy-mm-ddShh:mm:ss.ss */
fitsfile.c: *** Harvard-Smithsonian Center for Astrophysics
fitsfile.c: *** Copyright (C) 1996-2014
fitsfile.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fitsfile.c:/* FITSRHEAD -- Read a FITS header */
fitsfile.c:			   (0=primary -1=first with data -2=use EXTNAME) */
fitsfile.c:	fd = -1;
fitsfile.c:	extnum = -1;
fitsfile.c:	    extnum = -2;
fitsfile.c:	extnum = -1;
fitsfile.c:    /* Repair the damage done to the file-name string during parsing */
fitsfile.c:    			if (extnum != -1 && !extfound) {
fitsfile.c:		nbh0 = nbh - 4;
fitsfile.c:		    newhead[nbh-3] = (char) 0;
fitsfile.c:		    headnext = header + ((nrec-1) * FITSBLOCK);
fitsfile.c:		lprim = headend + 80 - header;
fitsfile.c:	    if (naxis < 1 && extnum == -1) {
fitsfile.c:	    else if (extnum != -1) {
fitsfile.c:		if (extnum > -1 && hdu == extnum) {
fitsfile.c:			nbpix = -ibpix / 8;
fitsfile.c:    if (extnum != -1 && !extfound) {
fitsfile.c:	lext = headend - header;
fitsfile.c:	lprim = pheadend + 320 - pheader;
fitsfile.c:	hputs (header,"COMMENT","-------------------------------------------");
fitsfile.c:	hputs (header,"COMMENT","-------------------------------------------");
fitsfile.c:    ibhead = *nbhead - ibhead;
fitsfile.c:/* FITSRTAIL -- Read FITS header appended to graphics file */
fitsfile.c:	fd = -1;
fitsfile.c:    /* Repair the damage done to the file-name string during parsing */
fitsfile.c:	offset = lseek (fd, -nbytes, SEEK_END);
fitsfile.c:		ndiff = headstart - header;
fitsfile.c:		for (i = 0; i < nbytes-ndiff; i++)
fitsfile.c:/* FITSRSECT -- Read a piece of a FITS image, having already read the header */
fitsfile.c:	fd = -1;
fitsfile.c:    if (bytepix < 0) bytepix = -bytepix;
fitsfile.c:    x1 = x0 + nx - 1;
fitsfile.c:    nx = x1 - x0 + 1;
fitsfile.c:    y1 = y0 + ny - 1;
fitsfile.c:    ny = y1 - y0 + 1;
fitsfile.c:    /* Set number of bytes to integral number of 2880-byte blocks */
fitsfile.c:    impos = ((y0 - 1) * nblin) + ((x0 - 1) * bytepix);
fitsfile.c:    row = y0 - 1;
fitsfile.c:    while (nyleft-- > 0) {
fitsfile.c:	    impos = nblin - nbread;
fitsfile.c:    /* Byte-reverse image, if necessary */
fitsfile.c:/* FITSRIMAGE -- Read a FITS image */
fitsfile.c:	fd = -1;
fitsfile.c:    /* If SIMPLE=F in header, simply put post-header part of file in buffer */
fitsfile.c:	nbytes = getfilesize (filename) - nbhead;
fitsfile.c:	    /* snprintf (fitserrmsg,79, "FITSRIMAGE:  %d-byte image buffer cannot be allocated\n"); */
fitsfile.c:    if (bytepix < 0) bytepix = -bytepix;
fitsfile.c:    /* If either dimension is one and image is 3-D, read all three dimensions */
fitsfile.c:    /* Set number of bytes to integral number of 2880-byte blocks */
fitsfile.c:	    nbleft = nbleft - nbread;
fitsfile.c:    /* Byte-reverse image, if necessary */
fitsfile.c:/* FITSRFULL -- Read a FITS image of any dimension */
fitsfile.c:	fd = -1;
fitsfile.c:    /* If SIMPLE=F in header, simply put post-header part of file in buffer */
fitsfile.c:	nbytes = getfilesize (filename) - nbhead;
fitsfile.c:	    snprintf (fitserrmsg,79, "FITSRFULL:  %d-byte image buffer cannot be allocated\n",nbytes+1);
fitsfile.c:    if (bytepix < 0) bytepix = -bytepix;
fitsfile.c:    /* Set number of bytes to integral number of 2880-byte blocks */
fitsfile.c:	    nbleft = nbleft - nbread;
fitsfile.c:    /* Byte-reverse image, if necessary */
fitsfile.c:/* FITSROPEN -- Open a FITS file, returning the file descriptor */
fitsfile.c:	    return (-1);
fitsfile.c:/* FITSRTOPEN -- Open FITS table file and fill structure with
fitsfile.c: *		 Return file descriptor (-1 if unsuccessful)
fitsfile.c:	    return (-1);
fitsfile.c:/* FITSRTHEAD -- From FITS table header, read pointers to selected keywords */
fitsfile.c:	return (-1);
fitsfile.c:	return (-1);
fitsfile.c:	return (-1);
fitsfile.c:	    return (-1);
fitsfile.c:	    return (-1);
fitsfile.c:	if (tform[ltform-1] == 'A') {
fitsfile.c:	    for (i = 0; i < ltform-1; i++)
fitsfile.c:	    ifield = rw[ik].kn - 1;
fitsfile.c:	rw[ik].kf = pw[ifield].kf - 1;
fitsfile.c:    offend = offset + nbline - 1;
fitsfile.c:	offset2 = offset + nbr - 1;
fitsfile.c:	tbuff1 = tbuff + (offset - offset1);
fitsfile.c:/* FTGETI2 -- Extract n'th column from FITS table line as short */
fitsfile.c:	if (!strcmp (kw->kform, "I"))
fitsfile.c:	else if (!strcmp (kw->kform, "J")) {
fitsfile.c:	else if (!strcmp (kw->kform, "E")) {
fitsfile.c:	else if (!strcmp (kw->kform, "D")) {
fitsfile.c:/* FTGETI4 -- Extract n'th column from FITS table line as int */
fitsfile.c:	if (!strcmp (kw->kform, "I")) {
fitsfile.c:	else if (!strcmp (kw->kform, "J"))
fitsfile.c:	else if (!strcmp (kw->kform, "E")) {
fitsfile.c:	else if (!strcmp (kw->kform, "D")) {
fitsfile.c:/* FTGETR4 -- Extract n'th column from FITS table line as float */
fitsfile.c:	if (!strcmp (kw->kform, "I")) {
fitsfile.c:	else if (!strcmp (kw->kform, "J")) {
fitsfile.c:	else if (!strcmp (kw->kform, "E"))
fitsfile.c:	else if (!strcmp (kw->kform, "D")) {
fitsfile.c:/* FTGETR8 -- Extract n'th column from FITS table line as double */
fitsfile.c:	if (!strcmp (kw->kform, "I")) {
fitsfile.c:	else if (!strcmp (kw->kform, "J")) {
fitsfile.c:	else if (!strcmp (kw->kform, "E")) {
fitsfile.c:	else if (!strcmp (kw->kform, "D"))
fitsfile.c:/* FTGETC -- Extract n'th column from FITS table line as character string */
fitsfile.c:    if (kw->kl < length)
fitsfile.c:	length = kw->kl;
fitsfile.c:	strncpy (string, entry+kw->kf, length);
fitsfile.c:/*FITSWIMAGE -- Write FITS header and image */
fitsfile.c:/*FITSWEXT -- Write FITS header and image as extension to a file */
fitsfile.c:/* FITSWHDU -- Write FITS head and image as extension */
fitsfile.c:    /* Change BITPIX=-16 files to BITPIX=16 with BZERO and BSCALE */
fitsfile.c:    if (bitpix == -16) {
fitsfile.c:    nbhead = endhead - header;
fitsfile.c:    /* Write extra spaces to make an integral number of 2880-byte blocks */
fitsfile.c:    nbpad = nbytes - nbhead;
fitsfile.c:	if (bytepix < 0) bytepix = -bytepix;
fitsfile.c:	/* Byte-reverse image before writing, if necessary */
fitsfile.c:    /* Write extra zeroes to make an integral number of 2880-byte blocks */
fitsfile.c:    nbpad = nbytes - nbimage;
fitsfile.c:    /* Byte-reverse image after writing, if necessary */
fitsfile.c:/*FITSCIMAGE -- Write FITS header and copy FITS image
fitsfile.c:    if (bytepix < 0) bytepix = -bytepix;
fitsfile.c:    /* If either dimension is one and image is 3-D, read all three dimensions */
fitsfile.c:	fdin = -1;
fitsfile.c:    /* Write extra to make integral number of 2880-byte blocks */
fitsfile.c:    nbpad = nbytes - nbdata;
fitsfile.c:/* FITSWHEAD -- Write FITS header and keep file open for further writing */
fitsfile.c:    nbhead = endhead - header;
fitsfile.c:/* FITSWEXHEAD -- Write FITS header in place */
fitsfile.c:	return (-1);
fitsfile.c:	return (-1);
fitsfile.c:	strncpy (lasthead-80, "END", 3);
fitsfile.c:	return (-1);
fitsfile.c:	return (-1);
fitsfile.c:/* ISFITS -- Return 1 if FITS file, else 0 */
fitsfile.c:/* FITSHEADSIZE -- Find size of FITS header */
fitsfile.c:    nbhead = endhead - header;
fitsfile.c:/* MOVEB -- Copy nbytes bytes from source+offs to dest+offd (any data type) */
fitsfile.c: * Jun 12 1996	Deal with byte-swapped images
fitsfile.c: * Jan 27 1999	Pad out data to integral number of 2880-byte blocks
fitsfile.c: * Apr 29 1999	Write BITPIX=-16 files as BITPIX=16 with BSCALE and BZERO
fitsfile.c: * Apr 30 1999	Add % as alternative to , to denote sub-images
fitsfile.c: * Aug 20 2003	Add fitsrfull() to read n-dimensional FITS images
fitsfile.c: * Aug 21 2003	Modify fitswimage() to always write n-dimensional FITS images
fitsfile.c: * Aug  8 2005	Fix space-padding bug in fitswexhead() found by Armin Rest
fitsfile.c: * Feb 27 2006	Add file name to header-reading error messages
fitsfile.h: *** Harvard-Smithsonian Center for Astrophysics
fitsfile.h: *** Copyright (C) 1996-2014
fitsfile.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fitsfile.h:			 * Return file descriptor (-1 if unsuccessful) */
fitsfile.h:    double getpix(	/* Read one pixel from any data type 2-D array (0,0)*/
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:			 *  16 = short, -16 = unsigned short, 32 = int
fitsfile.h:			 * -32 = float, -64 = double */
fitsfile.h:	int x,		/* Zero-based horizontal pixel number */
fitsfile.h:	int y);		/* Zero-based vertical pixel number */
fitsfile.h:    double getpix1(	/* Read one pixel from any data type 2-D array (1,1)*/
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	int x,		/* One-based horizontal pixel number */
fitsfile.h:	int y);		/* One-based vertical pixel number */
fitsfile.h:    void putpix(	/* Write one pixel to any data type 2-D array (0,0)*/
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	int x,		/* Zero-based horizontal pixel number */
fitsfile.h:	int y,		/* Zero-based vertical pixel number */
fitsfile.h:    void putpix1(	/* Write one pixel to any data type 2-D array (1,1) */
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	int x,		/* One-based horizontal pixel number */
fitsfile.h:	int y,		/* One-based vertical pixel number */
fitsfile.h:    void addpix(	/* Add to one pixel in any data type 2-D array (0,0)*/
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	int x,		/* Zero-based horizontal pixel number */
fitsfile.h:	int y,		/* Zero-based vertical pixel number */
fitsfile.h:    void addpix1(	/* Add to one pixel in any data type 2-D array (1,1)*/
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	int x,		/* One-based horizontal pixel number */
fitsfile.h:	int y,		/* One-based vertical pixel number */
fitsfile.h:    void movepix(	/* Move one pixel value between two 2-D arrays (0,0) */
fitsfile.h:	int x1,		/* Zero-based row for input pixel */
fitsfile.h:	int y1,		/* Zero-based column for input pixel */
fitsfile.h:	int x2,		/* Zero-based row for output pixel */
fitsfile.h:	int y2);	/* Zero-based column for output pixel */
fitsfile.h:    void movepix1(	/* Move one pixel value between two 2-D arrays (1,1) */
fitsfile.h:	int x1,		/* One-based row for input pixel */
fitsfile.h:	int y1,		/* One-based column for input pixel */
fitsfile.h:	int x2,		/* One-based row for output pixel */
fitsfile.h:	int y2);	/* One-based column for output pixel */
fitsfile.h:    void addvec(	/* Add constant to vector from 2-D array */
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:    void multvec(	/* Multiply vector from 2-D array by a constant */
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:    void getvec(	/* Read vector from 2-D array */
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:    void putvec(	/* Write vector into 2-D array */
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	int pix1,	/* Zero-based offset of first pixel to multiply */
fitsfile.h:	char *image,	/* Image array as 1-D vector */
fitsfile.h:	int pix1,	/* One-based offset of first pixel to multiply */
fitsfile.h:/* Image pixel byte-swapping subroutines in imio.c */
fitsfile.h:    void imswap2(	/* Swap bytes in a vector of 2-byte (short) integers */
fitsfile.h:    void imswap4(	/* Reverse bytes in a vector of 4-byte numbers */
fitsfile.h:    void imswap8(	/* Reverse bytes in a vector of 8-byte numbers */
fitsfile.h:			 * if <0, get whole string after token -itok
fitsfile.h:    int doy2tsi(	/* year and day of year to IRAF seconds since 1980-01-01 */
fitsfile.h:    time_t doy2tsu(	/* year and day of year to Unix seconds since 1970-01-01 */
fitsfile.h:			 * if time<0, it is time as -(fraction of a day)
fitsfile.h:    int dt2tsi(		/* yyyy.ddmm and hh.mmsss to IRAF seconds since 1980-01-01 */
fitsfile.h:    time_t dt2tsu(	/* yyyy.ddmm and hh.mmsss to Unix seconds since 1970-01-01 */
fitsfile.h:	double  epoch,  /* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:	double  epoch,  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:    char *ep2fd(	/* Fractional year to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:    char *epb2fd(	/* Besselian epoch to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:    char *epj2fd(	/* Julian epoch to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:	double  epoch,	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:	double  epoch,  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:	double  epoch);	/* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:	double  epoch);  /* Besselian epoch (fractional 365.242198781-day years) */
fitsfile.h:	double  epoch);  /* Julian epoch (fractional 365.25-day years) */
fitsfile.h:			 * dd-mm-yy (nonstandard use before 2000)
fitsfile.h:			 * yyyy-mm-dd (FITS standard after 1999)
fitsfile.h:			 * yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
fitsfile.h:    double fd2ts(	/* FITS standard date to seconds since 1950-01-01 */
fitsfile.h:    int fd2tsi(		/* FITS standard date to IRAF seconds since 1980-01-01 */
fitsfile.h:    time_t fd2tsu(	/* FITS standard date to Unix seconds since 1970-01-01 */
fitsfile.h:    char *jd2fd(	/* Julian Day to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:    time_t jd2tsu( /* Julian Day to Unix seconds since 1970-01-01T00:00 */
fitsfile.h:    int jd2tsi( /* Julian Day to IRAF seconds since 1980-01-01T00:00 */
fitsfile.h:    int lt2tsi(void);	/* Current local time to IRAF seconds since 1980-01-01T00:00 */
fitsfile.h:    time_t lt2tsu(void); /* Current local time to Unix seconds since 1970-01-01T00:00 */
fitsfile.h:    double lt2ts(void);	/* Current local time to IRAF seconds since 1950-01-01T00:00 */
fitsfile.h:    /* Convert from Modified Julian Day (JD - 2400000.5) */
fitsfile.h:    char *mjd2fd(	/* Modified Julian Day to FITS date yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:    /* Convert from seconds since 1950-01-01 0:00 (JPL Ephemeris time) */
fitsfile.h:    char *ts2fd(	/* Seconds since 1950.0 to FITS date, yyyy-mm-ddT00:00:00.000 */
fitsfile.h:    /* Convert from IRAF time (seconds since 1980-01-01 0:00 UT) */
fitsfile.h:    char *tsi2fd(	/* Seconds since 1980-01-01 to FITS standard date string */
fitsfile.h:	int isec);	/* Seconds past 1980-01-01 */
fitsfile.h:    double tsi2ts( /* Seconds since 1980-01-01 to seconds since 1950-01-01 */
fitsfile.h:	int isec);	/* Seconds past 1980-01-01 */
fitsfile.h:    void tsi2dt(	/* Seconds since 1980-01-01 to date yyyy.mmdd, time hh.mmssss */
fitsfile.h:	int isec,	/* Seconds past 1980-01-01 */
fitsfile.h:    /* Convert from Unix time (seconds since 1970-01-01 0:00 UT) */
fitsfile.h:    void tsu2dt(	/* Seconds since 1970-01-01 to date yyyy.ddmm, time hh.mmsss */
fitsfile.h:	time_t isec,	/* Seconds past 1970-01-01 */
fitsfile.h:    char *tsu2fd(	/* Seconds since 1970-01-01 to FITS standard date string */
fitsfile.h:	time_t isec);	/* Seconds past 1970-01-01 */
fitsfile.h:    double tsu2ts( /* Seconds since 1970-01-01 to seconds since 1950-01-01 */
fitsfile.h:	time_t isec);	/* Seconds past 1970-01-01 */
fitsfile.h:    int tsu2tsi(	/* Seconds since 1970-01-01 to local seconds since 1980-01-01 */
fitsfile.h:	time_t isec);	/* Seconds past 1970-01-01 */
fitsfile.h:    int ut2tsi(void);	/* Current UT to IRAF seconds since 1980-01-01T00:00 */
fitsfile.h:    time_t ut2tsu(void); /* Current UT to Unix seconds since 1970-01-01T00:00 */
fitsfile.h:    double ut2ts(void);	/* Current UT to seconds since 1950-01-01T00:00 */
fitsfile.h:			 *  dd-mm-yy (nonstandard FITS use before 2000)
fitsfile.h:			 *  yyyy-mm-dd (FITS standard after 1999)
fitsfile.h:			 *  yyyy-mm-ddThh:mm:ss.ss (FITS standard after 1999) */
fitsfile.h:			 *if time<0, it is time as -(fraction of a day) */
fitsfile.h:    double ets2ts(	/* ET in seconds since 1950-01-01 to UT in same format */
fitsfile.h:	double tsec);	/* ET in seconds since 1950-01-01 */
fitsfile.h:    double ts2ets(	/* UT in seconds since 1950-01-01 to ET in same format */
fitsfile.h:	double tsec);	/* UT in seconds since 1950-01-01 */
fitsfile.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile.h:    double utdt(	/* Compute difference between UT and dynamical time (ET-UT) */
fitsfile.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile.h:			 * If time<0, it is time as -(fraction of a day) */
fitsfile.h:	char *string);	/* UT Date, LST as yyyy-mm-ddShh:mm:ss.ss */
fitsfile.h:	char *string);	/* UT Date, GST as yyyy-mm-ddShh:mm:ss.ss */
fitsfile.h:	char *string);	/* UT Date, MST as yyyy-mm-ddShh:mm:ss.ss */
fitsfile.h:extern double getpix();	/* Read one pixel from any data type 2-D array (0,0)*/
fitsfile.h:extern double getpix1(); /* Read one pixel from any data type 2-D array (1,1)*/
fitsfile.h:extern void putpix();	/* Write one pixel to any data type 2-D array (0,0)*/
fitsfile.h:extern void putpix1();	/* Write one pixel to any data type 2-D array (1,1) */
fitsfile.h:extern void addpix();	/* Add to one pixel in any data type 2-D array (0,0)*/
fitsfile.h:extern void addpix1();	/* Add to one pixel in any data type 2-D array (1,1)*/
fitsfile.h:extern void movepix();	/* Move one pixel value between two 2-D arrays (0,0) */
fitsfile.h:extern void movepix1();	/* Move one pixel value between two 2-D arrays (1,1) */
fitsfile.h:extern void addvec();	/* Add constant to vector from 2-D array */
fitsfile.h:extern void multvec();	/* Multiply vector from 2-D array by a constant */
fitsfile.h:extern void getvec();	/* Read vector from 2-D array */
fitsfile.h:extern void putvec();	/* Write vector into 2-D array */
fitsfile.h:extern void imswap2();	/* Swap bytes in a vector of 2-byte (short) integers */
fitsfile.h:extern void imswap4();	/* Reverse bytes in a vector of 4-byte numbers */
fitsfile.h:extern void imswap8();	/* Reverse bytes in a vector of 8-byte numbers */
fitsfile.h:int doy2tsi();	/* year and day of year to IRAF seconds since 1980-01-01 */
fitsfile.h:time_t doy2tsu();	/* year and day of year to Unix seconds since 1970-01-01 */
fitsfile.h:int dt2tsi();	/* yyyy.ddmm and hh.mmsss to IRAF seconds since 1980-01-01 */
fitsfile.h:time_t dt2tsu();	/* yyyy.ddmm and hh.mmsss to Unix seconds since 1970-01-01 */
fitsfile.h:char *ep2fd();	/* Fractional year to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:char *epb2fd();	/* Besselian epoch to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:char *epj2fd();	/* Julian epoch to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:double fd2ts();	/* FITS standard date to seconds since 1950-01-01 */
fitsfile.h:int fd2tsi();	/* FITS standard date to IRAF seconds since 1980-01-01 */
fitsfile.h:time_t fd2tsu();	/* FITS standard date to Unix seconds since 1970-01-01 */
fitsfile.h:char *jd2fd();	/* Julian date to FITS date string yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:time_t jd2tsu(); /* Julian date to Unix seconds since 1970-01-01T00:00 */
fitsfile.h:int jd2tsi(); /* Julian date to IRAF seconds since 1980-01-01T00:00 */
fitsfile.h:int lt2tsi();	/* Current local time to IRAF seconds since 1980-01-01T00:00 */
fitsfile.h:time_t lt2tsu(); /* Current local time to Unix seconds since 1970-01-01T00:00 */
fitsfile.h:double lt2ts(); /* Current local time to IRAF seconds since 1950-01-01T00:00 */
fitsfile.h:char *mjd2fd();	/* Modified Julian date to FITS date yyyy-mm-ddThh:mm:ss.ss */
fitsfile.h:char *ts2fd();	/* Seconds since 1950.0 to FITS date, yyyy-mm-ddT00:00:00.000 */
fitsfile.h:char *tsi2fd();	/* Seconds since 1980-01-01 to FITS standard date string */
fitsfile.h:double tsi2ts(); /* Seconds since 1980-01-01 to seconds since 1950-01-01 */
fitsfile.h:double tsi2ts(); /* Seconds since 1980-01-01 to seconds since 1950-01-01 */
fitsfile.h:void tsi2dt(); /* Seconds since 1980-01-01 to date yyyy.mmdd, time hh.mmssss */
fitsfile.h:void tsu2dt();	/* Seconds since 1970-01-01 to date yyyy.ddmm, time hh.mmsss */
fitsfile.h:char *tsu2fd();	/* Seconds since 1970-01-01 to FITS standard date string */
fitsfile.h:double tsu2ts(); /* Seconds since 1970-01-01 to seconds since 1950-01-01 */
fitsfile.h:int tsu2tsi();	/* Seconds since 1970-01-01 to local seconds since 1980-01-01 */
fitsfile.h:int ut2tsi();	/* Current UT to IRAF seconds since 1980-01-01T00:00 */
fitsfile.h:time_t ut2tsu();	/* Current UT to Unix seconds since 1970-01-01T00:00 */
fitsfile.h:double ut2ts(); /* Current UT to IRAF seconds since 1950-01-01T00:00 */
fitsfile.h:double ets2ts(); /* ET in seconds since 1950-01-01 to UT in same format */
fitsfile.h:double ts2ets(); /* UT in seconds since 1950-01-01 to ET in same format */
fitsfile.h:double utdt();	/* Compute difference between UT and dynamical time (ET-UT) */
fitsfile.h: * Jun 12 1996	Add byte-swapping subroutines
fitsfile.h: * Sep 28 1999	Add (1,1)-based image access subroutines
fitsfile.h: * Jan 26 2000	Add conversion to modified Julian date (JD - 2400000.5
fitsfile.h: * Aug 20 2003	Add fitsrfull() to read n-dimensional simple FITS images
fitshead.h: *** Harvard-Smithsonian Center for Astrophysics
fitshead.h: *** Copyright (C) 1996-2007
fitshead.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fitshead.h:	const char* wchar,	/* WCS to use (A-Z or null) */
fitshead.h:	const char* wchar,	/* WCS to use (A-Z or null) */
fitshead.h:	const char* wchar,	/* WCS to use (A-Z or null) */
fitshead.h:	char* string);		/* null-terminated string value (returned) */
fitshead.h:	char* string);		/* null-terminated string value (returned) */
fitshead.h:	char* string);		/* null-terminated string value (returned) */
fitshead.h:    char *getutime(void);	/* Return current UT as an ISO-format string */
fitshead.h:	char* string);		/* null-terminated string value (returned) */
fitshead.h:	char* string);		/* null-terminated string value (returned) */
fitshead.h:/* All hput* routines return 0 if successful, else -1 */
fitshead.h:	const int lval);	/* 0->F, else ->T */
fitshead.h:extern int hgetl();	/* T->1, F->0 from FITS logical entry */
fitshead.h:extern char *strsrch ();	/* s1 null-terminated */
fitshead.h:extern char *strcsrch ();	/* s1 null-terminated (case-insensitive) */
fitshead.h:extern char *strncsrch ();	/* s1 ls1 characters long (case-insensitive) */
fitshead.h:/* Set length of header which is not null-terminated */
fitshead.h:extern int hputl();	/* 0 -> F, else T FITS logical entry */
fitshead.h:extern char *getutime(); /* Return current UT as an ISO-format string */
fitshead.h: * Jun 12 1996	Add byte-swapping subroutines
fitshead.h: * Aug  5 1996	Add HLENGTH for FITS headers which are not null-terminated
fitshead.h: * Aug  5 1996	Add STRNSRCH for FITS headers which are not null-terminated
fitshead.h: * May 12 1998	Add MGETS, MGETR8, MGETI4 for IRAF multi-line keywords
fitshead.h: * Oct 14 1999	All HPUT subroutines now return an error code, 0 if OK, else -1
fitshead.h: * Aug 30 2004	Add numdec() to non-C++ declarations
fitswcs.c: *** Harvard-Smithsonian Center for Astrophysics
fitswcs.c: *** Copyright (C) 1996-2011
fitswcs.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fitswcs.c: * return 0 if at least one such field is found, else -1.  */
fitswcs.c: * return 0 if all are found, else -1.
fitswcs.c:    return (n > 8 ? 0 : -1);
fitswcs.c:    if (wcs->xref < 0)
fitswcs.c:	wcs->xref = 360.0 + wcs->xref;
fitswcs.c:    hputra (header,"RA",wcs->xref);
fitswcs.c:    hputdec (header,"DEC",wcs->yref);
fitswcs.c:    hputr8 (header, "EQUINOX", wcs->equinox);
fitswcs.c:	hputr8 (header, "EPOCH", wcs->equinox);
fitswcs.c:	hputr8 (header, "EPOCH", wcs->equinox);
fitswcs.c:    if (wcs->radecsys[0] == 'B' || wcs->radecsys[0] == 'b')
fitswcs.c:    else if (wcs->radecsys[0] == 'I' || wcs->radecsys[0] == 'i')
fitswcs.c:    else if (wcs->radecsys[0] == 'J' || wcs->radecsys[0] == 'j')
fitswcs.c:	hputs (header, "RADECSYS", wcs->radecsys);
fitswcs.c:    strcpy (wcstemp, "RA---");
fitswcs.c:    strcpy (wcstemp, "DEC--");
fitswcs.c:    hputnr8 (header, "CRVAL1", 9, wcs->xref);
fitswcs.c:    hputnr8 (header, "CRVAL2", 9, wcs->yref);
fitswcs.c:    hputnr8 (header, "CRPIX1", 4, wcs->xrefpix);
fitswcs.c:    hputnr8 (header, "CRPIX2", 4, wcs->yrefpix);
fitswcs.c:    if (wcs->rotmat) {
fitswcs.c:	hputnr8 (header, "CD1_1", 12, wcs->cd[0]);
fitswcs.c:	hputnr8 (header, "CD1_2", 12, wcs->cd[1]);
fitswcs.c:	hputnr8 (header, "CD2_1", 12, wcs->cd[2]);
fitswcs.c:	hputnr8 (header, "CD2_2", 12, wcs->cd[3]);
fitswcs.c:	hputnr8 (header, "CDELT1", 12, wcs->xinc);
fitswcs.c:	hputnr8 (header, "CDELT2", 12, wcs->yinc);
fitswcs.c:	hputnr8 (header, "CROTA1", 6, wcs->rot);
fitswcs.c:	hputnr8 (header, "CROTA2", 6, wcs->rot);
fitswcs.c:	hputnr8 (header, "CD1_1", 12, wcs->cd[0]);
fitswcs.c:	hputnr8 (header, "CD1_2", 12, wcs->cd[1]);
fitswcs.c:	hputnr8 (header, "CD2_1", 12, wcs->cd[2]);
fitswcs.c:	hputnr8 (header, "CD2_2", 12, wcs->cd[3]);
fitswcs.c:    if (-wcs->xinc != wcs->yinc) {
fitswcs.c:	hputnr8 (header, "SECPIX1", 4, -wcs->xinc*3600.0);
fitswcs.c:	hputnr8 (header, "SECPIX2", 4, wcs->yinc*3600.0);
fitswcs.c:	hputnr8 (header, "SECPIX", 6, wcs->yinc*3600.0);
fitswcs.c:    if (wcs->ncoeff1 > 0) {
fitswcs.c:	for (i = 0; i < wcs->ncoeff1; i++) {
fitswcs.c:	    hputr8 (header, keyword, wcs->x_coeff[i]);
fitswcs.c:    if (wcs->ncoeff2 > 0) {
fitswcs.c:	for (i = 0; i < wcs->ncoeff2; i++) {
fitswcs.c:	    hputr8 (header, keyword, wcs->y_coeff[i]);
fitswcs.c: * Jul 16 1996	Update arguments for header-reading subroutines
fitswcs.c: * Apr 29 2010	Fx loop index test bug i -> j in PC matrix deletion
fitswcs.h: *** Harvard-Smithsonian Center for Astrophysics
fitswcs.h: *** Copyright (C) 1996-2013
fitswcs.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fitswcs.h:    /* and return 0 if all are found, else -1 */
fortcat.c: *** Harvard-Smithsonian Center for Astrophysics
fortcat.c: *** Copyright (C) 2001-2003
fortcat.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fortcat.c: * Catalogs supported include: USNO-A2.0, USNO_SA2.0, ACT, Tycho 2, SAO
fortcat.c: * SAO TDC ASCII format, and Starbase tab-delimited format
fortcat.c: * For shell-level searches, use WCSTools scat, documented at
fortcat.c: * http://tdc-www.harvard.edu/software/wcstools/scat/
fortcat.c:/* CATREAD -- Read ASCII stars in specified region using ctgread() */
fortcat.c:double	ddec;		/* Search half-width in declination in degrees */
fortcat.c:/* CATRNUM -- Read ASCII stars with specified numbers using ctgrnum() */
fortwcs.c: *** Harvard-Smithsonian Center for Astrophysics
fortwcs.c: *** Copyright (C) 1996-2003
fortwcs.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
fortwcs.c: *		    sets a WCS structure from keyword-based arguments
fortwcs.c: *		    pixel coordinates -> sky coordinates
fortwcs.c: *		    pixels -> sky coordinate string
fortwcs.c: *		    sky coordinates -> pixel coordinates
fortwcs.c: * Copyright:   2000-2003 Smithsonian Astrophysical Observatory
fortwcs.c:    /* Set index to -1 if no WCS is found in header */
fortwcs.c:	*iwcs = -1;
fortwcs.c:int	*nxpix;		/* Number of pixels along x-axis */
fortwcs.c:int	*nypix;		/* Number of pixels along y-axis */
fortwcs.c:    /* Set index to -1 if no WCS is found in header */
fortwcs.c:	*iwcs = -1;
fortwcs.c:int	*naxis1;	/* Number of pixels along x-axis */
fortwcs.c:int	*naxis2;	/* Number of pixels along y-axis */
fortwcs.c:    /* Set index to -1 if no WCS is found in header */
fortwcs.c:	*iwcs = -1;
fortwcs.c:double	*dra;		/* Half-width in radians (returned) */
fortwcs.c:double	*ddec;		/* Half-height in radians (returned) */
fortwcs.c:	strcpy (radecsys, wcs->radecsys);
fortwcs.c:	w = w + (pos1[i] - pos2[i]) * (pos1[i] - pos2[i]);
fortwcs.c:    *diff = 2.0 * atan2 (sqrt (w), sqrt (1.0 - w));
fortwcs.c:	wcs->degout = *mode;
fortwcs.c:	wcs->linmode = *mode;
gsc2read.c: *** Harvard-Smithsonian Center for Astrophysics
gsc2read.c: *** Copyright (C) 2001-2015
gsc2read.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
gsc2read.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
gsc2read.c:/* GSC2READ -- Read GSC II catalog stars over the web */
gsc2read.c:double	ddec;		/* Search half-width in declination in degrees */
gsc2read.c:double	**gmag;		/* 2-D array of magnitudes (returned) */
gsc2read.c:	nlog = -1;
gsc2read.c:    if (tabtable->tabdata == NULL || strlen (tabtable->tabdata) == 0 ||
gsc2read.c:	!strncasecmp (tabtable->tabdata, "[EOD]", 5)) {
gsc2read.c:	(void) fwrite  (tabtable->tabbuff, tabtable->lbuff, 1, stdout);
gsc2read.c:    /* starcat->rpmunit = PM_MASYR;
gsc2read.c:    starcat->dpmunit = PM_MASYR; */
gsc2read.c:    starcat->rpmunit = 0;
gsc2read.c:    starcat->dpmunit = 0;
gsc2read.c:    starcat->coorsys = WCS_J2000;
gsc2read.c:    starcat->epoch = 2000.0;
gsc2read.c:    starcat->equinox = 2000.0;
gsc2read.c:    if (*c0 == '+' || *c0 == '-') {
gsc2read.c:    char *csvbuff;	/* Input comma-separated table */
gsc2read.c:    char *tabbuff;	/* Output tab-separated table */
gsc2read.c:    lhead = (int) (databuff - csvbuff);
gsc2read.c:    /* Allocate buffer for tab-separated table with header */
gsc2read.c:	    tabbuff[i++] = '-';
gsc2read.c:	if (lastbuff - databuff < lbuff)
gsc2read.c:    char *tsvbuff;	/* Input tab-separated table */
gsc2read.c:    char *tabbuff;	/* Output tab-separated table */
gsc2read.c:    char cdash = '-';
gsc2read.c:    /* Allocate buffer for tab-separated table with header */
gsc2read.c: * Jun 29 2001	Always set maximum magnitude to 99.9 to get Tycho-2 stars, too
gsc2read.c: * Mar 13 2007	Add gsc2c2v() to convert comma-separated input to tab-separated
gscread.c: *** Harvard-Smithsonian Center for Astrophysics
gscread.c: *** Copyright (C) 1996-2009
gscread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
gscread.c:static char cdn[64]="http://archive.eso.org/skycat/servers/gsc-server";
gscread.c:/* Pathname of northern hemisphere GSC-ACT CDROM  or search engine URL */
gscread.c:/* Pathname of southern hemisphere GSC-ACT CDROM */
gscread.c:static int classd = -1; /* Desired object class
gscread.c:			   (-2=all objects, -1=all, 0=stars, 3=nonstars) */
gscread.c:/* GSCREAD -- Read HST Guide Star Catalog stars from CDROM */
gscread.c:double	ddec;		/* Search half-width in declination in degrees */
gscread.c:	printf ("---------	------------	------------	");
gscread.c:	printf ("-----	-----	----	-	------\n");
gscread.c:		((classd < -1 && band != band0) ||
gscread.c:		(classd < -1 && class != class0) || 
gscread.c:		if (pass > 0 && classd > -1 && class != classd)
gscread.c:			CatNum (refcat, -9, 0, xnum, numstr);
gscread.c:				mag, class-(band*100)-(npos*10000), band, npos, dist);
gscread.c:     	    if ((classd > -1 && class0 == classd) ||
gscread.c:		classd < -2 || (classd < 0 && class0 != 5)) {
gscread.c:/* GSCRNUM -- Read HST Guide Star Catalog stars from CDROM */
gscread.c:	dnum = (gnum[jstar] - (double)rnum) * 10000.0;
gscread.c:/* GSCBIN -- Fill FITS WCS image with HST Guide Star Catalog objects */
gscread.c:    double ddec;	/* Search half-width in declination in degrees */
gscread.c:    int	sysout = wcs->syswcs;	/* Image coordinate system */
gscread.c:    double eqout = wcs->equinox; /* Image coordinate equinox */
gscread.c:    double epout = wcs->epoch;	/* Image epoch */
gscread.c:		((classd < -1 && band != band0) ||
gscread.c:		(classd < -1 && class != class0) || 
gscread.c:		if (pass > 0 && classd > -1 && class != classd)
gscread.c:			    flux = magscale * exp (logt * (-mag / 2.5));
gscread.c:     	    if ((classd > -1 && class0 == classd) ||
gscread.c:		classd < -2 || (classd < 0 && class0 != 5)) {
gscread.c:/* GSCREG -- search the HST Guide Star Catalog index table for fields
gscread.c: * list containing the pathnames of the files on the cd-rom.
gscread.c:    nsrch = ir2 - ir1 + 1;
gscread.c:	fprintf (stderr,"GSCREG: searching %d regions: %d - %d\n",nsrch,ir1,ir2);
gscread.c:	nsrch1 = jr2 - jr1 + 1;
gscread.c:	    fprintf (stderr,"GSCREG: searching %d regions: %d - %d\n",nsrch1,jr1,jr2);
gscread.c:	fprintf(stderr,"GSCREG: RA: %.5f - %.5f, Dec: %.5f - %.5f\n",ra1,ra2,dec1,dec2);
gscread.c:	for (irow = ir1 - 1; irow < ir2; irow++) {
gscread.c:	/* Handle wrap-around through the equator */
gscread.c:/* GSCRA -- returns right ascension in degrees from the GSC index table
gscread.c:/*  GSCDEC -- returns the declination in degrees from the GSC index table.
gscread.c:    if (strchr (sgn, '-') != NULL)
gscread.c:	dec = -dec;
gscread.c:/*  GSCZONE -- find the zone number where a declination can be found */
gscread.c:	zone = ndeczones - zone;
gscread.c:/* GSCPATH -- Get HST Guide Star Catalog region FITS file pathname */
gscread.c: * May 13 1998	Print all stars if classd is < -1
gscread.c: * Apr 24 2001	Return individual entries if class is < -1
gscread.c: * May 23 2001	Add support for GSC-ACT
gscread.c: * Oct  2 2002	Fix pass-through tab table header
gscread.c: * Dec  1 2003	Add missing tab to n=-1 header
hget.c: *** Harvard-Smithsonian Center for Astrophysics
hget.c: *** Copyright (C) 1994-2011
hget.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
hget.c: * Subroutine:	hgetm  (hstring,keyword, lstr, str) returns multi-keyword string
hget.c: * Subroutine:	strsrch (s1, s2) finds string s2 in null-terminated string s1
hget.c: * Subroutine:	strnsrch (s1, s2, ls1) finds string s2 in ls1-byte string s1
hget.c:	lhead0 = hend + 80 - header;
hget.c:	minint = -INT_MAX - 1;
hget.c:	else if (dval-0.001 < minint)
hget.c:	    *ival = (int) (dval - 0.001);
hget.c:	minshort = -SHRT_MAX - 1;
hget.c:	else if (dval-0.001 < minshort)
hget.c:	    *ival = (short) (dval - 0.001);
hget.c:    /* Translate value from ASCII colon-delimited string to binary */
hget.c:    /* Translate value from ASCII colon-delimited string to binary */
hget.c:/* Extract real*8 date from FITS header string (dd/mm/yy or dd-mm-yy) */
hget.c:	dstr = strchr (value,'-');
hget.c:		sstr = strchr (nval,'-');
hget.c:		if (day > mday[month-1])
hget.c:		    day = mday[month-1];
hget.c:		yday = day - 1;
hget.c:		for (i = 0; i < month-1; i++)
hget.c:	/* New FITS date format: yyyy-mm-ddThh:mm:ss[.sss] */
hget.c:	    *dstr = '-';
hget.c:	    dstr = strchr (nval,'-');
hget.c:		*dstr = '-';
hget.c:	    if (day > mday[month-1])
hget.c:		day = mday[month-1];
hget.c:	    yday = day - 1;
hget.c:	    for (i = 0; i < month-1; i++)
hget.c:/* Extract IRAF multiple-keyword string value from FITS header string */
hget.c:    /* Loop through sequentially-named keywords */
hget.c:		strncpy (stri, value, lstri-1);
hget.c:	lstri = lstri - lval;
hget.c:	    strncpy (str, value, lstr-1);
hget.c:	for (i = nchar-1; i >= 0; i--) {
hget.c:    strncpy (keyword,keyword0, sizeof(keyword)-1);
hget.c:		q2 = c1 - 1;
hget.c:		    q2--;
hget.c:		    q2--;
hget.c:		    q2 = c1 - 1;
hget.c:			q2--;
hget.c:			q2--;
hget.c:	v2--;
hget.c:	    v2--;
hget.c:    /* Convert -zero to just plain 0 */
hget.c:    if (!strcmp (v1, "-0"))
hget.c:		for (i = 1; i < -ipar; i++) {
hget.c:const char *hstring;	/* character string containing fits-style header
hget.c:	nleft = headlast - headnext;
hget.c:	icol = (loc - hstring) % 80;
hget.c:	    line = loc - icol;
hget.c:    bval = pval - 80;
hget.c:	bval = bval - 80;
hget.c:const char *hstring;	/* character string containing fits-style header
hget.c:	nleft = headlast - headnext;
hget.c:	icol = (loc - hstring) % 80;
hget.c:	    line = loc - icol;
hget.c:    /* Translate value from ASCII colon-delimited string to binary */
hget.c:	if (*value == '-') {
hget.c:	    sign = -1.0;
hget.c:	while (value[lval-1] == ' ')
hget.c:	    lval--;
hget.c:/* Find string s2 within null-terminated string s1 */
hget.c:    /* A zero-length pattern is found in any string */
hget.c:    /* Only a zero-length string can be found in a zero-length string */
hget.c:    clast = (char) s2[ls2-1];
hget.c:    s1e = (char *) s1 + (int) ls1 - ls2 + 1;
hget.c:	    if (s[ls2-1] == clast) {
hget.c:		/* If two-character search, return */
hget.c:/* Find string s2 within null-terminated string s1 (case-free search) */
hget.c:/* Find string s2 within string s1 (case-free search) */
hget.c:    /* A zero-length pattern is found in any string */
hget.c:    /* Only a zero-length string can be found in a zero-length string */
hget.c:	    ocfirst = cfirst - 32;
hget.c:		oclast = clast - 32;
hget.c:		os2[i] = s2[i] - 32;
hget.c:	clast = s2[ls2-1];
hget.c:	oclast = os2[ls2-1];
hget.c:    s1e = s + (int) ls1 - ls2 + 1;
hget.c:	    sl = s[ls2-1];
hget.c:		/* If two-character search, return */
hget.c:/* ISNUM-- Return 1 if string is an integer number,
hget.c:    while (string[lstr-1] == ' ')
hget.c:	lstr--;
hget.c:    /* Numeric strings contain 0123456789-+ and d or e for exponents */
hget.c:	    cstr != '+' && cstr != '-' &&
hget.c:	else if (cstr == '+' || cstr == '-') {
hget.c:	    if (string[i+1] == '-' || string[i+1] == '+')
hget.c:		cstr1 = string[i-1];
hget.c:/* NUMDEC -- Return number of decimal places in numeric string (-1 if not number) */
hget.c:        return (-1);
hget.c:            return (lstr - (cdot - string) - 1);
hget.c:    /* If number, ignore leading # and remove trailing non-numeric character */
hget.c:	strend = str + strlen (str) - 1;
hget.c:	if (string[lstr-1] == ')') {
hget.c:	    string[lstr-1] = (char) 0;
hget.c:	    strend = string + lstr - 1;
hget.c:	    string[lstr-2] = (char) 0;
hget.c:	ndek = (int) (string[lstr-1] - 48);
hget.c:	ndek = ndek + (10 * ((int) (string[lstr-2] - 48)));
hget.c:	if (ndek < lstr - 7) {
hget.c:	    lstr = lstr - 4;
hget.c:	    strsrch (string, "E-") == NULL &&
hget.c:	    strsrch (string, "e-") == NULL &&
hget.c:	    s = string + lstr - 1;
hget.c:		if (*(s - 1) != '.') {
hget.c:		    lstr --;
hget.c:		s--;
hget.c:    s = string + lstr - 1;
hget.c: * Aug  5 1996	Add STRNSRCH to search strings which are not null-terminated
hget.c: * Feb 24 1998	Implement code to return IRAF multiple-keyword strings
hget.c: * Jul 21 1998	Drop minus sign for values of -0
hget.c: * Sep 29 1998	Treat hyphen-separated date as old format if 2-digit year
hget.c: * May  5 1999	values.h -> POSIX limits.h: MAXINT->INT_MAX, MAXSHORT->SHRT_MAX
hget.c: * Jul 15 1999	Add hgetm() options of 1- or 2-digit keyword extensions
hget.c: * Feb 11 2000	Add null at end of multi-line keyword value character string
hget.c: * Mar 21 2000	Implement -n to get string value starting with nth token
hget.c: * Apr  5 2000	Reject +- in isnum()
hget.c: * Oct 23 2000	Fix handling of embedded + or - in isnum()
hget.c: * Jun 26 2002	Do not drop leading or trailing spaces in multi-line values
hget.c: * Aug  6 2002	Add strcsrch() and strncsrch() for case-insensitive searches
hget.c: * Aug 30 2002	Fix bug so strcsrch() really is case-insensitive
hget.c: * Apr  9 2004	Use strncsrch() in ksearch() to find differently-cased keywords
hput1.c: *** Harvard-Smithsonian Center for Astrophysics
hput1.c: *** Copyright (C) 1995-2007
hput1.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
hput1.c: * Subroutine:	hputm  (hstring,keyword,cval) sets multi-line character string
hput1.c: * Subroutine:  getltime () returns current local time as ISO-style string
hput1.c: * Subroutine:  getutime () returns current UT as ISO-style string
hput1.c:/*  HPUTI4 - Set int keyword = ival in FITS header string */
hput1.c:char *hstring;		/* FITS-style header information in the format
hput1.c:/*  HPUTR4 - Set float keyword = rval in FITS header string */
hput1.c:    /* Remove sign if string is -0 or extension thereof */
hput1.c:/*  HPUTR8 - Set double keyword = dval in FITS header string */
hput1.c:    /* Remove sign if string is -0 or extension thereof */
hput1.c:/*  HPUTNR8 - Set double keyword = dval in FITS header string */
hput1.c:	sprintf (format, "%%.%dg", -ndec);
hput1.c:    /* Remove sign if string is -0 or extension thereof */
hput1.c:/*  HPUTRA - Set double keyword = hh:mm:ss.sss in FITS header string */
hput1.c:    /* Remove sign if string is -0 or extension thereof */
hput1.c:/*  HPUTDEC - Set double keyword = dd:mm:ss.sss in FITS header string */
hput1.c:    /* Remove sign if string is -0 or extension thereof */
hput1.c:/* FIXNEGZERO -- Drop - sign from beginning of any string which is all zeros */
hput1.c:    if (string[0] != '-')
hput1.c:    /* Drop out if any non-zero digits in this string */
hput1.c:    /* Drop - from start of string; overwrite string in place */
hput1.c:	string[i-1] = string[i];
hput1.c:    string[lstr-1] = (char) 0;
hput1.c:/*  HPUTL - Set keyword = F if lval=0, else T, in FITS header string */
hput1.c:/*  HPUTM - Set multi-line character string in FITS header string */
hput1.c:	    lcv = lcv - 67;
hput1.c:/*  HPUTS - Set character string keyword = 'cval' in FITS header string */
hput1.c:/*  HPUTC - Set character string keyword = value in FITS header string */
hput1.c:/*          Return -1 if error, 0 if OK */
hput1.c:	    /* Align pointer at start of 80-character line */
hput1.c:	    lc = v1 - hstring;
hput1.c:	    if (v2 - hstring > lhead) {
hput1.c:		return (-1);
hput1.c:	    /* Align pointer at start of 80-character line */
hput1.c:	    lc = v1 - hstring;
hput1.c:	    if (v2 - hstring > lhead) {
hput1.c:		return (-1);
hput1.c:	/* Align pointer at start of 80-character line */
hput1.c:	lc = v1 - hstring;
hput1.c:	    lcom = 80 - (c1 + 2 - line);
hput1.c:	    vp = newcom + lcom - 1;
hput1.c:	    while (vp-- > newcom && *vp == ' ')
hput1.c:		lcom--;
hput1.c:	vp = v1 + 30 - lval;
hput1.c:		lcom = 77 - lc;
hput1.c:	    lblank = v2 - vp;
hput1.c:/*  HPUTCOM - Set comment for keyword or on line in FITS header string */
hput1.c:	/* Align pointer at start of 80-character line */
hput1.c:	lc = v1 - hstring;
hput1.c:	if (v2 - hstring > lhead) {
hput1.c:	    return (-1);
hput1.c:	    return (-1);
hput1.c:	/* Align pointer at start of 80-character line */
hput1.c:	lc = v1 - hstring;
hput1.c:	line[80] = '\0'; /* Null-terminate line before strchr call */
hput1.c:	if (q2 == NULL || q2-line < 30)
hput1.c:	    c0 = v1 + (q2 - line) + 1; /* allan: 1997-09-30, was c0=q2+2 */
hput1.c:	if (c0 - v1 > 77)
hput1.c:	    return (-1);
hput1.c:	lblank = v2 - c1;
hput1.c:/*  HDEL - Set character string keyword = value in FITS header string
hput1.c:	ve = ve - 80;
hput1.c:/*  HADD - Add character string keyword = value to FITS header string
hput1.c:    /* limit bug found by Paolo Montegriffo fixed 2000-04-19 */
hput1.c:    for (v = ve; v >= v1; v = v - 80) {
hput1.c:/*  HCHANGE - Changes keyword for entry from keyword1 to keyword2 in FITS
hput1.c:	ra = -ra;
hput1.c:	dsgn = -1.0;
hput1.c:    b =  (a - (double)hours) * 60.0;
hput1.c:    seconds = (b - (double)minutes) * 60.0;
hput1.c:    if (ltstr < lstr-1)
hput1.c:	strncpy (string, tstring, lstr-1);
hput1.c:	string[lstr-1] = 0;
hput1.c:    /* Keep angle between -180 and 360 degrees */
hput1.c:	deg1 = -deg1;
hput1.c:	dsgn = -1.0;
hput1.c:    if (deg1 <= -180.0)
hput1.c:	sign = '-';
hput1.c:	a = -a;
hput1.c:    b =  (a - (double)degrees) * 60.0;
hput1.c:    seconds = (b - (double)minutes) * 60.0;
hput1.c:    if (ltstr < lstr-1)
hput1.c:	strncpy (string, tstring, lstr-1);
hput1.c:	string[lstr-1] = 0;
hput1.c:    /* Keep angle between -180 and 360 degrees */
hput1.c:	deg1 = -deg1;
hput1.c:	dsgn = -1.0;
hput1.c:    if (deg1 <= -180.0)
hput1.c:    if (ltstr < lstr-1)
hput1.c:	strncpy (string, tstring, lstr-1);
hput1.c:	string[lstr-1] = 0;
hput1.c:/* Write the variable a in decimal format into field-character string  */
hput1.c: * May 27 1998	Keep Dec between -90 and +90 in DEC2STR()
hput1.c: * Sep 28 1998	Null-terminate comment in HPUTCOM (Allan Brighton)
hput1.c: * Aug 16 1999	Keep angle between -180 and +360 in dec2str()
hput1.c: * Mar 27 2000	Add hputm() for muti-line keywords
hput.c: *** Harvard-Smithsonian Center for Astrophysics
hput.c: *** Copyright (C) 1995-2011
hput.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
hput.c: * Subroutine:	hputm  (hstring,keyword,cval) sets multi-line character string
hput.c: * Subroutine:  getltime () returns current local time as ISO-style string
hput.c: * Subroutine:  getutime () returns current UT as ISO-style string
hput.c:/*  HPUTI4 - Set int keyword = ival in FITS header string */
hput.c:char *hstring;		/* FITS-style header information in the format
hput.c:/*  HPUTR4 - Set float keyword = rval in FITS header string */
hput.c:    /* Remove sign if string is -0 or extension thereof */
hput.c:/*  HPUTR8 - Set double keyword = dval in FITS header string */
hput.c:    /* Remove sign if string is -0 or extension thereof */
hput.c:/*  HPUTNR8 - Set double keyword = dval in FITS header string */
hput.c:	sprintf (format, "%%.%dg", -ndec);
hput.c:    /* Remove sign if string is -0 or extension thereof */
hput.c:/*  HPUTRA - Set double keyword = hh:mm:ss.sss in FITS header string */
hput.c:    /* Remove sign if string is -0 or extension thereof */
hput.c:/*  HPUTDEC - Set double keyword = dd:mm:ss.sss in FITS header string */
hput.c:    /* Remove sign if string is -0 or extension thereof */
hput.c:/* FIXNEGZERO -- Drop - sign from beginning of any string which is all zeros */
hput.c:    if (string[0] != '-')
hput.c:    /* Drop out if any non-zero digits in this string */
hput.c:    /* Drop - from start of string; overwrite string in place */
hput.c:	string[i-1] = string[i];
hput.c:    string[lstr-1] = (char) 0;
hput.c:/*  HPUTL - Set keyword = F if lval=0, else T, in FITS header string */
hput.c:/*  HPUTM - Set multi-line character string in FITS header string */
hput.c:	    lcv = lcv - 67;
hput.c:/*  HPUTS - Set character string keyword = 'cval' in FITS header string */
hput.c:/*  HPUTC - Set character string keyword = value in FITS header string */
hput.c:/*          Return -1 if error, 0 if OK */
hput.c:	    /* Align pointer at start of 80-character line */
hput.c:	    lc = v1 - hstring;
hput.c:	    if (v2 - hstring > lhead) {
hput.c:		return (-1);
hput.c:	    /* Align pointer at start of 80-character line */
hput.c:	    lc = v1 - hstring;
hput.c:	    if (v2 - hstring > lhead) {
hput.c:		return (-1);
hput.c:	/* Align pointer at start of 80-character line */
hput.c:	lc = v1 - hstring;
hput.c:	    lcom = 80 - (c1 + 2 - line);
hput.c:	    vp = newcom + lcom - 1;
hput.c:	    while (vp-- > newcom && *vp == ' ')
hput.c:		lcom--;
hput.c:	vp = v1 + 30 - lval;
hput.c:		lcom = 77 - lc;
hput.c:	    lblank = v2 - vp;
hput.c:/*  HPUTCOM - Set comment for keyword or on line in FITS header string */
hput.c:	/* Align pointer at start of 80-character line */
hput.c:	lc = v1 - hstring;
hput.c:	if (v2 - hstring > lhead) {
hput.c:	    return (-1);
hput.c:	    return (-1);
hput.c:	/* Align pointer at start of 80-character line */
hput.c:	lc = v1 - hstring;
hput.c:	line[80] = '\0'; /* Null-terminate line before strchr call */
hput.c:		    q2 = c1 - 1;
hput.c:			q2--;
hput.c:			q2--;
hput.c:	    c0 = v1 + (c1 - line) - 1;
hput.c:	else if (q2 == NULL || q2-line < 30)
hput.c:	    c0 = v1 + (q2 - line) + 1; /* allan: 1997-09-30, was c0=q2+2 */
hput.c:	if (c0 - v1 > 77)
hput.c:	    return (-1);
hput.c:	lblank = v1 + 79 - c1;
hput.c:/*  HDEL - Set character string keyword = value in FITS header string
hput.c:	ve = ve - 80;
hput.c:/*  HADD - Add character string keyword = value to FITS header string
hput.c:    /* limit bug found by Paolo Montegriffo fixed 2000-04-19 */
hput.c:    for (v = ve; v >= v1; v = v - 80) {
hput.c:/*  HCHANGE - Changes keyword for entry from keyword1 to keyword2 in FITS
hput.c:	ra = -ra;
hput.c:	dsgn = -1.0;
hput.c:    b =  (a - (double)hours) * 60.0;
hput.c:    seconds = (b - (double)minutes) * 60.0;
hput.c:    if (ltstr < lstr-1)
hput.c:	strncpy (string, tstring, lstr-1);
hput.c:	string[lstr-1] = 0;
hput.c:    /* Keep angle between -180 and 360 degrees */
hput.c:	deg1 = -deg1;
hput.c:	dsgn = -1.0;
hput.c:    if (deg1 <= -180.0)
hput.c:	sign = '-';
hput.c:	a = -a;
hput.c:    b =  (a - (double)degrees) * 60.0;
hput.c:    seconds = (b - (double)minutes) * 60.0;
hput.c:    if (ltstr < lstr-1)
hput.c:	strncpy (string, tstring, lstr-1);
hput.c:	string[lstr-1] = 0;
hput.c:    /* Keep angle between -180 and 360 degrees */
hput.c:	deg1 = -deg1;
hput.c:	dsgn = -1.0;
hput.c:    if (deg1 <= -180.0)
hput.c:    if (ltstr < lstr-1)
hput.c:	strncpy (string, tstring, lstr-1);
hput.c:	string[lstr-1] = 0;
hput.c:/* Write the variable a in decimal format into field-character string  */
hput.c: * May 27 1998	Keep Dec between -90 and +90 in DEC2STR()
hput.c: * Sep 28 1998	Null-terminate comment in HPUTCOM (Allan Brighton)
hput.c: * Aug 16 1999	Keep angle between -180 and +360 in dec2str()
hput.c: * Mar 27 2000	Add hputm() for muti-line keywords
iget.c: *** Harvard-Smithsonian Center for Astrophysics
iget.c: *** Copyright (C) 1998-2007
iget.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
iget.c:const char *mkey;	/* Character string containing the name of the multi-line
iget.c:const char	*mkey;	  /* Character string containing the name of the multi-line
iget.c:const char *mkey;	/* Character string containing the name of the multi-line
iget.c:	    minint = -INT_MAX - 1;
iget.c:	    else if (dval-0.001 < minint)
iget.c:		*ival = (int) (dval - 0.001);
iget.c:	    minshort = -SHRT_MAX - 1;
iget.c:	    else if (dval-0.001 < minshort)
iget.c:		*ival = (short) (dval - 0.001);
iget.c:		strncpy (str, value, lstr-1);
iget.c:const char *hstring;	/* character string containing fits-style header
iget.c:	nleft = headlast - headnext;
iget.c:	lastchar = (int) *(loc - 1);
iget.c: * May  5 1999	values.h -> POSIX limits.h: MAXINT->INT_MAX, MAXSHORT->SHRT_MAX
imgetwcs.c: *** Harvard-Smithsonian Center for Astrophysics
imgetwcs.c: *** Copyright (C) 1996-2011
imgetwcs.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
imgetwcs.c: * finding the rotation and offsets which result in a best-fit.
imgetwcs.c:static double secpix0 = PSCALE;		/* Set image scale--override header */
imgetwcs.c:static double secpix2 = PSCALE;		/* Set image scale 2--override header */
imgetwcs.c:static double *cd0 = NULL;		/* Set CD matrix--override header */
imgetwcs.c:static double ra0 = -99.0;		/* Initial center RA in degrees */
imgetwcs.c:static double dec0 = -99.0;		/* Initial center Dec in degrees */
imgetwcs.c:static double xref0 = -99999.0;		/* Reference pixel X coordinate */
imgetwcs.c:static double yref0 = -99999.0;		/* Reference pixel Y coordinate */
imgetwcs.c:static int ptype0 = -1;			/* Projection type to fit */
imgetwcs.c:static char ctypes[NWCSTYPE][4];	/* 3-letter codes for projections */
imgetwcs.c:static char *dateobs0 = NULL;		/* Initial DATE-OBS value in FITS date format */
imgetwcs.c:double	*dra;		/* Right ascension half-width in degrees (returned) */
imgetwcs.c:double	*ddec;		/* Declination half-width in degrees (returned) */
imgetwcs.c:    *hp = (int) wcs->nypix;
imgetwcs.c:    *wp = (int) wcs->nxpix;
imgetwcs.c:    if (wcs->sysout < 1 || wcs->sysout == 6 || wcs->sysout == 10)
imgetwcs.c:	wcs->degout = 1;
imgetwcs.c:	*sysout = wcs->syswcs;
imgetwcs.c:	*eqout = wcs->equinox;
imgetwcs.c:    eq1 = wcs->equinox;
imgetwcs.c:    if (wcs->coorflip) {
imgetwcs.c:	ra1 = wcs->crval[1];
imgetwcs.c:	dec1 = wcs->crval[0];
imgetwcs.c:	ra1 = wcs->crval[0];
imgetwcs.c:	dec1 = wcs->crval[1];
imgetwcs.c:    if (verbose && (eq1 != *eqout || wcs->syswcs != *sysout)) {
imgetwcs.c:	if (wcs->degout) {
imgetwcs.c:	wcscstr (cstr, wcs->syswcs, wcs->equinox, wcs->epoch);
imgetwcs.c:		 wcs->xrefpix, wcs->yrefpix, rstr, dstr, cstr);
imgetwcs.c:    dx = wcs->nxpix;
imgetwcs.c:    dy = wcs->nypix;
imgetwcs.c:    if (wcs->syswcs > 0 && wcs->syswcs != 6 && wcs->syswcs != 10) {
imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra1,&dec1,wcs->epoch);
imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra2,&dec2,wcs->epoch);
imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra3,&dec3,wcs->epoch);
imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,&ra4,&dec4,wcs->epoch);
imgetwcs.c:    if (wcs->syswcs > 0 && wcs->syswcs != 6 && wcs->syswcs != 10)
imgetwcs.c:	wcscon (wcs->syswcs,*sysout,wcs->equinox,*eqout,cra,cdec,wcs->epoch);
imgetwcs.c:    /* Find maximum half-width in declination */
imgetwcs.c:    *ddec = fabs (dec1 - *cdec);
imgetwcs.c:    if (fabs (dec2 - *cdec) > *ddec)
imgetwcs.c:	*ddec = fabs (dec2 - *cdec);
imgetwcs.c:    if (fabs (dec3 - *cdec) > *ddec)
imgetwcs.c:	*ddec = fabs (dec3 - *cdec);
imgetwcs.c:    if (fabs (dec4 - *cdec) > *ddec)
imgetwcs.c:	*ddec = fabs (dec4 - *cdec);
imgetwcs.c:    /* Find maximum half-width in right ascension */
imgetwcs.c:    dra1 = ra1 - *cra;
imgetwcs.c:    dra2 = ra2 - *cra;
imgetwcs.c:	dra1 = -(dra1 - 360.0);
imgetwcs.c:	dra2 = -(dra2 - 360.0);
imgetwcs.c:	dra1 = dra1 - 360.0;
imgetwcs.c:    else if (dra1 < -180.0)
imgetwcs.c:	dra1 = -dra1;
imgetwcs.c:	dra2 = dra2 - 360.0;
imgetwcs.c:    else if (dra2 < -180.0)
imgetwcs.c:	dra2 = -dra2;
imgetwcs.c:    dra3 = *cra - ra3;
imgetwcs.c:    dra4 = *cra - ra4;
imgetwcs.c:    if (*cra > 0 && *cra - dra0 < 0.0) {
imgetwcs.c:	dra3 = dra3 - 360.0;
imgetwcs.c:    else if (dra3 < -180.0)
imgetwcs.c:	dra3 = -dra3;
imgetwcs.c:	dra4 = dra4 - 360.0;
imgetwcs.c:    else if (dra4 < -180.0)
imgetwcs.c:	dra4 = -dra4;
imgetwcs.c:    if (wcs->xref == -999.0 && wcs->yref == -999.0) {
imgetwcs.c:	wcs->xref = *cra;
imgetwcs.c:	wcs->cel.ref[0] = *cra;
imgetwcs.c:	wcs->crval[0] = *cra;
imgetwcs.c:	wcs->yref = *cdec;
imgetwcs.c:	wcs->cel.ref[1] = *cdec;
imgetwcs.c:	wcs->crval[1] = *cdec;
imgetwcs.c:	if (wcs->xrefpix == 0.0 && wcs->yrefpix == 0.0) {
imgetwcs.c:	    wcs->xrefpix = 0.5 + (double) wcs->nxpix * 0.5;
imgetwcs.c:	    wcs->yrefpix = 0.5 + (double) wcs->nypix * 0.5;
imgetwcs.c:	wcs->xinc = *dra * 2.0 / (double) wcs->nxpix;
imgetwcs.c:	wcs->yinc = *ddec * 2.0 / (double) wcs->nypix;
imgetwcs.c:	wcs->plate_fit = 0; */
imgetwcs.c:    else if (wcs->syswcs != *sysout && wcs->equinox != *eqout) {
imgetwcs.c:	wcscon (wcs->syswcs, *sysout, wcs->equinox, *eqout, &ra1, &dec1, wcs->epoch);
imgetwcs.c:	if (wcs->coorflip) {
imgetwcs.c:	    wcs->yref = ra1;
imgetwcs.c:	    wcs->xref = dec1;
imgetwcs.c:	    wcs->xref = ra1;
imgetwcs.c:	    wcs->yref = dec1;
imgetwcs.c:	pix2wcs (wcs, wcs->xrefpix-0.5, wcs->yrefpix, &ra1, &dec1);
imgetwcs.c:	pix2wcs (wcs, wcs->xrefpix+0.5, wcs->yrefpix, &ra2, &dec2);
imgetwcs.c:    wcs->crval[0] = wcs->xref;
imgetwcs.c:    wcs->crval[1] = wcs->yref;
imgetwcs.c:    if (wcs->coorflip) {
imgetwcs.c:	wcs->cel.ref[0] = wcs->crval[1];
imgetwcs.c:	wcs->cel.ref[1] = wcs->crval[0];
imgetwcs.c:	wcs->cel.ref[0] = wcs->crval[0];
imgetwcs.c:	wcs->cel.ref[1] = wcs->crval[1];
imgetwcs.c:    if (wcs->syswcs > 0 && wcs->syswcs != 6 && wcs->syswcs != 10) {
imgetwcs.c:	wcs->cel.flag = 0;
imgetwcs.c:	wcs->wcsl.flag = 0;
imgetwcs.c:	wcs->lin.flag = LINSET;
imgetwcs.c:	wcs->wcsl.flag = WCSSET;
imgetwcs.c:    wcs->equinox = *eqout;
imgetwcs.c:    wcs->syswcs = *sysout;
imgetwcs.c:    wcs->sysout = *sysout;
imgetwcs.c:    wcs->eqout = *eqout;
imgetwcs.c:    wcs->sysin = *sysout;
imgetwcs.c:    wcs->eqin = *eqout;
imgetwcs.c:    wcscstr (cstr,*sysout,*eqout,wcs->epoch);
imgetwcs.c:    strcpy (wcs->radecsys, cstr);
imgetwcs.c:    strcpy (wcs->radecout, cstr);
imgetwcs.c:    strcpy (wcs->radecin, cstr);
imgetwcs.c:    wcsininit (wcs, wcs->radecsys);
imgetwcs.c:    wcsoutinit (wcs, wcs->radecsys);
imgetwcs.c:    naxes = wcs->naxis;
imgetwcs.c:	naxes = wcs->naxes;
imgetwcs.c:	wcs->naxis = naxes;
imgetwcs.c:	hputnr8 (header, "CDELT1", 9, wcs->xinc);
imgetwcs.c:	    hputnr8 (header, "CDELT2", 9, wcs->yinc);
imgetwcs.c:	    hputnr8 (header, "CROTA2", 9, wcs->rot);
imgetwcs.c:	hputnr8 (header, "CD1_1", 9, wcs->cd[0]);
imgetwcs.c:	    hputnr8 (header, "CD1_2", 9, wcs->cd[1]);
imgetwcs.c:	    hputnr8 (header, "CD2_1", 9, wcs->cd[2]);
imgetwcs.c:	    hputnr8 (header, "CD2_2", 9, wcs->cd[3]);
imgetwcs.c:	if (wcs->degout) {
imgetwcs.c:	wcscstr (cstr,*sysout,*eqout,wcs->epoch);
imgetwcs.c:		wcs->xrefpix, wcs->yrefpix, rstr, dstr, cstr);
imgetwcs.c:	if (wcs->degout) {
imgetwcs.c:	wcscstr (cstr, *sysout, *eqout, wcs->epoch);
imgetwcs.c:	if (wcs->degout) {
imgetwcs.c:	fprintf (stderr," +- %s %s\n", rstr, dstr);
imgetwcs.c:    if (ra0 > -99.0 && dec0 > -99.0) {
imgetwcs.c:	    hputnr8 (header, "CDELT1", 8, -degpix);
imgetwcs.c:    if (ptype0 > -1 && ptype0 < nctype) {
imgetwcs.c:	strcpy (temp,"RA---");
imgetwcs.c:	strcpy (temp,"DEC--");
imgetwcs.c:    if (xref0 > -99999.0 && yref0 > -99999.0) {
imgetwcs.c:	    degpix = -secpix0 / 3600.0;
imgetwcs.c:	    hputnr8 (header, "CDELT1", 8, -degpix);
imgetwcs.c:		hputs (header, "CTYPE1", "GLON-TAN");
imgetwcs.c:		hputs (header, "CTYPE2", "GLAT-TAN");
imgetwcs.c:		hputs (header, "CTYPE1", "RA---TAN");
imgetwcs.c:		hputs (header, "CTYPE2", "DEC--TAN");
imgetwcs.c:	hputs (header, "DATE-OBS", dateobs0);
imgetwcs.c:    ptype0 = -1;
imgetwcs.c: * May 23 1996	Use pre-existing WCS for center, if it is present
imgetwcs.c: * Jul  9 1999	Fix bug which reset command-line-set reference pixel coordinate
imgetwcs.c: * Oct 19 2001	Allow DATE-OBS to be set
imgetwcs.c: * Mar 27 2003	Fix half-pixel bug in computation of image center
imgetwcs.c: * Jun  6 2003	Set xref and yref to center if -999, not 0
imgetwcs.c: * Oct  6 2003	Change wcs->naxes to wcs->naxis to match WCSLIB 3.2
imgetwcs.c: * Dec  3 2003	Add wcs->naxes back as an alternative
imhfile.c: *** Harvard-Smithsonian Center for Astrophysics
imhfile.c: *** Copyright (C) 1996-2012
imhfile.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
imhfile.c: *		Get 4-byte integer from arbitrary part of IRAF header
imhfile.c: * 		Convert 2-byte/char IRAF string to 1-byte/char string
imhfile.c: * 		Convert 1-byte/char string to IRAF 2-byte/char string
imhfile.c:#define IM_HDRLEN	 12		/* Length of header in 4-byte ints */
imhfile.c:#define IM2_HDRLEN	  6		/* Length of header in 4-byte ints */
imhfile.c:static int headswap=-1;	/* =1 to swap data bytes of foreign IRAF file */
imhfile.c:    headswap = -1;
imhfile.c:	(void)fprintf(stderr, "IRAFRHEAD Cannot allocate %d-byte header\n",
imhfile.c:    pixchar = pixname + lpname - 1;
imhfile.c:	newpixname[len-3] = 'p';
imhfile.c:	newpixname[len-2] = 'i';
imhfile.c:	newpixname[len-1] = 'x';
imhfile.c:	(void)fprintf(stderr, "IRAFRIMAGE Cannot allocate %d-byte pixel header\n",
imhfile.c:	bytepix = -bitpix / 8;
imhfile.c:    /* If either dimension is one and image is 3-D, read all three dimensions */
imhfile.c:	(void)fprintf(stderr, "IRAFRIMAGE Cannot allocate %d-byte image buffer\n",
imhfile.c:	nbdiff = (npaxis1 - naxis1) * bytepix;
imhfile.c:    /* Byte-reverse image, if necessary */
imhfile.c:    headswap = -1;
imhfile.c:    headswap = -1;
imhfile.c:	nlines = 24 + ((nbiraf - LEN_IM2HDR) / 81);
imhfile.c:	nlines = 24 + ((nbiraf - LEN_IMHDR) / 162);
imhfile.c:	(void)fprintf(stderr, "IRAF2FITS Cannot allocate %d-byte FITS header\n",
imhfile.c:	    nbits = -16;
imhfile.c:	    nbits = -32;
imhfile.c:	    nbits = -64;
imhfile.c:    pixoff = (pixoff - 1) * 2;
imhfile.c:    /* Set flag if header numbers are byte-reversed on this machine */
imhfile.c:    /* Set flag if image pixels are byte-reversed on this machine */
imhfile.c:    hputs (fitsheader, "DATE-MOD", dstring);
imhfile.c:    hputcom (fitsheader,"DATE-MOD", "Date of latest file modification");
imhfile.c:    /* Find end of last 2880-byte block of header */
imhfile.c:	return (-1);
imhfile.c:	return (-1);
imhfile.c:/* IRAFWIMAGE -- write IRAF .imh header file and .pix image file
imhfile.c:	bytepix = -bitpix / 8;
imhfile.c:    /* If either dimension is one and image is 3-D, read all three dimensions */
imhfile.c:    /* Byte-reverse image, if necessary */
imhfile.c:	while( (len > 0) && (newpixname[len-1] != '/') )
imhfile.c:	while( (len > 0) && (newpixname[len-1] != ']') && (newpixname[len-1] != ':') )
imhfile.c:	    len--;
imhfile.c:	plen = strlen (pixname) - 4;
imhfile.c:	    (void)strncat (newpixname, &pixname[4], SZ_IM2PIXFILE - len);
imhfile.c:	while( (len > 0) && (newpixname[len-1] != '/') )
imhfile.c:	while( (len > 0) && (newpixname[len-1] != ']') && (newpixname[len-1] != ':') )
imhfile.c:	    len--;
imhfile.c:	newpixname[len-3] = 'p';
imhfile.c:	newpixname[len-2] = 'i';
imhfile.c:	newpixname[len-1] = 'x';
imhfile.c:	case -8:
imhfile.c:	case -16:
imhfile.c:	case -32:
imhfile.c:	case -64:
imhfile.c:		    lhdrdir = hdrdir - hdrfile + 1;
imhfile.c:    hdel (fitsheader, "DATE-MOD");
imhfile.c:    hdel (fitsheader, "DATE-MOD");
imhfile.c:    nlfits = ((fitsend - fitsheader) / 80);
imhfile.c:	*nbiraf = iraf2p - irafheader;
imhfile.c:	*nbiraf = 2 * (irafp - irafs);
imhfile.c:/* IRAFGETC2 -- Get character string from arbitrary part of v.1 IRAF header */
imhfile.c:/* IRAFGETC -- Get character string from arbitrary part of IRAF header */
imhfile.c:	(void)fprintf(stderr, "IRAFGETC Cannot allocate %d-byte variable\n",
imhfile.c:/* Convert IRAF 2-byte/char string to 1-byte/char string */
imhfile.c:char	*irafstring;	/* IRAF 2-byte/character string */
imhfile.c:    /* Set swap flag according to position of nulls in 2-byte characters */
imhfile.c:	(void)fprintf(stderr, "IRAF2STR Cannot allocate %d-byte variable\n",
imhfile.c:/* IRAFPUTI4 -- Insert 4-byte integer into arbitrary part of IRAF header */
imhfile.c:/* IRAFPUTR4 -- Insert 4-byte real number into arbitrary part of IRAF header */
imhfile.c:/* IRAFPUTC2 -- Insert character string into arbitrary part of v.1 IRAF header */
imhfile.c:	(void)fprintf(stderr, "IRAFPUTC2 Cannot allocate %d-byte variable\n",
imhfile.c:/* IRAFPUTC -- Insert character string into arbitrary part of IRAF header */
imhfile.c:/* STR2IRAF -- Convert 1-byte/char string to IRAF 2-byte/char string */
imhfile.c:char	*string;	/* 1-byte/character string */
imhfile.c:char	*irafstring;	/* IRAF 2-byte/character string */
imhfile.c:    /* If swapped, start with first byte of 2-byte characters */
imhfile.c:/* IRAFSWAP -- Reverse bytes of any type of vector in place */
imhfile.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imhfile.c:			/* -32 = float, -64 = double */
imhfile.c:	case -16:
imhfile.c:	case -32:
imhfile.c:	case -64:
imhfile.c:/* IRAFSWAP2 -- Swap bytes in string in place */
imhfile.c:/* IRAFSWAP4 -- Reverse bytes of Integer*4 or Real*4 vector in place */
imhfile.c:/* IRAFSWAP8 -- Reverse bytes of Real*8 vector in place */
imhfile.c:/* ISIRAF -- return 1 if IRAF imh file, else 0 */
imhfile.c:/* IRAFSIZE -- return size of file in bytes */
imhfile.c:	filesize = -1;
imhfile.c: * Aug 26 1996	Allow 1-d images; fix comments; fix arguments after lint
imhfile.c: * Nov 16 1998	Fix byte-swap checking
imhfile.c: * Nov 24 1999	Delete HEADSWAP, IMHVER, DATE-MOD from header before writing
imhfile.c: * Nov 29 1999	Delete PIXSWAP, IRAF-MIN, IRAF-MAX from header before writing
imio.c: *** Harvard-Smithsonian Center for Astrophysics
imio.c: *** Copyright (C) 1996-2012
imio.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
imio.c:/* GETPIX1 -- Get pixel from 2D FITS image of any numeric type */
imio.c:char	*image;		/* Image array as 1-D vector */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:int	x;		/* One-based horizontal pixel number */
imio.c:int	y;		/* One-based vertical pixel number */
imio.c:    return (getpix (image, bitpix, w, h, bzero, bscale, x-1, y-1));
imio.c:/* GETPIX -- Get pixel from 2D image of any numeric type */
imio.c:char	*image;		/* Image array as 1-D vector */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:int	x;		/* Zero-based horizontal pixel number */
imio.c:int	y;		/* Zero-based vertical pixel number */
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* PUTPIX1 -- Copy pixel into 2D FITS image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:int	x;		/* One-based horizontal pixel number */
imio.c:int	y;		/* One-based vertical pixel number */
imio.c:    putpix (image, bitpix, w, h, bzero, bscale, x-1, y-1, dpix);
imio.c:/* PUTPIX -- Copy pixel into 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	dpix = (dpix - bzero) / bscale;
imio.c:		im1[(y*w) + x] = (unsigned char) (dpix - 0.5);
imio.c:		im2[(y*w) + x] = (short) (dpix - 0.5);
imio.c:		im4[(y*w) + x] = (int) (dpix - 0.5);
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* ADDPIX1 -- Add pixel value into 2D FITS image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:int	x;		/* One-based horizontal pixel number */
imio.c:int	y;		/* One-based vertical pixel number */
imio.c:    addpix (image, bitpix, w, h, bzero, bscale, x-1, y-1, dpix);
imio.c:/* ADDPIX -- Add constant to pixel values in 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:int	x;		/* Zero-based horizontal pixel number */
imio.c:int	y;		/* Zero-based vertical pixel number */
imio.c:	dpix = (dpix - bzero) / bscale;
imio.c:		image[ipix] = im1[ipix] + (unsigned char) (dpix - 0.5);
imio.c:		im2[ipix] = im2[ipix] + (short) (dpix - 0.5);
imio.c:		im4[ipix] = im4[ipix] + (int) (dpix - 0.5);
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* MOVEPIX -- Copy pixel between images */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:		case -16:
imio.c:		case -32:
imio.c:		case -64:
imio.c:		case -16:
imio.c:		case -32:
imio.c:		case -64:
imio.c:		case -16:
imio.c:		case -32:
imio.c:		case -64:
imio.c:	case -16:
imio.c:		case -16:
imio.c:		case -32:
imio.c:		case -64:
imio.c:	case -32:
imio.c:			ims2[(y2*w2) + x2] = (short) (rpix - 0.5);
imio.c:			imi2[(y2*w2) + x2] = (int) (rpix - 0.5);
imio.c:		case -16:
imio.c:		case -32:
imio.c:		case -64:
imio.c:	case -64:
imio.c:			ims2[(y2*w2) + x2] = (short) (dpix - 0.5);
imio.c:			imi2[(y2*w2) + x2] = (int) (dpix - 0.5);
imio.c:		case -16:
imio.c:		case -32:
imio.c:		case -64:
imio.c:/* MAXVEC -- Get maximum value in vector from 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* MINVEC -- Get minimum value in vector from 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* ADDVEC -- Add constant to pixel values in 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	dpix = (dpix - bzero) / bscale;
imio.c:		ccon = (unsigned char) (dpix - 0.5);
imio.c:		jcon = (short) (dpix - 0.5);
imio.c:		icon = (int) (dpix - 0.5);
imio.c:	case -16:
imio.c:		icon = (int) (dpix - 0.5);
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* MULTVEC -- Multiply pixel values in place in 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	dpix = (dpix - bzero) / bscale;
imio.c:		    ccon = (char) (dpix - 0.5);
imio.c:		    jcon = (short) (dpix - 0.5);
imio.c:		    icon = (int) (dpix - 0.5);
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* GETVEC -- Get vector from 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* PUTVEC -- Copy pixel vector into 2D image of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	    *dp = (*dp - bzero) / bscale;
imio.c:		    *(im2+ipix) = (short) (*dp++ - 0.5);
imio.c:		    *(im4+ipix) = (int) (*dp++ - 0.5);
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* FILLVEC1 -- Copy single value into a vector of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:    fillvec (image, bitpix, bzero, bscale, pix1-1, npix, dpix);
imio.c:/* FILLVEC -- Copy single value into a vector of any numeric type */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	dp = (dp - bzero) / bscale;
imio.c:		ipc = (char) (dp - 0.5);
imio.c:		ip2 = (short) (dp - 0.5);
imio.c:		ip4 = (int) (dp - 0.5);
imio.c:	case -16:
imio.c:		ipu = (unsigned short) (dp - 0.5);
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* IMSWAP -- Reverse bytes of any type of vector in place */
imio.c:			/*  16 = short, -16 = unsigned short, 32 = int */
imio.c:			/* -32 = float, -64 = double */
imio.c:	case -16:
imio.c:	case -32:
imio.c:	case -64:
imio.c:/* IMSWAP2 -- Swap bytes in string in place */
imio.c:/* IMSWAP4 -- Reverse bytes of Integer*4 or Real*4 vector in place */
imio.c:/* IMSWAP8 -- Reverse bytes of Real*8 vector in place */
imio.c:/* IMSWAPPED -- Returns 0 if big-endian (Sun,Mac),
imio.c:		1 if little-endian(PC,Alpha) */
imio.c: * Jun 12 1996	Add byte-swapping subroutines
imio.c: * Jul 24 1997	Add 8-bit option to subroutines
imio.c: * Apr 29 1999	Fix bug in getvec in dealing with 1-byte data
imio.c: * Sep 27 1999	Add interface for 1-based (FITS) image access
imio.c: * Apr 12 2012	Fix 8-bit variables to be unsigned char
imio.h: *** Harvard-Smithsonian Center for Astrophysics
imio.h: *** Copyright (C) 1996-2002
imio.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
imio.h:extern double getpix(); /* Read one pixel from any data type 2-D array (0,0)*/
imio.h:extern double getpix1(); /* Read one pixel from any data type 2-D array (1,1)*/
imio.h:extern void putpix();   /* Write one pixel to any data type 2-D array (0,0)*/
imio.h:extern void putpix1();  /* Write one pixel to any data type 2-D array (1,1) */
imio.h:extern void addpix();   /* Add to one pixel in any data type 2-D array (0,0)*/
imio.h:extern void addpix1();  /* Add to one pixel in any data type 2-D array (1,1)*/
imio.h:extern void movepix();  /* Move one pixel value between two 2-D arrays (0,0) */
imio.h:extern void movepix1(); /* Move one pixel value between two 2-D arrays (1,1) */
imio.h:extern void getvec();   /* Read vector from a 2-D array */
imio.h:extern void putvec();   /* Write vector into a 2-D array */
imio.h:extern void imswap2();  /* Swap bytes in a vector of 2-byte (short) integers */
imio.h:extern void imswap4();  /* Reverse bytes in a vector of 4-byte numbers */
imio.h:extern void imswap8();  /* Reverse bytes in a vector of 8-byte numbers */
imio.h: * Jun 12 1996	Add byte-swapping subroutines
imio.h: * Sep 27 1999	Add Fortran-indexed (1,1), not (0,0) image access *1()
imrotate1.c: *** Harvard-Smithsonian Center for Astrophysics
imrotate1.c: *** Copyright (C) 1996-2008
imrotate1.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
imrotate1.c:	case -16:
imrotate1.c:	case -32:
imrotate1.c:	case -64:
imrotate1.c:	sprintf (history,"Copy of image %s bits per pixel %d -> %d",
imrotate1.c:    if (rotate < 45 && rotate > -45) {
imrotate1.c:		x2 = nx - x1 - 1;
imrotate1.c:		y2 = ny - y1 - 1;
imrotate1.c:		x2 = ny - y1 - 1;
imrotate1.c:		    y2 = nx - x1 - 1;
imrotate1.c:		x2 = ny - y1 - 1;
imrotate1.c:		y2 = ny - y1 - 1;
imrotate1.c:		x2 = nx - x1 - 1;
imrotate1.c:		y2 = ny - y1 - 1;
imrotate1.c:		    x2 = nx - x1 - 1;
imrotate1.c:		x2 = ny - y1 - 1;
imrotate1.c:		    y2 = nx - x1 - 1;
imrotate1.c:		    y2 = nx - x1 - 1;
imrotate1.c:    /* If rotating by more than 315 degrees, assume top-bottom reflection */
imrotate1.c: * return 0 if at least one such field is found, else -1.  */
imrotate1.c:	    hputnr8 (header, "CROTA1", ndec1, -ctemp1);
imrotate1.c:	    hputnr8 (header, "CROTA2", ndec2, -ctemp2);
imrotate1.c:	    hputnr8 (header, "LTM1_1", ndec1, -ctemp1);
imrotate1.c:		hputr8 (header, "CD1_1", -ctemp1);
imrotate1.c:		hputr8 (header, "CD2_2", -ctemp1);
imrotate1.c:	    hputr8 (header, "CD1_2", -ctemp1);
imrotate1.c:	    hputr8 (header, "CD2_1", -ctemp1);
imrotate1.c:			hputr8 (header, "CRPIX1", (ctemp3-ltv1)/ctemp1);
imrotate1.c:			hputr8 (header, "CRPIX2", (ctemp3-ltv2)/ctemp1);
imrotate1.c:		hputnr8 (header, "CRPIX1", ndec1, naxis1-ctemp1);
imrotate1.c:		hputnr8 (header, "CRPIX1", ndec2, naxis2-ctemp2);
imrotate1.c:		hputnr8 (header, "CRPIX2", ndec1, naxis1-ctemp1);
imrotate1.c:		hputnr8 (header, "CRPIX2", ndec2, naxis2-ctemp2);
imrotate1.c:		hputnr8 (header, "CRPIX1", ndec2, naxis2-ctemp2);
imrotate1.c:		hputnr8 (header, "CRPIX1", ndec1, naxis1-ctemp1);
imrotate1.c:		hputnr8 (header, "CRPIX2", ndec2, naxis2-ctemp2);
imrotate1.c:		hputnr8 (header, "CRPIX2", ndec1, naxis1-ctemp1);
imrotate1.c:		hputnr8 (header, "CDELT1", ndec1, -ctemp1);
imrotate1.c:		hputnr8 (header, "CDELT1", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CDELT2", ndec1, -ctemp1);
imrotate1.c:		hputnr8 (header, "CDELT2", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CDELT1", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CDELT1", ndec1, -ctemp1);
imrotate1.c:		hputnr8 (header, "CDELT2", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CDELT2", ndec1, -ctemp1);
imrotate1.c:		hputnr8 (header, "CD1_2", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CD2_1", ndec3, -ctemp3);
imrotate1.c:		hputnr8 (header, "CD1_1", ndec4, -ctemp4);
imrotate1.c:		hputnr8 (header, "CD1_2", ndec3, -ctemp3);
imrotate1.c:		hputnr8 (header, "CD2_1", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CD2_2", ndec1, -ctemp1);
imrotate1.c:		hputnr8 (header, "CD2_1", ndec3, -ctemp3);
imrotate1.c:		hputnr8 (header, "CD2_2", ndec4, -ctemp4);
imrotate1.c:		hputnr8 (header, "CD1_1", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CD2_1", ndec4, -ctemp4);
imrotate1.c:		hputnr8 (header, "CD1_1", ndec1, -ctemp1);
imrotate1.c:		hputnr8 (header, "CD1_2", ndec2, -ctemp2);
imrotate1.c:		hputnr8 (header, "CD2_1", ndec3, -ctemp3);
imrotate1.c:		hputnr8 (header, "CD2_2", ndec4, -ctemp4);
imrotate1.c:		hputnr8 (header, "CD1_2", ndec1, -ctemp1);
imrotate1.c:		hputnr8 (header, "CD2_2", ndec3, -ctemp3);
imrotate.c: *** Harvard-Smithsonian Center for Astrophysics
imrotate.c: *** Copyright (C) 1996-2008
imrotate.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
imrotate.c:	case -16:
imrotate.c:	case -32:
imrotate.c:	case -64:
imrotate.c:	sprintf (history,"Copy of image %s bits per pixel %d -> %d",
imrotate.c:    if (rotate < 45 && rotate > -45) {
imrotate.c:		x2 = nx - x1 - 1;
imrotate.c:		y2 = ny - y1 - 1;
imrotate.c:		x2 = ny - y1 - 1;
imrotate.c:		    y2 = nx - x1 - 1;
imrotate.c:		x2 = ny - y1 - 1;
imrotate.c:		y2 = ny - y1 - 1;
imrotate.c:		x2 = nx - x1 - 1;
imrotate.c:		y2 = ny - y1 - 1;
imrotate.c:		    x2 = nx - x1 - 1;
imrotate.c:		x2 = ny - y1 - 1;
imrotate.c:		    y2 = nx - x1 - 1;
imrotate.c:		    y2 = nx - x1 - 1;
imrotate.c:    /* If rotating by more than 315 degrees, assume top-bottom reflection */
imrotate.c: * return 0 if at least one such field is found, else -1.  */
imrotate.c:	    hputnr8 (header, "CROTA1", ndec1, -ctemp1);
imrotate.c:	    hputnr8 (header, "CROTA2", ndec2, -ctemp2);
imrotate.c:	    hputnr8 (header, "LTM1_1", ndec1, -ctemp1);
imrotate.c:	    hputr8 (header, "CD1_1", -ctemp1);
imrotate.c:	    hputr8 (header, "CD1_2", -ctemp1);
imrotate.c:	    hputr8 (header, "CD2_1", -ctemp1);
imrotate.c:			hputr8 (header, "CRPIX1", (ctemp3-ltv1)/ctemp1);
imrotate.c:			hputr8 (header, "CRPIX2", (ctemp3-ltv2)/ctemp1);
imrotate.c:		hputnr8 (header, "CRPIX1", ndec1, naxis1-ctemp1);
imrotate.c:		hputnr8 (header, "CRPIX1", ndec2, naxis2-ctemp2);
imrotate.c:		hputnr8 (header, "CRPIX2", ndec1, naxis1-ctemp1);
imrotate.c:		hputnr8 (header, "CRPIX2", ndec2, naxis2-ctemp2);
imrotate.c:		hputnr8 (header, "CRPIX1", ndec2, naxis2-ctemp2);
imrotate.c:		hputnr8 (header, "CRPIX1", ndec1, naxis1-ctemp1);
imrotate.c:		hputnr8 (header, "CRPIX2", ndec2, naxis2-ctemp2);
imrotate.c:		hputnr8 (header, "CRPIX2", ndec1, naxis1-ctemp1);
imrotate.c:		hputnr8 (header, "CDELT1", ndec1, -ctemp1);
imrotate.c:		hputnr8 (header, "CDELT1", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CDELT2", ndec1, -ctemp1);
imrotate.c:		hputnr8 (header, "CDELT2", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CDELT1", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CDELT1", ndec1, -ctemp1);
imrotate.c:		hputnr8 (header, "CDELT2", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CDELT2", ndec1, -ctemp1);
imrotate.c:		hputnr8 (header, "CD1_2", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CD2_1", ndec3, -ctemp3);
imrotate.c:		hputnr8 (header, "CD1_1", ndec4, -ctemp4);
imrotate.c:		hputnr8 (header, "CD1_2", ndec3, -ctemp3);
imrotate.c:		hputnr8 (header, "CD2_1", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CD2_2", ndec1, -ctemp1);
imrotate.c:		hputnr8 (header, "CD2_1", ndec3, -ctemp3);
imrotate.c:		hputnr8 (header, "CD2_2", ndec4, -ctemp4);
imrotate.c:		hputnr8 (header, "CD1_1", ndec4, -ctemp4);
imrotate.c:		hputnr8 (header, "CD1_2", ndec3, -ctemp3);
imrotate.c:		hputnr8 (header, "CD1_1", ndec1, -ctemp1);
imrotate.c:		hputnr8 (header, "CD1_2", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CD2_1", ndec3, -ctemp3);
imrotate.c:		hputnr8 (header, "CD2_2", ndec4, -ctemp4);
imrotate.c:		hputnr8 (header, "CD2_1", ndec2, -ctemp2);
imrotate.c:		hputnr8 (header, "CD2_2", ndec1, -ctemp1);
imsetwcs.c: *** Harvard-Smithsonian Center for Astrophysics
imsetwcs.c: *** Copyright (C) 1996-2010
imsetwcs.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
imsetwcs.c:static double tolerance = PIXDIFF;	/* +/- this many pixels is a hit */
imsetwcs.c: * return 0 if all ok, else -1
imsetwcs.c:    double *gx;		/* Reference star image X-coordinates in pixels */
imsetwcs.c:    double *gy;		/* Reference star image Y-coordinates in pixels */
imsetwcs.c:    double *sx;		/* Image star image X-coordinates in pixels */
imsetwcs.c:    double *sy;		/* Image star image X-coordinates in pixels */
imsetwcs.c:    double dra, ddec;	/* Image half-widths in degrees */
imsetwcs.c:    /* Use already-matched stars first, if they are present */
imsetwcs.c:    refep = wcs->epoch;
imsetwcs.c:	wcs->prjcode = WCS_TAN;
imsetwcs.c:	magsort = sortmag - 1;
imsetwcs.c:		     nrg, ng, gm[magsort][nrg-1]);
imsetwcs.c:		if (starcat->stnum < 0 && gobj1 != NULL) {
imsetwcs.c:		    CatNum (refcat,-nnfld,starcat->nndec,gnum[ig],numstr);
imsetwcs.c:		CatNum (refcat, -nnfld, nndec, gnum[ig], numstr);
imsetwcs.c:    /* Discover star-like things in the image, in pixels */
imsetwcs.c:	/* Sort star-like objects in image by brightness (magnitude) */
imsetwcs.c:	   use only as many star-like objects as reference stars.  If using
imsetwcs.c:		    mdiff = gm[magsort][0] - xmag;
imsetwcs.c:	if (wcs->ncoeff1 > 0)
imsetwcs.c:	    printf ("# %d-term x, %d-term y polynomial fit\n",
imsetwcs.c:		    wcs->ncoeff1, wcs->ncoeff2);
imsetwcs.c:		    3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
imsetwcs.c:	ra2str (rstr, 32, wcs->xref, 3);
imsetwcs.c:	dec2str (dstr, 32, wcs->yref, 2);
imsetwcs.c:		rstr,dstr, refcoor, wcs->xrefpix, wcs->yrefpix);
imsetwcs.c:	ra = wcs->xref;
imsetwcs.c:	dec = wcs->yref;
imsetwcs.c:		    rstr,dstr, wcs->xrefpix, wcs->yrefpix);
imsetwcs.c:		    rstr,dstr, wcs->xrefpix, wcs->yrefpix);
imsetwcs.c:	igs = -1;
imsetwcs.c:		dx = gx[ig] - sx[is];
imsetwcs.c:		dy = gy[ig] - sy[is];
imsetwcs.c:	if (igs > -1) {
imsetwcs.c:/*	setdcenter (wcs->xref, wcs->yref);
imsetwcs.c:	setsys (wcs->syswcs);
imsetwcs.c:	setrefpix (wcs->xrefpix, wcs->yrefpix);
imsetwcs.c:	    setcd (wcs->cd);
imsetwcs.c:	    setsecpix (-3600.0 * wcs->xinc);
imsetwcs.c:	    setsecpix2 (3600.0 * wcs->yinc);
imsetwcs.c:	    setrot (wcs->rot);
imsetwcs.c:	iterate--;
imsetwcs.c:/*	setdcenter (wcs->xref, wcs->yref);
imsetwcs.c:	setsys (wcs->syswcs);
imsetwcs.c:	setrefpix (wcs->xrefpix, wcs->yrefpix);
imsetwcs.c:	    setcd (wcs->cd);
imsetwcs.c:	    setsecpix (-3600.0 * wcs->xinc);
imsetwcs.c:	    setsecpix2 (3600.0 * wcs->yinc);
imsetwcs.c:	    setrot (wcs->rot);
imsetwcs.c:	toliterate--;
imsetwcs.c:	x = 0.5 * wcs->nxpix;
imsetwcs.c:	y = 0.5 * wcs->nypix;
imsetwcs.c:	setsys (wcs->syswcs);
imsetwcs.c:	setsecpix (-3600.0 * wcs->xinc);
imsetwcs.c:	setsecpix2 (3600.0 * wcs->yinc);
imsetwcs.c:	setrot (wcs->rot);
imsetwcs.c:	nfiterate--;
imsetwcs.c:	dx = gx - sx1[i];
imsetwcs.c:	dy = gy - sy1[i];
imsetwcs.c:	rsep = 3600.0 * ((gra1[i]-sra) * cos(degrad(sdec)));
imsetwcs.c:	    rsep = 3600.0 * ((gra1[i] - sra - 360.0) * cos(degrad(sdec)));
imsetwcs.c:	dsep = 3600.0 * (gdec1[i] - sdec);
imsetwcs.c:	CatNum (refcat, -nnfld, 0, gnum1[i], numstr);
imsetwcs.c:    dmatch1 = (double) (nmatch - 1);
imsetwcs.c:	dx = gx - sx1[i];
imsetwcs.c:	dy = gy - sy1[i];
imsetwcs.c:	rsep = 3600.0 * ((gra1[i]-sra) * cos(degrad(sdec)));
imsetwcs.c:	    rsep = 3600.0 * ((gra1[i] - sra - 360.0) * cos(degrad(sdec)));
imsetwcs.c:	dsep = 3600.0 * (gdec1[i] - sdec);
imsetwcs.c:    dmatch1 = (double) (nmatch - 1);
imsetwcs.c:  if (lim1 > -2.0) refmag1 = lim1;
imsetwcs.c: * Apr 30 1996	Add FOCAS-style catalog matching
imsetwcs.c: * May 23 1996	Use pre-existing WCS for center, if it is present
imsetwcs.c: * Sep  9 1997	Return with default WCS in header only if nfit < -7
imsetwcs.c: * Mar 25 1998	Change residual polynomial fit to full plate-style polynomial
imsetwcs.c: * Sep 29 1999	Add option to start with pre-matched stars
imsetwcs.c: * Jun 22 2000	Fix bug created in last update (found by J.-B. Marquette)
imsetwcs.c: * Jun 11 2001	Set refep from wcs->epoch after WCS is set
imsetwcs.c: * Sep 11 2001	Use single, 2-D magnitude argument to ctgread()
imsetwcs.c: * Oct 29 2001	Print number of matches after residuals to avoid scroll-off
imsetwcs.c: * Aug  2 2002	Use WCSMatch() to set initial values for pre-matched stars
imsetwcs.c: * Mar 14 2007	Return if -n 0 after computing WCS from match
imutil.c: *** Harvard-Smithsonian Center for Astrophysics
imutil.c: *** Copyright (C) 2006-2014
imutil.c: *	Compute Gaussian-weighted mean of a square group of pixels
imutil.c:static double bpval = -9999.0;
imutil.c:			/* Bad pixels have non-zero values */
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    if (minval != -9999.0)
imutil.c:    if (maxval != -9999.0)
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:	    fprintf (stderr, "MEDPIXI1: Could not allocate %d-pixel buffer\n",npix);
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:	    i = j - 1;
imutil.c:		i--;
imutil.c:	    fprintf (stderr, "MEDPIXI2: Could not allocate %d-pixel buffer\n",npix);
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:	    i = j - 1;
imutil.c:		i--;
imutil.c:	    fprintf (stderr, "MEDIANI4: Could not allocate %d-pixel buffer\n",npix);
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:	    i = j - 1;
imutil.c:		i--;
imutil.c:	    fprintf (stderr, "MEDIANR4: Could not allocate %d-pixel buffer\n",npix);
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:	    i = j - 1;
imutil.c:		i--;
imutil.c:	    fprintf (stderr, "MEDIANR8: Could not allocate %d-pixel buffer\n",npix);
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:	    i = j - 1;
imutil.c:		i--;
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:    jx1 = ix - nx2;
imutil.c:    jy1 = iy - ny2;
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:static double hwidth = 1.0;	/* Half-width at half-height of Gaussian */
imutil.c:static int nsub = 1;	/* Number of sub-computations per pixel */
imutil.c:    xd0 = (dsub - 1.0) / (dsub * 2.0);
imutil.c:    idr = (-my / 2) - 1;
imutil.c:	idc = (-mx / 2) - 1;
imutil.c:	    xdr = ((double) idr - xd0) / hwidth;
imutil.c:		xdc = ((double)(idc) - xd0) / hwidth;
imutil.c:		    gwt[i] = gwt[i] + exp (-rad2 / 2.0);
imutil.c:/* Compute Gaussian-weighted mean of a square group of pixels */
imutil.c:int	ix,iy;	/* Pixel around which to compute Gaussian-weighted mean */
imutil.c:	if (ixi > -1 && iyi > -1 && ixi < nx && iyi < ny) {
imutil.c:    /* If enough surrounding pixels are non-zero, replace the current pixel */
imutil.c:int	ix,iy;	/* Pixel around which to compute Gaussian-weighted mean */
imutil.c:	if (ixi > -1 && iyi > -1 && ixi < nx && iyi < ny) {
imutil.c:    /* If enough surrounding pixels are non-zero, replace the current pixel */
imutil.c:int	ix,iy;	/* Pixel around which to compute Gaussian-weighted mean */
imutil.c:	if (ixi > -1 && iyi > -1 && ixi < nx && iyi < ny) {
imutil.c:    /* If enough surrounding pixels are non-zero, replace the current pixel */
imutil.c:int	ix,iy;	/* Pixel around which to compute Gaussian-weighted mean */
imutil.c:	if (ixi > -1 && iyi > -1 && ixi < nx && iyi < ny) {
imutil.c:    /* If enough surrounding pixels are non-zero, replace the current pixel */
imutil.c:    else if (bitpix == -32) {
imutil.c:    else if (bitpix == -64) {
imutil.c:		nyf = ny - ky + 1;
imutil.c:		    nxf = nx - kx + 1;
imutil.c:		    case -32:
imutil.c:		    case -64:
imutil.c:		    case -32:
imutil.c:		    case -64:
imutil.c:/* PhotPix -- Compute counts within a strictly defined circular aperture
imutil.c:    iy1 = (int) (cy - rad);
imutil.c:    ix1 = (int) (cx - rad);
imutil.c:/* IMAPFR -- Determine the fraction of a square pixel that is included
imutil.c:    dc = fabs (pcol - ccol);
imutil.c:    dr = fabs (prow - crow);
imutil.c:    dc5 = dc - 0.5;
imutil.c:    dr5 = dr - 0.5;
imutil.c:    if ((pcol-0.5) < ccol && ccol < (pcol+.5)) {
imutil.c:	else if ((prow - 0.5) < crow && crow < (prow + 0.5)) {
imutil.c:    y = prow - 1.5;
imutil.c:	x = pcol - 1.50;
imutil.c:	    dx = x - ccol;
imutil.c:	    dy = y - crow;
imutil.c:	if ((pcol - 0.5) >= ccol || ccol >= (pcol + 0.5)) {
imutil.c:	    xdiff = fabs (pcol - ccol) - 0.5;
imutil.c:	    dx = sqrt (rad*rad - xdiff*xdiff);
imutil.c:	    y0 = crow - dx;
imutil.c:		x = pcol - 0.5;
imutil.c:	    frac = -xdiff * (y1 - y0) + apint ((y1 - crow), rad) -
imutil.c:		   apint ((y0 - crow), rad);
imutil.c:	    ydiff = fabs (prow - crow) - 0.5;
imutil.c:	    dy = sqrt (rad*rad - ydiff*ydiff);
imutil.c:	    x0 = ccol - dy;
imutil.c:		y = prow - 0.5;
imutil.c:	    frac = -ydiff*(x1 - x0) + apint ((x1 - ccol),rad) -
imutil.c:		   apint ((x0 - ccol),rad);
imutil.c:	    ydiff = fabs (prow - crow) - 0.5;;
imutil.c:	    x0 = ccol - sqrt (rad*rad - ydiff*ydiff);
imutil.c:		y = prow - 0.5;
imutil.c:	    frac = -ydiff*(pcol + 0.5 - x0) + apint ((pcol + 0.5 - ccol),rad) -
imutil.c:		   apint ((x0 - ccol),rad);
imutil.c:	    ydiff = fabs (crow - prow) - 0.5;
imutil.c:	    x1 = ccol + sqrt (rad*rad - ydiff*ydiff);
imutil.c:		y = prow - 0.5;
imutil.c:	    frac = -ydiff*(x1 - pcol + 0.5) + apint ((x1 - ccol),rad) -
imutil.c:		   apint ((pcol - .5 - ccol),rad);
imutil.c:    /* determine whether this may be a 4-intersection configuration */
imutil.c:	if (((pcol - 0.5) < ccol && ccol < (pcol + .5) &&
imutil.c:	    (fabs(crow - prow) + 0.5) < rad) ||
imutil.c:	    ((prow - 0.5) < crow && crow < (prow + 0.5) &&
imutil.c:	    (fabs(ccol - pcol) + 0.5) < rad)) {
imutil.c:   determine whether the pixel is east-west or north-south. */
imutil.c:	    /* pixel is east-west */
imutil.c:	    if ((pcol - 0.5) >= ccol || (pcol + 0.5) <= ccol) {
imutil.c:		dx = sqrt (rad*rad - xdiff*xdiff);
imutil.c:		y0 = crow - dx;
imutil.c:		    x = pcol - .5;
imutil.c:		frac = 1. - xdiff*(y0 - y1 + 1.0) +
imutil.c:			apint ((y0 - crow), rad) -
imutil.c:			apint ((prow - 0.5 - crow), rad) +
imutil.c:			apint ((prow + 0.5 - crow), rad) -
imutil.c:			apint ((y1 - crow), rad);
imutil.c:	    /* Pixel is north-south */
imutil.c:		dy = sqrt (rad*rad - ydiff*ydiff);
imutil.c:		/* x0 is the x-coordinate of the small x intercept */
imutil.c:		x0 = ccol - dy;
imutil.c:		/* x1 is the x-coordinate of the large x intercept */
imutil.c:		    y = prow - 0.5;
imutil.c:		frac = 1. - ydiff * (x0 - x1 + 1.0) +
imutil.c:			apint ((x0 - ccol), rad) -
imutil.c:			apint ((pcol - 0.5 - ccol), rad) +
imutil.c:			apint ((pcol + 0.5 - ccol), rad) -
imutil.c:			apint ((x1 - ccol), rad);
imutil.c:	/* in the two-intersection case, determine which corners are included */
imutil.c:		cterm = 0.5 - dr;
imutil.c:		ulim = apint ((pcol + 0.5 - ccol) ,rad);
imutil.c:		llim = apint ((pcol - 0.5 - ccol) ,rad);
imutil.c:		frac = cterm + ulim - llim;
imutil.c:		cterm = 0.5 - dc;
imutil.c:		ulim = apint ((prow + 0.5 - crow), rad);
imutil.c:		llim = apint ((prow - 0.5 - crow), rad);
imutil.c:		frac = cterm + ulim - llim;
imutil.c:		y = prow - 0.5;
imutil.c:	    x0 = ccol + sqrt (rad*rad - ydiff*ydiff);
imutil.c:	    frac = 1.0 - (ydiff * (pcol + 0.5 - x0)) +
imutil.c:		   apint ((pcol + 0.5 - ccol), rad) -
imutil.c:		   apint ((x0 - ccol), rad);
imutil.c:		y = prow - 0.5;
imutil.c:	    x0 = ccol - sqrt (rad*rad - ydiff*ydiff);
imutil.c:	    frac = 1. - ydiff*(x0 - pcol + 0.5) +
imutil.c:		   apint ((x0 - ccol),rad) -
imutil.c:		   apint ((pcol - 0.5 - ccol),rad);
imutil.c:/* APINT -- Evaluate the integral of sqrt (rad**2 - x**2) dx at one limit */
imutil.c:    arcsin = atan2 (arg, sqrt (1.0 - arg2));
imutil.c:    if ((1. - fabs (arg)) < 0.000001) {
imutil.c:	    arcsin = -pi / 2.0;
imutil.c:    return (0.5 * (x * sqrt (rad2 - x2) + rad2 * arcsin));
imutil.c: * May 16 2012	Add medpixi1() and meanpixi1() to handle 8-bit images
lin.c:*   WCSLIB - an implementation of the FITS WCS proposal.
lin.c:*   Copyright (C) 1995-2002, Mark Calabretta
lin.c:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
lin.c:*   -------------------
lin.c:*   FITS header cards.  There are separate routines for the image-to-pixel,
lin.c:*   linfwd(), and pixel-to-image, linrev(), transformations.
lin.c:*   the transformation parameters but need not be called explicitly - see the
lin.c:*   LU-triangular factorization with scaled partial pivoting.
lin.c:*   --------------------------------
lin.c:*   --------------------------------
lin.c:*   --------------------------------
lin.c:*   --------------------------------
lin.c:*         This may be conveniently constructed from a two-dimensional array
lin.c:   n = lin->naxis;
lin.c:	 lin->naxis_sqr= (lin->naxis)*(lin->naxis);
lin.c:   lin->piximg = (double*)malloc(mem);
lin.c:   if (lin->piximg == (double*)0) return 1;
lin.c:   lin->imgpix = (double*)malloc(mem);
lin.c:   if (lin->imgpix == (double*)0) {
lin.c:      free(lin->piximg);
lin.c:   /* Compute the pixel-to-image transformation matrix. */
lin.c:         lin->piximg[ij] = lin->cdelt[i] * lin->pc[ij];
lin.c:   /* Compute the image-to-pixel transformation matrix. */
lin.c:   if (matinv(n, lin->piximg, lin->imgpix)) return 2;
lin.c:   lin->flag = LINSET;
lin.c:/*--------------------------------------------------------------------------*/
lin.c:   n = lin->naxis;
lin.c:	 lin->naxis_sqr= (lin->naxis)*(lin->naxis);
lin.c:   if (lin->flag != LINSET) {
lin.c:         pixcrd[i] += lin->imgpix[ij] * imgcrd[j];
lin.c:      pixcrd[j] += lin->crpix[j];
lin.c:/*--------------------------------------------------------------------------*/
lin.c:   n = lin->naxis;
lin.c:   lin->naxis_sqr= (lin->naxis)*(lin->naxis);
lin.c:   if (lin->flag != LINSET) {
lin.c:      temp = pixcrd[j] - lin->crpix[j];
lin.c:         imgcrd[i] += lin->piximg[ij] * temp;
lin.c:/*--------------------------------------------------------------------------*/
lin.c:               lu[i*n+j] -= lu[ik]*lu[k*n+j];
lin.c:            inv[i*n+k] -= lu[i*n+j]*inv[j*n+k];
lin.c:      for (i = n-1; i >= 0; i--) {
lin.c:            inv[i*n+k] -= lu[i*n+j]*inv[j*n+k];
lin.c:/* Dec 20 1999	Doug Mink - Include wcslib.h, which includes lin.h
lin.c: * Feb 15 2001	Doug Mink - Add comments for WCSLIB 2.6; no code changes
lin.c: * Sep 19 2001	Doug Mink - Add above change to WCSLIB 2.7 code
lin.c: * Nov 20 2001	Doug Mink - Always include stdlib.h
lin.c: * Jan 15 2002	Bill Joye - Add ifdef so this compiles on MacOS/X
lin.c: * Nov 18 2003	Doug Mink - Include stdlib.h instead of malloc.h
log.c:*   WCSLIB 4.2 - an implementation of the FITS WCS standard.
log.c:*   Copyright (C) 1995-2005, Mark Calabretta
log.c:*   59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
log.c:   "Invalid log-coordinate reference value",
log.c:/*--------------------------------------------------------------------------*/
log.c:/*--------------------------------------------------------------------------*/
lwcs.h: *** Harvard-Smithsonian Center for Astrophysics
lwcs.h: *** Copyright (C) 1999-2006
lwcs.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
lwcs.h:#define	NSTATPIX	25	/* Stats are computed for +- this many pixels */
lwcs.h:#define RNOISE	 	50	/* Mean noise is from center +- this many pixels */
lwcs.h:#define PIXDIFF		10	/* +- this many pixels is a match */
Makefile:CFLAGS= -g -D_FILE_OFFSET_BITS=64 -fPIC
Makefile:	rm -f *.a *.o
matchstar1.c: *** Harvard-Smithsonian Center for Astrophysics
matchstar1.c: *** Copyright (C) 1996-2006
matchstar1.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
matchstar1.c: *  Find shift, scale, and rotation of image stars to best-match reference stars
matchstar1.c: *  Read in x, y, RA, and Dec of pre-match stars in image
matchstar1.c: *  Find shift, scale, and rotation of image stars to best-match reference stars
matchstar1.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
matchstar1.c:/* Find shift, scale, and rotation of image stars to best-match reference stars
matchstar1.c: * Return count of total coincidences found, else 0 if none or -1 if trouble.
matchstar1.c:double	tol;		/* +/- this many pixels is a hit */
matchstar1.c:	    dx  = gx[g] - sx[s];
matchstar1.c:	    dy = gy[g] - sy[s];
matchstar1.c:	    if ((idx > -nbx && idx < nbx && idy > -nby && idy < nby)
matchstar1.c:    for (idy = -nby; idy < nby; idy++) {
matchstar1.c:	for (idx = -nbx; idx < nbx; idx++) {
matchstar1.c:		idymax - idy;
matchstar1.c:		dx = gx[g] - sx[s];
matchstar1.c:		dy = gy[g] - sy[s];
matchstar1.c:			dxi = gx[gi] - sx[si] - dx;
matchstar1.c:			    dxi = -dxi;
matchstar1.c:			dyi = gy[gi] - sy[si] - dy;
matchstar1.c:			    dyi = -dyi;
matchstar1.c:			for (i = npeaks; i > 0; i--) {
matchstar1.c:			    peaks[i] = peaks[i-1];
matchstar1.c:			    dxpeaks[i] = dxpeaks[i-1];
matchstar1.c:			    dypeaks[i] = dypeaks[i-1];
matchstar1.c:			dxpeaks[0] = (int) (bestdx - 0.5);
matchstar1.c:			dypeaks[0] = (int) (bestdy - 0.5);
matchstar1.c:    wcs->xref = wcs->xref + (bestdx * wcs->xinc);
matchstar1.c:    if (wcs->xref < 0.0) wcs->xref = 360.0 + wcs->xref;
matchstar1.c:    wcs->yref = wcs->yref + (bestdy * wcs->yinc);
matchstar1.c:    /* Provide non-parametric access to the star lists */
matchstar1.c:    xref_p = wcs->xref;
matchstar1.c:    yref_p = wcs->yref;
matchstar1.c:    xrefpix = wcs->xrefpix;
matchstar1.c:    yrefpix = wcs->yrefpix;
matchstar1.c:    vfit[0] = -1;
matchstar1.c:	    vfit[i] = vi - vpar;
matchstar1.c:	    vfit[i] = -1;
matchstar1.c:    xref0 = wcs->xref;
matchstar1.c:    yref0 = wcs->yref;
matchstar1.c:    xinc0 = wcs->xinc;
matchstar1.c:    yinc0 = wcs->yinc;
matchstar1.c:    rot0 = wcs->rot;
matchstar1.c:    xrefpix0 = wcs->xrefpix;
matchstar1.c:    yrefpix0 = wcs->yrefpix;
matchstar1.c:    cd0[0] = wcs->cd[0];
matchstar1.c:    cd0[1] = wcs->cd[1];
matchstar1.c:    cd0[2] = wcs->cd[2];
matchstar1.c:    cd0[3] = wcs->cd[3];
matchstar1.c:    if (vfit[6] > -1)
matchstar1.c:	if (vfit[6] > -1)
matchstar1.c:	ra2str (rastr, 16, wcs->xref, 3);
matchstar1.c:	dec2str (decstr, 16, wcs->yref, 2);
matchstar1.c:	if (vfit[6] > -1)
matchstar1.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
matchstar1.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
matchstar1.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar1.c:	double dmatch1 = (double)(nmatch - 1);
matchstar1.c:	    xe[i] = (mx - gbra[i]) * 3600.0;
matchstar1.c:	    ye[i] = (my - gbdec[i]) * 3600.0;
matchstar1.c:		fprintf (stderr,"%3d (%8.3f,%8.3f) -> %s %6.3f %6.3f %6.3f\n",
matchstar1.c:	    diff = xe[i] - xmean;
matchstar1.c:	    diff = ye[i] - ymean;
matchstar1.c:	for (i = 0; i < nmatch-1; i++) {
matchstar1.c:		if (i > bestbin) bestbin = i - 1;
matchstar1.c:	xref_p = wcs->xref;
matchstar1.c:	yref_p = wcs->yref;
matchstar1.c:	xrefpix = wcs->xrefpix;
matchstar1.c:	yrefpix = wcs->yrefpix;
matchstar1.c:	    ra2str (rastr, 16, wcs->xref, 3);
matchstar1.c:	    dec2str (decstr, 16, wcs->yref, 2);
matchstar1.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
matchstar1.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar1.c:	    lastchar = nextline + strlen(nextline) - 1;
matchstar1.c:		    if (strchr (token, '-') != NULL)
matchstar1.c:				dec = dec - (atof (token) / 60.0);
matchstar1.c:				dec = dec - (atof (token) / 60.0);
matchstar1.c:					dec = dec - (atof (token) / 3600.0);
matchstar1.c:/* Find shift, scale, and rotation of image stars to best-match reference stars
matchstar1.c:	    xdiff = sbx[j] - sbx[i];
matchstar1.c:	    ydiff = sby[j] - sby[i];
matchstar1.c:    if (cra == -99.0 && cdec == -99.0) {
matchstar1.c:    if (cx == -99999.0) {
matchstar1.c:/* Find shift, scale, and rotation of image stars to best-match reference stars
matchstar1.c: * Return count of total coincidences found, else 0 if none or -1 if trouble.
matchstar1.c:/*    double equinox = wcs->equinox; */
matchstar1.c:	    xdiff = sbx[j] - sbx[i];
matchstar1.c:	    ydiff = sby[j] - sby[i];
matchstar1.c:    /* Provide non-parametric access to the star lists */
matchstar1.c:    xref_p = wcs->xref;
matchstar1.c:    yref_p = wcs->yref;
matchstar1.c:    xrefpix = wcs->xrefpix;
matchstar1.c:    yrefpix = wcs->yrefpix;
matchstar1.c:    vfit[0] = -1;
matchstar1.c:	    vfit[i] = vi - vpar;
matchstar1.c:	    vfit[i] = -1;
matchstar1.c:    xref0 = wcs->xref;
matchstar1.c:    yref0 = wcs->yref;
matchstar1.c:    xinc0 = wcs->xinc;
matchstar1.c:    yinc0 = wcs->yinc;
matchstar1.c:    rot0 = wcs->rot;
matchstar1.c:    xrefpix0 = wcs->xrefpix;
matchstar1.c:    yrefpix0 = wcs->yrefpix;
matchstar1.c:    cd0[0] = wcs->cd[0];
matchstar1.c:    cd0[1] = wcs->cd[1];
matchstar1.c:    cd0[2] = wcs->cd[2];
matchstar1.c:    cd0[3] = wcs->cd[3];
matchstar1.c:    if (vfit[6] > -1)
matchstar1.c:	if (vfit[6] > -1)
matchstar1.c:	ra2str (rastr, 16, wcs->xref, 3);
matchstar1.c:	dec2str (decstr, 16, wcs->yref, 2);
matchstar1.c:	if (vfit[6] > -1)
matchstar1.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
matchstar1.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
matchstar1.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar1.c:	double dmatch1 = (double)(nmatch - 1);
matchstar1.c:	    xe[i] = (mra - gbra[i]) * 3600.0;
matchstar1.c:	    ye[i] = (mdec - gbdec[i]) * 3600.0;
matchstar1.c:		fprintf (stderr,"%3d (%8.3f,%8.3f) -> %s %6.3f %6.3f %6.3f\n",
matchstar1.c:	    diff = xe[i] - xmean;
matchstar1.c:	    diff = ye[i] - ymean;
matchstar1.c:	for (i = 0; i < nmatch-1; i++) {
matchstar1.c:		if (i > bestbin) bestbin = i - 1;
matchstar1.c:	xref_p = wcs->xref;
matchstar1.c:	yref_p = wcs->yref;
matchstar1.c:	xrefpix = wcs->xrefpix;
matchstar1.c:	yrefpix = wcs->yrefpix;
matchstar1.c:	    ra2str (rastr, 16, wcs->xref, 3);
matchstar1.c:	    dec2str (decstr, 16, wcs->yref, 2);
matchstar1.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
matchstar1.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar1.c:	   p5[NPAR], p6[NPAR], p7[NPAR], p8[NPAR]; /* used as px[0..NPAR-1] */
matchstar1.c:    if (vfit[1] > -1) {
matchstar1.c:	vdiff[vfit[1]] = 5.0 * wcsf->xinc;
matchstar1.c:    if (vfit[2] > -1) {
matchstar1.c:	vdiff[vfit[2]] = 5.0 * wcsf->yinc;
matchstar1.c:    /* Second rotation about optical axis (degrees) -> CD matrix */
matchstar1.c:    if (vfit[6] > -1) {
matchstar1.c:	wcsf->rotmat = 1;
matchstar1.c:	vguess[vfit[3]] = wcsf->cd[0];
matchstar1.c:	vdiff[vfit[3]] = wcsf->xinc * 0.03;
matchstar1.c:	vguess[vfit[4]] = wcsf->cd[1];
matchstar1.c:	vdiff[vfit[4]] = wcsf->yinc * 0.03;
matchstar1.c:	vguess[vfit[5]] = wcsf->cd[2];
matchstar1.c:	vdiff[vfit[5]] = wcsf->xinc * 0.03;
matchstar1.c:	vguess[vfit[6]] = wcsf->cd[3];
matchstar1.c:	vdiff[vfit[6]] = wcsf->yinc * 0.03;
matchstar1.c:	if (vfit[3] > -1) {
matchstar1.c:	    vguess[vfit[3]] = wcsf->xinc;
matchstar1.c:	    vdiff[vfit[3]] = wcsf->xinc * 0.03;
matchstar1.c:	if (vfit[4] > -1) {
matchstar1.c:	    vguess[vfit[4]] = wcsf->yinc;
matchstar1.c:	    vdiff[vfit[4]] = wcsf->yinc * 0.03;
matchstar1.c:	if (vfit[5] > -1) {
matchstar1.c:	    vguess[vfit[5]] = wcsf->rot;
matchstar1.c:    if (vfit[7] > -1) {
matchstar1.c:    if (vfit[8] > -1) {
matchstar1.c:	    p[i][i-1] = vguess[i-1] + vdiff[i-1];
matchstar1.c:	 y[i] = wcs_chisqr (p[i], -i);
matchstar1.c:	if (vfit[1] > -1)
matchstar1.c:	    ra2str (rastr, 16, wcsf->xref, 3);
matchstar1.c:	if (vfit[2] > -1)
matchstar1.c:	    dec2str (decstr, 16, wcsf->yref, 2);
matchstar1.c:	if (vfit[6] > -1) {
matchstar1.c:	    if (vfit[3] > -1)
matchstar1.c:		xinc1 = wcsf->xinc;
matchstar1.c:	    if (vfit[4] > -1)
matchstar1.c:	    else if (vfit[3] > -1) {
matchstar1.c:		    yinc1 = -xinc1;
matchstar1.c:		yinc1 = wcsf->yinc;
matchstar1.c:	    if (vfit[5] > -1)
matchstar1.c:		rot = wcsf->rot;
matchstar1.c:	if (vfit[7] > -1)
matchstar1.c:	    xrefpix1 = wcsf->xrefpix;
matchstar1.c:	if (vfit[8] > -1)
matchstar1.c:	    yrefpix1 = wcsf->yrefpix;
matchstar1.c:	if (vfit[1] > -1)
matchstar1.c:	    ra2str (rastr, 16, wcsf->xref, 3);
matchstar1.c:	if (vfit[2] > -1)
matchstar1.c:	    dec2str (decstr, 16, wcsf->yref, 2);
matchstar1.c:	if (vfit[6] > -1) {
matchstar1.c:	    if (vfit[3] > -1)
matchstar1.c:		xinc1 = wcsf->xinc;
matchstar1.c:	    if (vfit[4] > -1)
matchstar1.c:	    else if (vfit[3] > -1) {
matchstar1.c:		    yinc1 = -xinc1;
matchstar1.c:		yinc1 = wcsf->yinc;
matchstar1.c:	    if (vfit[5] > -1)
matchstar1.c:		rot = wcsf->rot;
matchstar1.c:	if (vfit[7] > -1)
matchstar1.c:	    xrefpix1 = wcsf->xrefpix;
matchstar1.c:	if (vfit[8] > -1)
matchstar1.c:	    yrefpix1 = wcsf->yrefpix;
matchstar1.c:    if (vfit[1] > -1) {
matchstar1.c:	wcsf->xref = xref_p + vp[vfit[1]];
matchstar1.c:	if (wcsf->xref < 0.0) wcsf->xref = 360.0 + wcsf->xref;
matchstar1.c:    if (vfit[2] > -1)
matchstar1.c:	wcsf->yref = yref_p + vp[vfit[2]];
matchstar1.c:    if (vfit[6] > -1) {
matchstar1.c:	wcsf->cd[0] = vp[vfit[3]];
matchstar1.c:	wcsf->cd[1] = vp[vfit[4]];
matchstar1.c:	wcsf->cd[2] = vp[vfit[5]];
matchstar1.c:	wcsf->cd[3] = vp[vfit[6]];
matchstar1.c:	if (vfit[3] > -1)
matchstar1.c:	    wcsf->xinc = vp[vfit[3]];
matchstar1.c:	if (vfit[4] > -1)
matchstar1.c:	    wcsf->yinc = vp[vfit[4]];
matchstar1.c:	else if (vfit[3] > -1) {
matchstar1.c:	    if (wcsf->xinc < 0)
matchstar1.c:		wcsf->yinc = -wcsf->xinc;
matchstar1.c:		wcsf->yinc = wcsf->xinc;
matchstar1.c:	if (vfit[5] > -1)
matchstar1.c:	    wcsf->rot = vp[vfit[5]];
matchstar1.c:    if (vfit[7] > -1)
matchstar1.c:	wcsf->xrefpix = xrefpix + vp[vfit[7]];
matchstar1.c:    if (vfit[8] > -1)
matchstar1.c:	wcsf->yrefpix = yrefpix + vp[vfit[8]];
matchstar1.c:    ra2str (rastr, 16, wcsf->xref, 3);
matchstar1.c:    dec2str (decstr, 16, wcsf->yref, 2);
matchstar1.c:    if (vfit[6] > -1)
matchstar1.c:		rastr, decstr, wcsf->cd[0], wcsf->cd[1], wcsf->cd[2],
matchstar1.c:		wcsf->cd[3]);
matchstar1.c:		rastr, decstr, wcsf->xinc*3600.0, wcsf->yinc*3600.0, wcsf->rot);
matchstar1.c:    fprintf (stderr,"(%8.2f,%8.2f)\n", wcsf->xrefpix, wcsf->yrefpix);
matchstar1.c:	ex = 3600.0 * (mra - gra_p[i]);
matchstar1.c:	ey = 3600.0 * (mdec - gdec_p[i]);
matchstar1.c: * v[4]=rotation, v[5]=2nd rotation->CD matrix, v[6]=ref x, and v[7] = ref y
matchstar1.c:    if (vfit[1] > -1)
matchstar1.c:	crval1 = wcsf->xref;
matchstar1.c:    if (vfit[2] > -1)
matchstar1.c:	crval2 = wcsf->yref;
matchstar1.c:    if (vfit[6] > -1) {
matchstar1.c:	if (vfit[3] > -1)
matchstar1.c:	    cdelt1 = wcsf->xinc;
matchstar1.c:	if (vfit[4] > -1)
matchstar1.c:	else if (vfit[3] > -1) {
matchstar1.c:		cdelt2 = -cdelt1;
matchstar1.c:	    cdelt2 = wcsf->yinc;
matchstar1.c:	if (vfit[5] > -1)
matchstar1.c:	    crota = wcsf->rot;
matchstar1.c:    if (vfit[7] > -1)
matchstar1.c:	crpix1 = wcsf->xrefpix;
matchstar1.c:    if (vfit[8] > -1)
matchstar1.c:	crpix2 = wcsf->yrefpix;
matchstar1.c:	    dx = xmp - sx_p[i];
matchstar1.c:	    dy = ymp - sy_p[i];
matchstar1.c:    ra2str (rastr, 16, wcsf->xref, 3);
matchstar1.c:    dec2str (decstr, 16, wcsf->yref, 2);
matchstar1.c:    if (vfit[6] > -1)
matchstar1.c:		iter, rastr, decstr, wcsf->cd[0],wcsf->cd[1],wcsf->cd[2],
matchstar1.c:		wcsf->cd[3]);
matchstar1.c:		iter, rastr, decstr, wcsf->xinc*3600.0, wcsf->yinc*3600.0,
matchstar1.c:		wcsf->rot);
matchstar1.c:    fprintf (stderr,"(%8.2f,%8.2f) -> %f\r",
matchstar1.c:	     wcsf->xrefpix, wcsf->yrefpix, chsq);
matchstar1.c:	rtol = 2.0 * fabs(y[ihi]-y[ilo]) / (fabs(y[ihi]) + fabs(y[ilo]));
matchstar1.c:	ytry = amotry (p, y, psum, ndim, funk, ihi, nfunk, -ALPHA);
matchstar1.c:    fac1 = (1.0 - fac) / ndim;
matchstar1.c:    fac2 = fac1 - fac;
matchstar1.c:	ptry[j] = psum[j] * fac1 - p[ihi][j] * fac2;
matchstar1.c:    	    psum[j] +=  ptry[j] - p[ihi][j];
matchstar1.c:	pfit0 = -nfit;
matchstar1.c: * Mar  3 1998	Fix residual-refining code
matchstar1.c: * Jul 21 1999	Add FitMatch() to fit WCS to already-matched stars
matchstar1.c: * Sep  8 1999	Fix bug found by Jean-Baptiste Marquette
matchstar.c: *** Harvard-Smithsonian Center for Astrophysics
matchstar.c: *** Copyright (C) 1996-2011
matchstar.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
matchstar.c: *  Find shift, scale, and rotation of image stars to best-match reference stars
matchstar.c: *  Read in x, y, RA, and Dec of pre-match stars in image
matchstar.c: *  Find shift, scale, and rotation of image stars to best-match reference stars
matchstar.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
matchstar.c:/* Find shift, scale, and rotation of image stars to best-match reference stars
matchstar.c: * Return count of total coincidences found, else 0 if none or -1 if trouble.
matchstar.c:double	tol;		/* +/- this many pixels is a hit */
matchstar.c:    /* Build 2-d histogram of offset distribution */
matchstar.c:	nbx = wcs->nxpix / tol2;
matchstar.c:	nnbx = -nbx;
matchstar.c:	nby = wcs->nypix / tol2;
matchstar.c:	nnby = -nby;
matchstar.c:		dx  = gx[g] - sx[s];
matchstar.c:		dy = gy[g] - sy[s];
matchstar.c:	    bestdx = tol2 * (double) (idxmax - nbx);
matchstar.c:	    bestdy = tol2 * (double) (idymax - nby);
matchstar.c:	    igs = -1;
matchstar.c:		dx = gx[g] - sx[s];
matchstar.c:		dy = gy[g] - sy[s];
matchstar.c:	    if (igs > -1) {
matchstar.c:			dxsum = dxsum - mx[igs];
matchstar.c:			dysum = dysum - my[igs];
matchstar.c:		dx = gx[g] - sx[s];
matchstar.c:		dy = gy[g] - sy[s];
matchstar.c:			dxi = gx[gi] - sx[si] - dx;
matchstar.c:			    dxi = -dxi;
matchstar.c:			dyi = gy[gi] - sy[si] - dy;
matchstar.c:			    dyi = -dyi;
matchstar.c:			for (i = npeaks; i > 0; i--) {
matchstar.c:			    peaks[i] = peaks[i-1];
matchstar.c:			    dxpeaks[i] = dxpeaks[i-1];
matchstar.c:			    dypeaks[i] = dypeaks[i-1];
matchstar.c:			dxpeaks[0] = (int) (bestdx - 0.5);
matchstar.c:			dypeaks[0] = (int) (bestdy - 0.5);
matchstar.c:    wcs->xref = wcs->xref + (bestdx * wcs->xinc);
matchstar.c:    if (wcs->xref < 0.0) wcs->xref = 360.0 + wcs->xref;
matchstar.c:    wcs->yref = wcs->yref + (bestdy * wcs->yinc);
matchstar.c:    /* Provide non-parametric access to the star lists */
matchstar.c:    xref_p = wcs->xref;
matchstar.c:    yref_p = wcs->yref;
matchstar.c:    xrefpix = wcs->xrefpix;
matchstar.c:    yrefpix = wcs->yrefpix;
matchstar.c:    vfit[0] = -1;
matchstar.c:	    vfit[i] = vi - vpar;
matchstar.c:	    vfit[i] = -1;
matchstar.c:    xref0 = wcs->xref;
matchstar.c:    yref0 = wcs->yref;
matchstar.c:    xinc0 = wcs->xinc;
matchstar.c:    yinc0 = wcs->yinc;
matchstar.c:    rot0 = wcs->rot;
matchstar.c:    xrefpix0 = wcs->xrefpix;
matchstar.c:    yrefpix0 = wcs->yrefpix;
matchstar.c:    cd0[0] = wcs->cd[0];
matchstar.c:    cd0[1] = wcs->cd[1];
matchstar.c:    cd0[2] = wcs->cd[2];
matchstar.c:    cd0[3] = wcs->cd[3];
matchstar.c:    if (vfit[6] > -1)
matchstar.c:	if (vfit[6] > -1)
matchstar.c:	ra2str (rastr, 31, wcs->xref, 3);
matchstar.c:	dec2str (decstr, 31, wcs->yref, 2);
matchstar.c:	if (vfit[6] > -1)
matchstar.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
matchstar.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
matchstar.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar.c:	double dmatch1 = (double)(nmatch - 1);
matchstar.c:	    xe[i] = (mx - gbra[i]) * 3600.0;
matchstar.c:	    ye[i] = (my - gbdec[i]) * 3600.0;
matchstar.c:		fprintf (stderr,"%3d (%8.3f,%8.3f) -> %s %6.3f %6.3f %6.3f\n",
matchstar.c:	    diff = xe[i] - xmean;
matchstar.c:	    diff = ye[i] - ymean;
matchstar.c:	for (i = 0; i < nmatch-1; i++) {
matchstar.c:		if (i > bestbin) bestbin = i - 1;
matchstar.c:	xref_p = wcs->xref;
matchstar.c:	yref_p = wcs->yref;
matchstar.c:	xrefpix = wcs->xrefpix;
matchstar.c:	yrefpix = wcs->yrefpix;
matchstar.c:	    ra2str (rastr, 31, wcs->xref, 3);
matchstar.c:	    dec2str (decstr, 31, wcs->yref, 2);
matchstar.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
matchstar.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar.c:	    lastchar = nextline + strlen(nextline) - 1;
matchstar.c:		    if (strchr (token, '-') != NULL)
matchstar.c:				dec = dec - (atof (token) / 60.0);
matchstar.c:				dec = dec - (atof (token) / 60.0);
matchstar.c:					dec = dec - (atof (token) / 3600.0);
matchstar.c:/* Find shift, scale, and rotation of image stars to best-match reference stars
matchstar.c:		gbra[i] = gbra[i] - 360.0;
matchstar.c:    for (i = 0; i < nmatch-1; i++) {
matchstar.c:	    xdiff = sbx[j] - sbx[i];
matchstar.c:	    ydiff = sby[j] - sby[i];
matchstar.c:    tx = tx + sbx[nmatch-1];
matchstar.c:    ty = ty + sby[nmatch-1];
matchstar.c:    tra = tra + gbra[nmatch-1];
matchstar.c:    tdec = tdec + gbdec[nmatch-1];
matchstar.c:    cra = -99.0;
matchstar.c:    cdec = -99.0;
matchstar.c:    if (cra == -99.0 && cdec == -99.0) {
matchstar.c:    cx = -99999.0;
matchstar.c:    cy = -99999.0;
matchstar.c:    if (cx == -99999.0) {
matchstar.c:/* Find shift, scale, and rotation of image stars to best-match reference stars
matchstar.c: * Return count of total coincidences found, else 0 if none or -1 if trouble.
matchstar.c:/*    double equinox = wcs->equinox; */
matchstar.c:	    xdiff = sbx[j] - sbx[i];
matchstar.c:	    ydiff = sby[j] - sby[i];
matchstar.c:    /* Provide non-parametric access to the star lists */
matchstar.c:    xref_p = wcs->xref;
matchstar.c:    yref_p = wcs->yref;
matchstar.c:    xrefpix = wcs->xrefpix;
matchstar.c:    yrefpix = wcs->yrefpix;
matchstar.c:    vfit[0] = -1;
matchstar.c:	    vfit[i] = vi - vpar;
matchstar.c:	    vfit[i] = -1;
matchstar.c:    xref0 = wcs->xref;
matchstar.c:    yref0 = wcs->yref;
matchstar.c:    xinc0 = wcs->xinc;
matchstar.c:    yinc0 = wcs->yinc;
matchstar.c:    rot0 = wcs->rot;
matchstar.c:    xrefpix0 = wcs->xrefpix;
matchstar.c:    yrefpix0 = wcs->yrefpix;
matchstar.c:    cd0[0] = wcs->cd[0];
matchstar.c:    cd0[1] = wcs->cd[1];
matchstar.c:    cd0[2] = wcs->cd[2];
matchstar.c:    cd0[3] = wcs->cd[3];
matchstar.c:    if (vfit[6] > -1)
matchstar.c:	if (vfit[6] > -1)
matchstar.c:	ra2str (rastr, 31, wcs->xref, 3);
matchstar.c:	dec2str (decstr, 31, wcs->yref, 2);
matchstar.c:	if (vfit[6] > -1)
matchstar.c:		     rastr,decstr,wcs->cd[0],wcs->cd[1],wcs->cd[2],wcs->cd[3]);
matchstar.c:		     rastr,decstr,3600.0*wcs->xinc,3600.0*wcs->yinc,wcs->rot);
matchstar.c:	fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar.c:	double dmatch1 = (double)(nmatch - 1);
matchstar.c:	    xe[i] = (mra - gbra[i]) * 3600.0;
matchstar.c:	    ye[i] = (mdec - gbdec[i]) * 3600.0;
matchstar.c:		fprintf (stderr,"%3d (%8.3f,%8.3f) -> %s %6.3f %6.3f %6.3f\n",
matchstar.c:	    diff = xe[i] - xmean;
matchstar.c:	    diff = ye[i] - ymean;
matchstar.c:	for (i = 0; i < nmatch-1; i++) {
matchstar.c:		if (i > bestbin) bestbin = i - 1;
matchstar.c:	xref_p = wcs->xref;
matchstar.c:	yref_p = wcs->yref;
matchstar.c:	xrefpix = wcs->xrefpix;
matchstar.c:	yrefpix = wcs->yrefpix;
matchstar.c:	    ra2str (rastr, 31, wcs->xref, 3);
matchstar.c:	    dec2str (decstr, 31, wcs->yref, 2);
matchstar.c:		 rastr, decstr, 3600.0*wcs->xinc, 3600.0*wcs->yinc, wcs->rot);
matchstar.c:	    fprintf (stderr,"(%8.2f,%8.2f)\n", wcs->xrefpix, wcs->yrefpix);
matchstar.c:	   p5[NPAR], p6[NPAR], p7[NPAR], p8[NPAR]; /* used as px[0..NPAR-1] */
matchstar.c:    if (vfit[1] > -1) {
matchstar.c:	vdiff[vfit[1]] = 5.0 * wcsf->xinc;
matchstar.c:    if (vfit[2] > -1) {
matchstar.c:	vdiff[vfit[2]] = 5.0 * wcsf->yinc;
matchstar.c:    /* Second rotation about optical axis (degrees) -> CD matrix */
matchstar.c:    if (vfit[6] > -1) {
matchstar.c:	wcsf->rotmat = 1;
matchstar.c:	vguess[vfit[3]] = wcsf->cd[0];
matchstar.c:	vdiff[vfit[3]] = wcsf->xinc * 0.03;
matchstar.c:	vguess[vfit[4]] = wcsf->cd[1];
matchstar.c:	vdiff[vfit[4]] = wcsf->yinc * 0.03;
matchstar.c:	vguess[vfit[5]] = wcsf->cd[2];
matchstar.c:	vdiff[vfit[5]] = wcsf->xinc * 0.03;
matchstar.c:	vguess[vfit[6]] = wcsf->cd[3];
matchstar.c:	vdiff[vfit[6]] = wcsf->yinc * 0.03;
matchstar.c:	if (vfit[3] > -1) {
matchstar.c:	    vguess[vfit[3]] = wcsf->xinc;
matchstar.c:	    vdiff[vfit[3]] = wcsf->xinc * 0.03;
matchstar.c:	if (vfit[4] > -1) {
matchstar.c:	    vguess[vfit[4]] = wcsf->yinc;
matchstar.c:	    vdiff[vfit[4]] = wcsf->yinc * 0.03;
matchstar.c:	if (vfit[5] > -1) {
matchstar.c:	    vguess[vfit[5]] = wcsf->rot;
matchstar.c:    if (vfit[7] > -1) {
matchstar.c:    if (vfit[8] > -1) {
matchstar.c:	    p[i][i-1] = vguess[i-1] + vdiff[i-1];
matchstar.c:	 y[i] = wcs_chisqr (p[i], -i);
matchstar.c:	if (vfit[1] > -1)
matchstar.c:	    ra2str (rastr, 31, wcsf->xref, 3);
matchstar.c:	if (vfit[2] > -1)
matchstar.c:	    dec2str (decstr, 16, wcsf->yref, 2);
matchstar.c:	if (vfit[6] > -1) {
matchstar.c:	    if (vfit[3] > -1)
matchstar.c:		xinc1 = wcsf->xinc;
matchstar.c:	    if (vfit[4] > -1)
matchstar.c:	    else if (vfit[3] > -1) {
matchstar.c:		    yinc1 = -xinc1;
matchstar.c:		yinc1 = wcsf->yinc;
matchstar.c:	    if (vfit[5] > -1)
matchstar.c:		rot = wcsf->rot;
matchstar.c:	if (vfit[7] > -1)
matchstar.c:	    xrefpix1 = wcsf->xrefpix;
matchstar.c:	if (vfit[8] > -1)
matchstar.c:	    yrefpix1 = wcsf->yrefpix;
matchstar.c:	if (vfit[1] > -1)
matchstar.c:	    ra2str (rastr, 31, wcsf->xref, 3);
matchstar.c:	if (vfit[2] > -1)
matchstar.c:	    dec2str (decstr, 31, wcsf->yref, 2);
matchstar.c:	if (vfit[6] > -1) {
matchstar.c:	    if (vfit[3] > -1)
matchstar.c:		xinc1 = wcsf->xinc;
matchstar.c:	    if (vfit[4] > -1)
matchstar.c:	    else if (vfit[3] > -1) {
matchstar.c:		    yinc1 = -xinc1;
matchstar.c:		yinc1 = wcsf->yinc;
matchstar.c:	    if (vfit[5] > -1)
matchstar.c:		rot = wcsf->rot;
matchstar.c:	if (vfit[7] > -1)
matchstar.c:	    xrefpix1 = wcsf->xrefpix;
matchstar.c:	if (vfit[8] > -1)
matchstar.c:	    yrefpix1 = wcsf->yrefpix;
matchstar.c:    if (vfit[1] > -1) {
matchstar.c:	wcsf->xref = xref_p + vp[vfit[1]];
matchstar.c:	if (wcsf->xref < 0.0) wcsf->xref = 360.0 + wcsf->xref;
matchstar.c:    if (vfit[2] > -1)
matchstar.c:	wcsf->yref = yref_p + vp[vfit[2]];
matchstar.c:    if (vfit[6] > -1) {
matchstar.c:	wcsf->cd[0] = vp[vfit[3]];
matchstar.c:	wcsf->cd[1] = vp[vfit[4]];
matchstar.c:	wcsf->cd[2] = vp[vfit[5]];
matchstar.c:	wcsf->cd[3] = vp[vfit[6]];
matchstar.c:	if (vfit[3] > -1)
matchstar.c:	    wcsf->xinc = vp[vfit[3]];
matchstar.c:	if (vfit[4] > -1)
matchstar.c:	    wcsf->yinc = vp[vfit[4]];
matchstar.c:	else if (vfit[3] > -1) {
matchstar.c:	    if (wcsf->xinc < 0)
matchstar.c:		wcsf->yinc = -wcsf->xinc;
matchstar.c:		wcsf->yinc = wcsf->xinc;
matchstar.c:	if (vfit[5] > -1)
matchstar.c:	    wcsf->rot = vp[vfit[5]];
matchstar.c:    if (vfit[7] > -1)
matchstar.c:	wcsf->xrefpix = xrefpix + vp[vfit[7]];
matchstar.c:    if (vfit[8] > -1)
matchstar.c:	wcsf->yrefpix = yrefpix + vp[vfit[8]];
matchstar.c:    ra2str (rastr, 31, wcsf->xref, 3);
matchstar.c:    dec2str (decstr, 31, wcsf->yref, 2);
matchstar.c:    if (vfit[6] > -1)
matchstar.c:		rastr, decstr, wcsf->cd[0], wcsf->cd[1], wcsf->cd[2],
matchstar.c:		wcsf->cd[3]);
matchstar.c:		rastr, decstr, wcsf->xinc*3600.0, wcsf->yinc*3600.0, wcsf->rot);
matchstar.c:    fprintf (stderr,"(%8.2f,%8.2f)\n", wcsf->xrefpix, wcsf->yrefpix);
matchstar.c:	ex = 3600.0 * (mra - gra_p[i]);
matchstar.c:	ey = 3600.0 * (mdec - gdec_p[i]);
matchstar.c: * v[4]=rotation, v[5]=2nd rotation->CD matrix, v[6]=ref x, and v[7] = ref y
matchstar.c:    if (vfit[1] > -1)
matchstar.c:	crval1 = wcsf->xref;
matchstar.c:    if (vfit[2] > -1)
matchstar.c:	crval2 = wcsf->yref;
matchstar.c:    if (vfit[6] > -1) {
matchstar.c:	if (vfit[3] > -1)
matchstar.c:	    cdelt1 = wcsf->xinc;
matchstar.c:	if (vfit[4] > -1)
matchstar.c:	else if (vfit[3] > -1) {
matchstar.c:		cdelt2 = -cdelt1;
matchstar.c:	    cdelt2 = wcsf->yinc;
matchstar.c:	if (vfit[5] > -1)
matchstar.c:	    crota = wcsf->rot;
matchstar.c:    if (vfit[7] > -1)
matchstar.c:	crpix1 = wcsf->xrefpix;
matchstar.c:    if (vfit[8] > -1)
matchstar.c:	crpix2 = wcsf->yrefpix;
matchstar.c:	    dx = xmp - sx_p[i];
matchstar.c:	    dy = ymp - sy_p[i];
matchstar.c:    ra2str (rastr, 31, wcsf->xref, 3);
matchstar.c:    dec2str (decstr, 31, wcsf->yref, 2);
matchstar.c:    if (vfit[6] > -1)
matchstar.c:		iter, rastr, decstr, wcsf->cd[0],wcsf->cd[1],wcsf->cd[2],
matchstar.c:		wcsf->cd[3]);
matchstar.c:		iter, rastr, decstr, wcsf->xinc*3600.0, wcsf->yinc*3600.0,
matchstar.c:		wcsf->rot);
matchstar.c:    fprintf (stderr,"(%8.2f,%8.2f) -> %f\r",
matchstar.c:	     wcsf->xrefpix, wcsf->yrefpix, chsq);
matchstar.c:	rtol = 2.0 * fabs(y[ihi]-y[ilo]) / (fabs(y[ihi]) + fabs(y[ilo]));
matchstar.c:	ytry = amotry (p, y, psum, ndim, funk, ihi, nfunk, -ALPHA);
matchstar.c:    fac1 = (1.0 - fac) / ndim;
matchstar.c:    fac2 = fac1 - fac;
matchstar.c:	ptry[j] = psum[j] * fac1 - p[ihi][j] * fac2;
matchstar.c:    	    psum[j] +=  ptry[j] - p[ihi][j];
matchstar.c:	pfit0 = -nfit;
matchstar.c: * Mar  3 1998	Fix residual-refining code
matchstar.c: * Jul 21 1999	Add FitMatch() to fit WCS to already-matched stars
matchstar.c: * Sep  8 1999	Fix bug found by Jean-Baptiste Marquette
NEWS:imio.c:  Fix 8-bit variables to be unsigned char
NEWS:imio.c: Change 8-bit pixel values from char to unsigned char
NEWS:hget.c: Free allocated memory in strnsrch() to eliminate memory leak (2011-05-19)
NEWS:imhfile.c: Free *newpixname* not pixname. (2011-05-20)
NEWS:wcslib.h: Declare undeclared SCAMP subroutine raw-to-pv()
NEWS:wcs.c: Fix wcsfree() so it frees depended-on WCS structures (2011-05-09)
NEWS:March 18, 2011 - Release 3.8.2
NEWS:April 30, 2010 - Release 3.8.1
NEWS:skycoor: Use number of decimal places from -n for -r difference if set
NEWS:wcscon.c: Fix bug in fk524() e-term computation; fix J<->B conversions
NEWS:wcscon.c: Fix bug in computing the magnitude of the e-terms in fk524()
NEWS:November 13, 2009 - Release 3.8.0
NEWS:November 21, 2008 - Release 3.7.6
NEWS:July 1, 2008 - Release 3.7.5
NEWS:May 9, 2008 - Release 3.7.4
NEWS:March 20, 2008 - Release 3.7.3
NEWS:December 31, 2007 - Release 3.7.2 
NEWS:November 9, 2007 - Release 3.7.1 
NEWS:August 24, 2007 - Release 3.7.0
NEWS:June 11, 2007 - Release 3.6.9
NEWS:April 3, 2007 - Release 3.6.8
NEWS:January 16, 2007 - Release 3.6.7
NEWS:November 2, 2006 - Release 3.6.6
NEWS:June 30, 2006 - Release 3.6.5
NEWS:May 3, 2006 - Release 3.6.4
NEWS:fitsfile.c: Add file name to header-reading error messages
NEWS:wcsinit.c:  Get Epoch of observation from MJD-OBS or DATE-OBS/UT unless DSS
NEWS:wcsinit.c:  Set wcs->naxes to actual number of image WCS axes, usually 2
NEWS:January 5, 2006 - Release 3.6.3
NEWS:July 21, 2005 - Release 3.6.2
NEWS:April 13, 2005 - Release 3.6.1
NEWS:March 17, 2005 - Release 3.6.0
NEWS:In wcs.c, fix bug in wcsrotset() so angles > 360 are set to angle - 360, not 360
NEWS:------------------------
NEWS:November 01, 2004 - Release 3.5.8
NEWS:In wcs.c, keep wcs->rot between 0 and 360 degrees (360.0 -> 0.0)
NEWS:September 21, 2004 - Release 3.5.7
NEWS:In hput.c, add fixnegzero() to avoid putting -0.000 in header
NEWS:September 3, 2004 - Release 3.5.6
NEWS:July 13, 2004 - Release 3.5.5
NEWS:May 6, 2004 - Release 3.5.4
NEWS:April 16, 2004 - Release 3.5.3
NEWS:Use strncsrch() in hget.c to get differently-cased keywords.
NEWS:February 3, 2004 - Release 3.5.2
NEWS:December 12, 2003 - Release 3.5.1
NEWS:Add wcs->naxes back into wcs structure for backward compatibility; it
NEWS:should always be equal to wcs->naxis.
NEWS:November 17, 2003 - Release 3.5.0
NEWS:Change wcs->naxes to wcs->naxis to prepare for WCSLIB 3.*
NEWS:Move all distortion-related code to distort.c; include unistd.h
NEWS:------------------------
NEWS:August 22, 2003 - Release 3.4.2
NEWS:July 11, 2003 - Release 3.4.1
NEWS:May 30, 2003 - Release 3.4.0
NEWS:------------------------
NEWS:May 8, 2003 - Release 3.3.4
NEWS:April 3, 2003 - Release 3.3.2
NEWS:March 27, 2003 - Release 3.3.1
NEWS:January 30, 2003 - Release 3.3.0
NEWS:------------------------
NEWS:January 3, 2003 - Release 3.2.1
NEWS:December 6, 2002 - Release 3.2.0
NEWS:------------------------
NEWS:August 30, 2002 - Release 3.1.3
NEWS:Add case-insensitive string search subroutines strcsrch() and strncsrch()
NEWS:July 8, 2002 - Release 3.1.2
NEWS:June 26, 2002 - Release 3.1.1
NEWS:Put SAO-written software under Gnu Lesser Public License
NEWS:April 12, 2002 - Release 3.1.0
NEWS:Support inversion (WCS->pix) of multiple dependent WCSs
NEWS:------------------------
NEWS:February 13, 2002 - Release 3.0.7
NEWS:December 4, 2001 - Release 3.0.6
NEWS:September 25, 2001 - Release 3.0.5
NEWS:September 7, 2001 - Release 3.0.3
NEWS:July 12, 2001 - Release 3.0
NEWS:------------------------
NEWS:March 30, 2001 - Release 2.9.4
NEWS:March 22, 2001 - Release 2.9.3
NEWS:March 9, 2001 - Release 2.9.2
NEWS:and fix bug which failed to read multi-extension files if END was not preceded
NEWS:February 28, 2001 - Release 2.9.1
NEWS:February 23, 2001 - Release 2.9.0
NEWS:An off-by-one bug was fixed for some polynomial types in tnxpos().
NEWS:------------------------
NEWS:December 29, 2000 - Release 2.8.6
NEWS:Fix handling of embedded + or - in isnum() in hget.c
NEWS:September 29, 2000 - Release 2.8.5
NEWS:August 1, 2000 - Release 2.8.3
NEWS:Improve handling of 1-D WCS data.  Fix numerous warning-generating bugs.
NEWS:June 13, 2000 - Release 2.8.2
NEWS:June 9, 2000 - Release 2.8.1
NEWS:June 2, 2000 - Release 2.8.0
NEWS:------------------------
NEWS:May 10, 2000 - Release 2.7.4
NEWS:May 1, 2000 - Release 2.7.3
NEWS: 0 to 999 have 1900 added to them:  01/05/100 becomes 2000-05-01.
NEWS:March 27, 2000 - Release 2.7.2
NEWS:February 23, 2000 - Release 2.7.0
NEWS:Change oldwcs in wcs.h from switch to multi-value flag wcsproj, default is same
NEWS:------------------------
NEWS:January 11, 2000 - Release 2.6.12
NEWS:December 20, 1999 - Release 2.6.11
NEWS:December 10, 1999 - Release 2.6.10
NEWS:November 17, 1999 - Release 2.6.9
NEWS:November 5, 1999 - Release 2.6.8
NEWS:Add DATE-MOD to FITS header in iraf2fits()
NEWS:------------------------
NEWS:May 5, 1999 - Release 1.26
NEWS:hget.c, iget.c Use POSIX-compliant limits.h instead of values.h
NEWS:April 7, 1999 - Release 1.26
NEWS:wcs.c	    Fix bug in dealing with EPOCHless non-equatorial coordinates
NEWS:April 5, 1999 - Release 1.26
NEWS:February 22, 1999 - Release 1.26
NEWS:            Use faaces 0-5, not 1-6 for quad cube projections
NEWS:February 9, 1999 - Release 1.26
NEWS:------------------------
NEWS:December 8, 1998 - Release 1.25
NEWS:November 30, 1998 - Release 1.25
NEWS:November 12, 1998 - Release 1.25
NEWS:hget.c:     Assume 2-digit year in hyphen-separated date means FITS, not ISO
nut1981.c: *    Kaplan,G.H., 1981, USNO Circular No. 163, pa3-6.
nut1981.c:    t = (dj - 2400000.5  - 51544.5 ) / 36525.0;
nut1981.c:    elp = as2r*(1287099.804 + (99.0 * t2as+1292581.224 + (-0.577 -0.012*t)*t)*t);
nut1981.c:    f = as2r*(335778.877 + (1342.0 * t2as+295263.137 + (-13.257 + 0.011*t)*t)*t);
nut1981.c:    d = as2r*(1072261.307 + (1236.0 * t2as+1105601.328 + (-6.891 + 0.019*t)*t)*t);
nut1981.c:    om = as2r * (450160.280 + (-5.0 * t2as-482890.539 + (7.455 +0.008*t)*t)*t);
nut1981.c:    dp = dp - sin (f2 + d4 + om2);
nut1981.c:    dp = dp - sin (el - f2 + d2);
nut1981.c:    dp = dp - sin (el + elp - d2 + om);
nut1981.c:    dp = dp - sin (-elp + f2 + om);
nut1981.c:    dp = dp - sin (el - f2 - d2);
nut1981.c:    dp = dp - sin (elp + d2);
nut1981.c:    dp = dp - sin (f2 - d + om2);
nut1981.c:    dp = dp - sin (-f2 + om);
nut1981.c:    dp = dp + sin (-el - elp + d2 + om);
nut1981.c:    dp = dp - sin (el + f2 - d2);
nut1981.c:    dp = dp + sin(el3 + f2 - d2 + om2);
nut1981.c:    dp = dp + sin(f4 - d2 + om2);
nut1981.c:    dp = dp - sin(el + d2 + om);
nut1981.c:    dp = dp - sin(el2 + f2 + d2 + om2);
nut1981.c:    a = el2 + f2 - d2 + om;
nut1981.c:    de = de - cos(a);
nut1981.c:    dp = dp + (sin(el - elp - d2));
nut1981.c:    dp = dp + (sin(-el + f4 + om2));
nut1981.c:    a = -el2 + f2 + d4 + om2;
nut1981.c:    dp = dp - sin(a);
nut1981.c:    dp = dp - sin(a);
nut1981.c:    a = el + elp + f2 - d2 + om2;
nut1981.c:    de = de - cos(a);
nut1981.c:    dp = dp - sin(el2 - d4);
nut1981.c:    a = -el + f2 + d4 + om2;
nut1981.c:    dp = dp - (2.0 * sin(a));
nut1981.c:    a = -el2 + f2 + d2 + om2;
nut1981.c:    de = de - cos(a);
nut1981.c:    dp = dp - sin(el - d4);
nut1981.c:    a = -el + om2;
nut1981.c:    de = de - cos(a);
nut1981.c:    de = de - cos(a);
nut1981.c:    dp = dp - (2.0 * sin(a));
nut1981.c:    de = de - cos(a);
nut1981.c:    a =  - el + f2 - d2 + om;
nut1981.c:    dp = dp - (2.0 * sin(a));
nut1981.c:    de = de - cos(a);
nut1981.c:    a = -elp + f2 + d2 + om2;
nut1981.c:    dp = dp - (3.0 * sin(a));
nut1981.c:    dp = dp - (3.0 * sin(a));
nut1981.c:    a = -el2 + om;
nut1981.c:    dp = dp - (2.0 * sin(a));
nut1981.c:    a = -el - elp + f2 + d2 + om2;
nut1981.c:    dp = dp - (3.0 * sin(a));
nut1981.c:    a = el - elp + f2 + om2;
nut1981.c:    dp = dp - (3.0 * sin(a));
nut1981.c:    dp = dp - (3.0 * sin(el + elp));
nut1981.c:    dp = dp - (4.0 * sin(d));
nut1981.c:    dp = dp + (4.0 * sin(el - f2));
nut1981.c:    dp = dp - (4.0 * sin(elp - d2));
nut1981.c:    dp = dp - (5.0 * sin(a));
nut1981.c:    dp = dp + (5.0 * sin(el - elp));
nut1981.c:    a = -d2 + om;
nut1981.c:    dp = dp - (5.0 * sin(a));
nut1981.c:    a = el + f2 - d2 + om;
nut1981.c:    de = de - (3.0 * cos(a));
nut1981.c:    dp = dp - (7.0 * sin(a));
nut1981.c:    dp = dp - (6.0 * sin(a));
nut1981.c:    a = el2 + f2 - d2 + om2;
nut1981.c:    de = de - (3.0 * cos(a));
nut1981.c:    dp = dp - (8.0 * sin(a));
nut1981.c:    a = -elp + f2 + om2;
nut1981.c:    dp = dp - (7.0 * sin(a));
nut1981.c:    de = de - (3.0 * cos(a));
nut1981.c:    dp = dp - (7.0 * sin(el + elp - d2));
nut1981.c:    a = -el + f2 + d2 + om;
nut1981.c:    dp = dp - (10.0 * sin(a));
nut1981.c:    a = el - d2 + om;
nut1981.c:    dp = dp - (13.0 * sin(a));
nut1981.c:    a = -el + d2 + om;
nut1981.c:    de = de - (8.0 * cos(a));
nut1981.c:    a =  - el + f2 + om;
nut1981.c:    de = de - (10.0 * cos(a));
nut1981.c:    de = de - cos(f2);
nut1981.c:    dp = dp - (31.0 * sin(a));
nut1981.c:    a = el + f2 - d2 + om2;
nut1981.c:    de = de - (12.0 * cos(a));
nut1981.c:    de = de - cos(el2);
nut1981.c:    dp = dp - (38.0 * sin(a));
nut1981.c:    dp = dp - (51.0 * sin(a));
nut1981.c:    a =  -el + f2 + d2 + om2;
nut1981.c:    dp = dp - (59.0 * sin(a));
nut1981.c:    a =  -el + om;
nut1981.c:    dp = dp + ((-58.0 - 0.1 * t) * sin(a));
nut1981.c:    de = de - (33.0 * cos(a));
nut1981.c:    de = de - (2.0 * cos(d2));
nut1981.c:    a =  -el + f2 + om2;
nut1981.c:    de = de - (53.0 * cos(a));
nut1981.c:    a = el - d2;
nut1981.c:    dp = dp - (158.0 * sin(a));
nut1981.c:    de = de - cos(a);
nut1981.c:    dp = dp - (301.0 * sin(a));
nut1981.c:    de = de + ((129.0 - 0.1 * t) * cos(a));
nut1981.c:    dp = dp + ((-386.0  - 0.4 * t) * sin(a));
nut1981.c:    de = de - (7.0 * cos(el));
nut1981.c:    dp = dp + ((-2274.0  - 0.2 * t) * sin(a));
nut1981.c:    de = de + ((977.0  - 0.5 * t) * cos(a));
nut1981.c:    dp = dp - sin(elp + f2 - d2);
nut1981.c:    dp = dp + sin(-el + d + om);
nut1981.c:    dp = dp - sin(elp - f2 + d2);
nut1981.c:    dp = dp + sin(-f2 + d2 + om);
nut1981.c:    dp = dp + sin(el2 + elp - d2);
nut1981.c:    dp = dp - (4.0 * sin(el - d));
nut1981.c:    a = elp + f2 - d2 + om;
nut1981.c:    de = de - (2.0 * cos(a));
nut1981.c:    a = el2 - d2 + om;
nut1981.c:    de = de - (2.0 * cos(a));
nut1981.c:    a = -elp + f2 - d2 + om;
nut1981.c:    dp = dp - (5.0 * sin(a));
nut1981.c:    a = -el2 + d2 + om;
nut1981.c:    dp = dp - (6.0 * sin(a));
nut1981.c:    a = -elp + om;
nut1981.c:    dp = dp - (12.0 * sin(a));
nut1981.c:    a = elp2 + f2 - d2 + om2;
nut1981.c:    dp = dp + ((-16.0  + (0.1 * t)) * sin(a));
nut1981.c:    dp = dp - (15.0 * sin(a));
nut1981.c:    dp = dp + ((17.0  - (0.1 * t)) * sin(elp2));
nut1981.c:    dp = dp - (22.0 * sin(f2 - d2));
nut1981.c:    a = el2 - d2;
nut1981.c:    a = f2 - d2 + om;
nut1981.c:    de = de - (70.0 * cos(a));
nut1981.c:    a =  - elp + f2 - d2 + om2;
nut1981.c:    dp = dp + ((217.0  - 0.5 * t) * sin(a));
nut1981.c:    de = de + ((-95.0  + 0.3 * t) * cos(a));
nut1981.c:    a = elp + f2 - d2 + om2;
nut1981.c:    dp = dp + ((-517.0  + (1.2 * t)) * sin(a));
nut1981.c:    de = de + ((224.0  - (0.6 * t)) * cos(a));
nut1981.c:    dp = dp + ((1426.0 - (3.4 * t)) * sin(elp));
nut1981.c:    de = de + ((54.0 - (0.1 * t)) * cos(elp));
nut1981.c:    a = f2 - d2 + om2;
nut1981.c:    dp = dp + ((-13187.0  - (1.6 * t)) * sin(a));
nut1981.c:    de = de + ((5736.0  - (3.1 * t)) * cos(a));
nut1981.c:    dp = dp + sin(el2 - f2 + om);
nut1981.c:    a =  -elp2 + f2 - d2 + om;
nut1981.c:    dp = dp - (2.0 * sin(a));
nut1981.c:    dp = dp - (3.0 * sin(el - elp - d));
nut1981.c:    a =  - el2 + f2 + om2;
nut1981.c:    dp = dp - (3.0 * sin(a));
nut1981.c:    dp = dp + (11.0 * sin (el2 - f2));
nut1981.c:    a =  - el2 + f2 + om;
nut1981.c:    de = de - (24.0 * cos(a));
nut1981.c:    de = de + ((-895.0 + (0.5 * t)) * cos(om2));
nut1981.c:    dp = dp + ((-171996.0 - (174.2 * t)) * sin(om));
nut1981.c:    *eps0 = as2r * (84381.448 + (-46.8150 + (-0.00059 + (0.001813*t)*t)*t));
nut2006.c:#define NLS	77 /* number of terms in the luni-solar nutation model */
nut2006.c: *     the nutation model consists only of luni-solar terms, but includes
nut2006.c: *     also a fixed offset which compensates for certain long-period
nut2006.c: *     2000.  the routine computes the mhb_2000_short luni-solar nutation
nut2006.c: *     corrections for the essentially unpredictable free-core-nutation
nut2006.c: *     adjustments, and nutation (luni-solar + planetary).  these total
nut2006.c: *     precession implementation, such as iau_pmat76, to deliver gcrs-to-
nut2006.c: *     in size but compensate for long-period nutations.  the amplitudes
nut2006.c: *     quoted in mccarthy & luzum (2003), namely dpsi = -1.5835 mas and
nut2006.c: *     sofa implementation, namely -0.135 mas and +0.388 mas, are
nut2006.c: *     interval 1995-2050, the sofa implementation delivers a maximum
nut2006.c: *     astronomical constants", Astron.Astrophys. 58, 1-2, 1-16. (1977)
nut2006.c: *     precession-nutation of the celestial pole", Cel.Mech.Dyn.Astron.
nut2006.c: *     85, 37-49 (2003)
nut2006.c: *     Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M.,
nut2006.c: *     Francou, G., Laskar, J., Astron.Astrophys. 282, 663-683 (1994)
nut2006.c:    int nls = NLS; /* number of terms in the luni-solar nutation model */
nut2006.c:    double dpplan = - 0.135 * dmas2r;
nut2006.c:    /* Luni-solar argument multipliers: */
nut2006.c:             0,    0,    2,   -2,    2,
nut2006.c:             0,    1,    2,   -2,    2,
nut2006.c:             0,   -1,    2,   -2,    2,
nut2006.c:             0,    0,    2,   -2,    1,
nut2006.c:            -1,    0,    2,    0,    2,
nut2006.c:            -1,    0,    0,    2,    0,
nut2006.c:            -1,    0,    0,    0,    1,
nut2006.c:            -1,    0,    2,    2,    2,
nut2006.c:            -2,    0,    2,    0,    1,
nut2006.c:             0,   -2,    2,   -2,    2,
nut2006.c:            -2,    0,    0,    2,    0,
nut2006.c:             1,    0,    2,   -2,    2,
nut2006.c:            -1,    0,    2,    0,    1,
nut2006.c:            -1,    0,    0,    2,    1,
nut2006.c:             0,    2,    2,   -2,    2,
nut2006.c:             0,    0,   -2,    2,    0,
nut2006.c:             1,    0,    0,   -2,    1,
nut2006.c:             0,   -1,    0,    0,    1,
nut2006.c:            -1,    0,    2,    2,    1,
nut2006.c:            -2,    0,    2,    0,    0,
nut2006.c:             0,   -1,    2,    0,    2,
nut2006.c:             1,    0,    2,   -2,    1,
nut2006.c:             2,    0,    2,   -2,    2,
nut2006.c:            -2,    0,    0,    2,    1,
nut2006.c:             0,   -1,    2,   -2,    1,
nut2006.c:             0,    0,    0,   -2,    1,
nut2006.c:            -1,   -1,    0,    2,    0,
nut2006.c:             2,    0,    0,   -2,    1,
nut2006.c:             0,    1,    2,   -2,    1,
nut2006.c:             1,   -1,    0,    0,    0,
nut2006.c:            -2,    0,    2,    0,    2,
nut2006.c:             0,   -1,    0,    2,    0,
nut2006.c:             1,   -1,    2,    0,    2,
nut2006.c:            -1,   -1,    2,    2,    2,
nut2006.c:            -1,    0,    2,    0,    0,
nut2006.c:             0,   -1,    2,    2,    2,
nut2006.c:            -2,    0,    0,    0,    1,
nut2006.c:            -1,    1,    0,    1,    0,
nut2006.c:            -1,    0,    2,   -2,    1,
nut2006.c:            -1,    0,    0,    1,    0,
nut2006.c:            -1,    0,    2,    4,    2,
nut2006.c:            -1,    1,    0,    1,    1,
nut2006.c:             0,   -2,    2,   -2,    1,
nut2006.c:            -2,    0,    2,    2,    2,
nut2006.c:            -1,    0,    0,    0,    2,
nut2006.c:             1,    1,    2,   -2,    2};
nut2006.c:    /* Luni-solar nutation coefficients, in 1e-7 arcsec */
nut2006.c:   {-172064161.0, -174666.0,  33386.0, 92052331.0,  9086.0, 15377.0,
nut2006.c:     -13170906.0,   -1675.0, -13696.0,  5730336.0, -3015.0, -4587.0,
nut2006.c:      -2276413.0,    -234.0,   2796.0,   978459.0,  -485.0,  1374.0,
nut2006.c:       2074554.0,     207.0,   -698.0,  -897492.0,   470.0,  -291.0,
nut2006.c:       1475877.0,   -3633.0,  11817.0,    73871.0,  -184.0, -1924.0,
nut2006.c:       -516821.0,    1226.0,   -524.0,   224386.0,  -677.0,  -174.0,
nut2006.c:        711159.0,      73.0,   -872.0,    -6750.0,     0.0,   358.0,
nut2006.c:       -387298.0,    -367.0,    380.0,   200728.0,    18.0,   318.0,
nut2006.c:       -301461.0,     -36.0,    816.0,   129025.0,   -63.0,   367.0,
nut2006.c:        215829.0,    -494.0,    111.0,   -95929.0,   299.0,   132.0,
nut2006.c:        128227.0,     137.0,    181.0,   -68982.0,    -9.0,    39.0,
nut2006.c:        123457.0,      11.0,     19.0,   -53311.0,    32.0,    -4.0,
nut2006.c:        156994.0,      10.0,   -168.0,    -1235.0,     0.0,    82.0,
nut2006.c:         63110.0,      63.0,     27.0,   -33228.0,     0.0,    -9.0,
nut2006.c:        -57976.0,     -63.0,   -189.0,    31429.0,     0.0,   -75.0,
nut2006.c:        -59641.0,     -11.0,    149.0,    25543.0,   -11.0,    66.0,
nut2006.c:        -51613.0,     -42.0,    129.0,    26366.0,     0.0,    78.0,
nut2006.c:         45893.0,      50.0,     31.0,   -24236.0,   -10.0,    20.0,
nut2006.c:         63384.0,      11.0,   -150.0,    -1220.0,     0.0,    29.0,
nut2006.c:        -38571.0,      -1.0,    158.0,    16452.0,   -11.0,    68.0,
nut2006.c:         32481.0,       0.0,      0.0,   -13870.0,     0.0,     0.0,
nut2006.c:        -47722.0,       0.0,    -18.0,      477.0,     0.0,   -25.0,
nut2006.c:        -31046.0,      -1.0,    131.0,    13238.0,   -11.0,    59.0,
nut2006.c:         28593.0,       0.0,     -1.0,   -12338.0,    10.0,    -3.0,
nut2006.c:         20441.0,      21.0,     10.0,   -10758.0,     0.0,    -3.0,
nut2006.c:         29243.0,       0.0,    -74.0,     -609.0,     0.0,    13.0,
nut2006.c:         25887.0,       0.0,    -66.0,     -550.0,     0.0,    11.0,
nut2006.c:        -14053.0,     -25.0,     79.0,     8551.0,    -2.0,   -45.0,
nut2006.c:         15164.0,      10.0,     11.0,    -8001.0,     0.0,    -1.0,
nut2006.c:        -15794.0,      72.0,    -16.0,     6850.0,   -42.0,    -5.0,
nut2006.c:         21783.0,       0.0,     13.0,     -167.0,     0.0,    13.0,
nut2006.c:        -12873.0,     -10.0,    -37.0,     6953.0,     0.0,   -14.0,
nut2006.c:        -12654.0,      11.0,     63.0,     6415.0,     0.0,    26.0,
nut2006.c:        -10204.0,       0.0,     25.0,     5222.0,     0.0,    15.0,
nut2006.c:         16707.0,     -85.0,    -10.0,      168.0,    -1.0,    10.0,
nut2006.c:         -7691.0,       0.0,     44.0,     3268.0,     0.0,    19.0,
nut2006.c:        -11024.0,       0.0,    -14.0,      104.0,     0.0,     2.0,
nut2006.c:          7566.0,     -21.0,    -11.0,    -3250.0,     0.0,    -5.0,
nut2006.c:         -6637.0,     -11.0,     25.0,     3353.0,     0.0,    14.0,
nut2006.c:         -7141.0,      21.0,      8.0,     3070.0,     0.0,     4.0,
nut2006.c:         -6302.0,     -11.0,      2.0,     3272.0,     0.0,     4.0,
nut2006.c:          5800.0,      10.0,      2.0,    -3045.0,     0.0,    -1.0,
nut2006.c:          6443.0,       0.0,     -7.0,    -2768.0,     0.0,    -4.0,
nut2006.c:         -5774.0,     -11.0,    -15.0,     3041.0,     0.0,    -5.0,
nut2006.c:         -5350.0,       0.0,     21.0,     2695.0,     0.0,    12.0,
nut2006.c:         -4752.0,     -11.0,     -3.0,     2719.0,     0.0,    -3.0,
nut2006.c:         -4940.0,     -11.0,    -21.0,     2720.0,     0.0,    -9.0,
nut2006.c:          7350.0,       0.0,     -8.0,      -51.0,     0.0,     4.0,
nut2006.c:          4065.0,       0.0,      6.0,    -2206.0,     0.0,     1.0,
nut2006.c:          6579.0,       0.0,    -24.0,     -199.0,     0.0,     2.0,
nut2006.c:          3579.0,       0.0,      5.0,    -1900.0,     0.0,     1.0,
nut2006.c:          4725.0,       0.0,     -6.0,      -41.0,     0.0,     3.0,
nut2006.c:         -3075.0,       0.0,     -2.0,     1313.0,     0.0,    -1.0,
nut2006.c:         -2904.0,       0.0,     15.0,     1233.0,     0.0,     7.0,
nut2006.c:          4348.0,       0.0,    -10.0,      -81.0,     0.0,     2.0,
nut2006.c:         -2878.0,       0.0,      8.0,     1232.0,     0.0,     4.0,
nut2006.c:         -4230.0,       0.0,      5.0,      -20.0,     0.0,    -2.0,
nut2006.c:         -2819.0,       0.0,      7.0,     1207.0,     0.0,     3.0,
nut2006.c:         -4056.0,       0.0,      5.0,       40.0,     0.0,    -2.0,
nut2006.c:         -2647.0,       0.0,     11.0,     1129.0,     0.0,     5.0,
nut2006.c:         -2294.0,       0.0,    -10.0,     1266.0,     0.0,    -4.0,
nut2006.c:          2481.0,       0.0,     -7.0,    -1062.0,     0.0,    -3.0,
nut2006.c:          2179.0,       0.0,     -2.0,    -1129.0,     0.0,    -2.0,
nut2006.c:          3276.0,       0.0,      1.0,       -9.0,     0.0,     0.0,
nut2006.c:         -3389.0,       0.0,      5.0,       35.0,     0.0,    -2.0,
nut2006.c:          3339.0,       0.0,    -13.0,     -107.0,     0.0,     1.0,
nut2006.c:         -1987.0,       0.0,     -6.0,     1073.0,     0.0,    -2.0,
nut2006.c:         -1981.0,       0.0,      0.0,      854.0,     0.0,     0.0,
nut2006.c:          4026.0,       0.0,   -353.0,     -553.0,     0.0,  -139.0,
nut2006.c:          1660.0,       0.0,     -5.0,     -710.0,     0.0,    -2.0,
nut2006.c:         -1521.0,       0.0,      9.0,      647.0,     0.0,     4.0,
nut2006.c:          1314.0,       0.0,      0.0,     -700.0,     0.0,     0.0,
nut2006.c:         -1283.0,       0.0,      0.0,      672.0,     0.0,     0.0,
nut2006.c:         -1331.0,       0.0,      8.0,      663.0,     0.0,     4.0,
nut2006.c:          1383.0,       0.0,     -2.0,     -594.0,     0.0,    -2.0,
nut2006.c:          1405.0,       0.0,      4.0,     -610.0,     0.0,     2.0,
nut2006.c:          1290.0,       0.0,      0.0,     -556.0,     0.0,     0.0};
nut2006.c:    t = (dj - dj0) / djc;
nut2006.c:/* Luni-solar nutation */
nut2006.c:    om  = fmod (450160.398036 - (6962890.5431 * t), as2pi ) * as2r;
nut2006.c:    /* Summation of luni-solar nutation series (in reverse order) */
nut2006.c:    for (i = nls; i > 0; i=i-1) {
nut2006.c:	j = i - 1;
nut2006.c:    /* Add luni-solar and planetary components */
nut2006.c:	    ( -46.836769    +
nut2006.c:	    (  -0.0001831   +
nut2006.c:	    (  -0.000000576 +
nut2006.c:	    (  -0.0000000434 ) * t ) * t ) * t ) * t ) * t ) * as2r;
platefit.c: *** Harvard-Smithsonian Center for Astrophysics
platefit.c: *** Copyright (C) 1998-2006
platefit.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
platefit.c:	double dra = wcsp->cdelt[0];
platefit.c:	double ddec = wcsp->cdelt[1];
platefit.c:	vguess[1] = wcsp->cd[0];
platefit.c:	vguess[2] = wcsp->cd[1];
platefit.c:	vguess[ncoeff+1] = wcsp->cd[2];
platefit.c:	vguess[ncoeff+2] = wcsp->cd[3];
platefit.c:	    p[i][i-1] = vguess[i-1] + vdiff[i-1];
platefit.c:	y[i] = plate_chisqr (p[i], -i);
platefit.c:	ex = 3600.0 * (mx - gx_p[i]);
platefit.c:	ey = 3600.0 * (my - gy_p[i]);
platefit.c:	dx =3600.0 * (xsp - gx_p[i]);
platefit.c:	dy = 3600.0 * (ysp - gy_p[i]);
platefit.c:    fprintf (stderr," -> %f\r", chsq);
platepos.c: *** Harvard-Smithsonian Center for Astrophysics
platepos.c: *** Copyright (C) 1998-2002
platepos.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
platepos.c:    int ncoeff1 = wcs->ncoeff1;
platepos.c:    int ncoeff2 = wcs->ncoeff2;
platepos.c:    x = xpix - wcs->crpix[0];
platepos.c:    y = ypix - wcs->crpix[1];
platepos.c:    xi =  wcs->x_coeff[ 0]		+ wcs->x_coeff[ 1]*x +
platepos.c:	  wcs->x_coeff[ 2]*y	+ wcs->x_coeff[ 3]*x2 +
platepos.c:	  wcs->x_coeff[ 4]*y2	+ wcs->x_coeff[ 5]*x*y;
platepos.c:	  xi = xi + wcs->x_coeff[ 6]*x3	+ wcs->x_coeff[ 7]*y3;
platepos.c:	xi = xi + wcs->x_coeff[ 8]*x2*y	+ wcs->x_coeff[ 9]*x*y2 +
platepos.c:		  wcs->x_coeff[10]*(r2)	+ wcs->x_coeff[11]*x*r2 +
platepos.c:		  wcs->x_coeff[12]*y*r2;
platepos.c:    eta = wcs->y_coeff[ 0]		+ wcs->y_coeff[ 1]*x +
platepos.c:	  wcs->y_coeff[ 2]*y	+ wcs->y_coeff[ 3]*x2 +
platepos.c:	  wcs->y_coeff[ 4]*y2	+ wcs->y_coeff[ 5]*x*y;
platepos.c:	eta = eta + wcs->y_coeff[ 6]*x3	+ wcs->y_coeff[ 7]*y3;
platepos.c:	eta = eta + wcs->y_coeff[ 8]*x2*y + wcs->y_coeff[ 9]*y2*x +
platepos.c:		    wcs->y_coeff[10]*r2   + wcs->y_coeff[11]*x*r2 +
platepos.c:		    wcs->y_coeff[12]*y*r2;
platepos.c:    ra0 = degrad (wcs->crval[0]);
platepos.c:    dec0 = degrad (wcs->crval[1]);
platepos.c:    raoff = atan2 (xir / ccos, 1.0 - etar * ctan);
platepos.c:    dec = atan (cos (raoff) / ((1.0 - (etar * ctan)) / (etar + ctan)));
platepos.c:    int	ncoeff1 = wcs->ncoeff1;
platepos.c:    int	ncoeff2 = wcs->ncoeff2;
platepos.c:    ra0 = degrad (wcs->crval[0]);
platepos.c:    dec0 = degrad (wcs->crval[1]);
platepos.c:    traoff = tan (ra - ra0);
platepos.c:    craoff = cos (ra - ra0);
platepos.c:    etar = (1.0 - ctan * craoff / tdec) / (ctan + (craoff / tdec));
platepos.c:    xir = traoff * ccos * (1.0 - (etar * ctan));
platepos.c:    x = xi * wcs->dc[0] + eta * wcs->dc[1];
platepos.c:    y = xi * wcs->dc[2] + eta * wcs->dc[3];
platepos.c:    /* if (wcs->x_coeff[1] == 0.0)
platepos.c:	x = xi - wcs->x_coeff[0];
platepos.c:	x = (xi - wcs->x_coeff[0]) / wcs->x_coeff[1];
platepos.c:    if (wcs->y_coeff[2] == 0.0)
platepos.c:	y = eta - wcs->y_coeff[0];
platepos.c:	y = (eta - wcs->y_coeff[0]) / wcs->y_coeff[2]; */
platepos.c:	f = wcs->x_coeff[0]	+ wcs->x_coeff[1]*x +
platepos.c:	    wcs->x_coeff[2]*y	+ wcs->x_coeff[3]*x2 +
platepos.c:	    wcs->x_coeff[4]*y2	+ wcs->x_coeff[5]*xy;
platepos.c:	fx = wcs->x_coeff[1]	+ wcs->x_coeff[3]*2.0*x +
platepos.c:	     wcs->x_coeff[5]*y;
platepos.c:	fy = wcs->x_coeff[2]	+ wcs->x_coeff[4]*2.0*y +
platepos.c:	     wcs->x_coeff[5]*x;
platepos.c:	    f = f + wcs->x_coeff[6]*x3	+ wcs->x_coeff[7]*y3;
platepos.c:	    fx = fx + wcs->x_coeff[6]*3.0*x2;
platepos.c:	    fy = fy + wcs->x_coeff[7]*3.0*y2;
platepos.c:		wcs->x_coeff[8]*x2y	+ wcs->x_coeff[9]*y2x +
platepos.c:		wcs->x_coeff[10]*r2 + wcs->x_coeff[11]*x*r2 +
platepos.c:		wcs->x_coeff[12]*y*r2;
platepos.c:	    fx = fx +	wcs->x_coeff[8]*2.0*xy + 
platepos.c:			wcs->x_coeff[9]*y2 +
platepos.c:	 		wcs->x_coeff[10]*2.0*x +
platepos.c:			wcs->x_coeff[11]*(3.0*x2+y2) +
platepos.c:			wcs->x_coeff[12]*2.0*xy;
platepos.c:	    fy = fy +	wcs->x_coeff[8]*x2 +
platepos.c:			wcs->x_coeff[9]*2.0*xy +
platepos.c:			wcs->x_coeff[10]*2.0*y +
platepos.c:			wcs->x_coeff[11]*2.0*xy +
platepos.c:			wcs->x_coeff[12]*(3.0*y2+x2);
platepos.c:	g = wcs->y_coeff[0]	+ wcs->y_coeff[1]*x +
platepos.c:	    wcs->y_coeff[2]*y	+ wcs->y_coeff[3]*x2 +
platepos.c:	    wcs->y_coeff[4]*y2	+ wcs->y_coeff[5]*xy;
platepos.c:	gx = wcs->y_coeff[1]	+ wcs->y_coeff[3]*2.0*x +
platepos.c:	     wcs->y_coeff[5]*y;
platepos.c:	gy = wcs->y_coeff[2]	+ wcs->y_coeff[4]*2.0*y +
platepos.c:	     wcs->y_coeff[5]*x;
platepos.c:	    g = g + wcs->y_coeff[6]*x3	+ wcs->y_coeff[7]*y3;
platepos.c:	    gx = gx + wcs->y_coeff[6]*3.0*x2;
platepos.c:	    gy = gy + wcs->y_coeff[7]*3.0*y2;
platepos.c:		wcs->y_coeff[8]*x2y	+ wcs->y_coeff[9]*y2x +
platepos.c:		wcs->y_coeff[10]*r2	+ wcs->y_coeff[11]*x*r2 +
platepos.c:		wcs->y_coeff[12]*y*r2;
platepos.c:	    gx = gx +	wcs->y_coeff[8]*2.0*xy + 
platepos.c:			wcs->y_coeff[9]*y2 +
platepos.c:	 		wcs->y_coeff[10]*2.0*x +
platepos.c:			wcs->y_coeff[11]*(3.0*x2+y2) +
platepos.c:			wcs->y_coeff[12]*2.0*xy;
platepos.c:	    gy = gy +	wcs->y_coeff[8]*x2 +
platepos.c:			wcs->y_coeff[9]*2.0*xy +
platepos.c:			wcs->y_coeff[10]*2.0*y +
platepos.c:			wcs->y_coeff[11]*2.0*xy +
platepos.c:			wcs->y_coeff[12]*(3.0*y2+x2);
platepos.c:	f = f - xi;
platepos.c:	g = g - eta;
platepos.c:	dx = ((-f * gy) + (g * fy)) / ((fx * gy) - (fy * gx));
platepos.c:	dy = ((-g * fx) + (f * gx)) / ((fx * gy) - (fy * gx));
platepos.c:    *xpix = x + wcs->crpix[0];
platepos.c:    *ypix = y + wcs->crpix[1];
platepos.c:    if (*xpix < 0.5 || *xpix > wcs->nxpix+0.5)
platepos.c:	return -1;
platepos.c:    if (*ypix < 0.5 || *ypix > wcs->nypix+0.5)
platepos.c:	return -1;
platepos.c:    wcs->ncoeff1 = ncoeff1;
platepos.c:    wcs->ncoeff2 = ncoeff2;
platepos.c:    wcs->prjcode = WCS_PLT;
platepos.c:	    wcs->x_coeff[i] = coeff[i];
platepos.c:	    wcs->x_coeff[i] = 0.0;
platepos.c:	    wcs->y_coeff[i] = coeff[ncoeff1+i];
platepos.c:	    wcs->y_coeff[i] = 0.0;
platepos.c:    *ncoeff1 = wcs->ncoeff1;
platepos.c:    *ncoeff2 = wcs->ncoeff2;
platepos.c:	coeff[i] = wcs->x_coeff[i];
platepos.c:	coeff[*ncoeff1+i] = wcs->y_coeff[i];
platepos.c:    for (i = 0; i < wcs->ncoeff1; i++) {
platepos.c:	hputnr8 (header, keyword, -15, wcs->x_coeff[i]);
platepos.c:    for (i = 0; i < wcs->ncoeff2; i++) {
platepos.c:	hputnr8 (header, keyword, -15, wcs->y_coeff[i]);
platepos.c:/* Mar 27 1998	New subroutines for direct image pixel <-> sky polynomials
polfit.c: *--- Polynomial least squares fitting program, almost identical to the
polfit.c: *      y = a(1) + a(2)*(x-x0) + a(3)*(x-x0)**2 + a(3)*(x-x0)**3 + . . .
polfit.c:    nmax = 2 * nterms - 1;
polfit.c:	xi = x[i] - x0;
polfit.c:	sigma2sum = sigma2sum + ((y[i] - yi) * (y[i] - yi));
polfit.c:    *stdev = sqrt (sigma2sum / (double) (npts - 1));
polfit.c:/*--- Calculate the determinant of a square matrix
polfit.c:	    det = -det;
polfit.c:	if (k < norder - 1) {
polfit.c:		    array[i+j*norder] = array[i+j*norder] -
polfit.c:/* POLCOMP -- Polynomial evaluation
polfit.c:    x = xi - x0;
poly.c:  exit(-1);
poly.c:NOTES   -.
poly.c:  if ((poly->ndim=ndim) > POLY_MAXDIM)
poly.c:    QMALLOC(poly->group, int, poly->ndim);
poly.c:    for (groupt=poly->group, d=ndim; d--;)
poly.c:      *(groupt++) = *(group++)-1;
poly.c:  poly->ngroup = ngroup;
poly.c:    group = poly->group;	/* Forget the original *group */
poly.c:    QMALLOC(poly->degree, int, poly->ngroup);
poly.c:/*-- Compute the number of context parameters for each group */
poly.c:  poly->ncoeff = 1;
poly.c:    if ((d=poly->degree[g]=*(degree++))>POLY_MAXDEGREE)
poly.c:		"allowed one (%d)", poly->degree[g], POLY_MAXDEGREE);
poly.c:/*-- There are (n+d)!/(n!d!) coeffs per group, that is Prod_(i<=d) (n+i)/i */
poly.c:    for (num=den=1, n=nd[g]; d; num*=(n+d), den*=d--);
poly.c:    poly->ncoeff *= num/den;
poly.c:  QMALLOC(poly->basis, double, poly->ncoeff);
poly.c:  QCALLOC(poly->coeff, double, poly->ncoeff);
poly.c:OUTPUT  -.
poly.c:NOTES   -.
poly.c:    free(poly->coeff);
poly.c:    free(poly->basis);
poly.c:    free(poly->degree);
poly.c:    free(poly->group);
poly.c:NOTES   Values of the basis functions are updated in poly->basis.
poly.c:  ndim = poly->ndim;
poly.c:  basis = poly->basis;
poly.c:  coeff = poly->coeff;
poly.c:  group = poly->group;
poly.c:  degree = poly->degree;
poly.c:    for (xpolt=xpol, expot=expo, post=pos, d=ndim; --d;)
poly.c:    for (gexpot=gexpo, degreet=degree, g=poly->ngroup; g--;)
poly.c:      gexpo[*group]--;
poly.c:  for (t=poly->ncoeff; --t; )
poly.c:/*-- xpol[0] contains the current product of the x^n's */
poly.c:/*-- A complex recursion between terms of the polynom speeds up computations */
poly.c:/*-- Not too good for roundoff errors (prefer Horner's), but much easier for */
poly.c:/*-- multivariate polynomials: this is why we use a long double accumulator */
poly.c:      if (gexpo[*groupt]--)
poly.c:        xval = (*(xpolt--) *= *post);
poly.c:        while (d--)
poly.c:          *(xpolt--) = xval;
poly.c:PURPOSE Least-Square fit of a multidimensional polynom to weighted data.
poly.c:  ncoeff = poly->ncoeff;
poly.c:  ndim = poly->ndim;
poly.c:  basis = poly->basis;
poly.c:    for (n=ndata; n--;)
poly.c:  for (n=ndata; n--;)
poly.c:/*---- If x!=NULL, compute the basis functions */
poly.c:        x2[d] = *(xt++)/* - offset[d]*/;     
poly.c:/*---- If, in addition, extbasis is provided, then fill it */
poly.c:        for (basis1=basis,j=ncoeff; j--;)
poly.c:/*---- If x==NULL, then rely on pre-computed basis functions */
poly.c:      for (basis1=basis,j=ncoeff; j--;)
poly.c:    for (j=ncoeff; j--;)
poly.c:      for (basis2=basis,i=ncoeff; i--;)
poly.c:  coeff = poly->coeff;
poly.c:  for (j=ncoeff; j--;)
poly.c:OUTPUT  -.
poly.c:NOTES   Requires quadruple-precision. **For the time beeing, this function
poly.c:  ncoeff = poly->ncoeff;
poly.c:  ndim = poly->ndim;
poly.c:  for (j=0; j<poly->ngroup; j++)
poly.c:    if (maxdegree < poly->degree[j])
poly.c:      maxdegree = poly->degree[j];
poly.c:  mcoefft = mcoeff;		/* To avoid gcc -Wall warnings */
poly.c:  coeff = poly->coeff;
poly.c:      for (p=n+1; p--;)
poly.c:        *(mcoefft--) = val;
poly.c:        val *= (cste[j]*(n--))/(denum++);	/* This is C_n^p X^(n-p) */
poly.c:/*-- Update all valid coefficients */
poly.c:/*---- Check that this combination of powers is included in the series above */
poly.c:      for (j=ndim; j--; mcoefft += maxdegree)
poly.c:OUTPUT  -.
poly.c:NOTES   -.
poly.c:OUTPUT  -1 if the matrix is not positive-definite, 0 otherwise.
poly.c:      for (sum=a[i*n+j],k=i-1; k>=0; k--)
poly.c:        sum -= a[i*n+k]*a[j*n+k];
poly.c:          return -1;
poly.c:    for (sum=b[i],k=i-1; k>=0; k--)
poly.c:      sum -= a[i*n+k]*x[k];
poly.c:  for (i=n-1; i>=0; i--)
poly.c:      sum -= a[k*n+i]*x[k];
poly.c:PURPOSE General least-square fit A.x = b, based on Singular Value
poly.c:OUTPUT  -.
poly.c:#define SIGN(a,b) ((b) >= 0.0 ? fabs(a) : -fabs(a))
poly.c:#define TOL             1.0e-11
poly.c:  l = nm = nml = 0;	/* To avoid gcc -Wall warnings */
poly.c:    nml = n-l;
poly.c:    if ((mmi = m - i) > 0)
poly.c:      for (k=mmi;k--;)
poly.c:        for (ap=ap0,k=mmi; k--; ap++)
poly.c:        g = -SIGN(sqrt(s),f);
poly.c:        h = f*g-s;
poly.c:        *ap0 = f-g;
poly.c:        for (j=nml;j--; ap10+=m)
poly.c:          for (s=0.0,ap=ap0,ap1=ap10,k=mmi; k--;)
poly.c:          for (ap=ap0,ap1=ap10,k=mmi; k--;)
poly.c:        for (ap=ap0,k=mmi; k--;)
poly.c:      for (k=nml;k--; ap+=m)
poly.c:        for (ap=ap0,k=nml;k--; ap+=m)
poly.c:        g = -SIGN(sqrt(s),f);
poly.c:        h=f*g-s;
poly.c:        *ap0=f-g;
poly.c:        for (ap=ap0,k=nml;k--; ap+=m)
poly.c:        for (j=m-l; j--; ap10++)
poly.c:          for (s=0.0,ap=ap0,ap1=ap10,k=nml; k--; ap+=m,ap1+=m)
poly.c:          for (ap1=ap10,k=nml;k--; ap1+=m)
poly.c:        for (ap=ap0,k=nml;k--; ap+=m)
poly.c:  for (i=n-1;i>=0;i--)
poly.c:    if (i < n-1)
poly.c:        for (ap=ap0,vp=vp0,j=nml; j--; ap+=m)
poly.c:        for (j=nml; j--; vp10+=n)
poly.c:          for (s=0.0,ap=ap0,vp1=vp10,k=nml; k--; ap+=m)
poly.c:          for (vp=vp0,vp1=vp10,k=nml; k--;)
poly.c:      for (j=nml; j--; vp+=n)
poly.c:    nml = n-l;
poly.c:  for (i=(m<n?m:n); --i>=0;)
poly.c:    nml = n-l;
poly.c:    mmi=m-i;
poly.c:    for (ap=ap10,j=nml;j--;ap+=m)
poly.c:      for (j=nml;j--; ap10+=m)
poly.c:        for (s=0.0,ap=ap0,ap1=ap10,k=mmi; --k;)
poly.c:        for (ap=ap0,ap1=ap10,k=mmi;k--;)
poly.c:      for (ap=ap0,j=mmi;j--;)
poly.c:      for (ap=ap0,j=mmi;j--;)
poly.c:  for (k=n; --k>=0;)
poly.c:        for (l=k;l>=0;l--)
poly.c:          nm=l-1;
poly.c:            s=(-f*h);
poly.c:            for (ap=ap0,ap1=ap10,j=m; j--;)
poly.c:              *(ap1++) = z*c-y*s;
poly.c:            wmat[k] = -z;
poly.c:            for (j=n; j--; vp++)
poly.c:              *vp = (-*vp);
poly.c:        nm=k-1;
poly.c:        f=((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);
poly.c:        f=((x-z)*(x+z)+h*((y/(f+SIGN(g,f)))-h))/x;
poly.c:          g=g*c-x*s;
poly.c:          for (vp=(vp1=vp10)+n,jj=n; jj--;)
poly.c:            *(vp++) = z*c-x*s;
poly.c:          x=c*y-s*g;
poly.c:          for (ap=(ap1=ap10)+m,jj=m; jj--;)
poly.c:            *(ap++) = z*c-y*s;
poly.c:  for (j=n;j--; w++)
poly.c:  for (j=n;j--; w++)
poly.c:  for (j=n; j--; w++)
poly.c:      for (i=m; i--;)
poly.c:    for (vp=vp0,jj=n; jj--; vp+=n)
poly.c:  ndim = poly->ndim;
poly.c:  group = poly->group;
poly.c:  degree = poly->degree;
poly.c:  QMALLOC(powers, int, ndim*poly->ncoeff);
poly.c:    for (expot=expo, d=ndim; --d;)
poly.c:    for (gexpot=gexpo, degreet=degree, g=poly->ngroup; g--;)
poly.c:      gexpo[*group]--;
poly.c:  for (t=poly->ncoeff; --t; )
poly.c:/*-- A complex recursion between terms of the polynom speeds up computations */
poly.c:      if (gexpo[*groupt]--)
prm:lin.c:   n = lin->naxis;
prm:lin.c:	 lin->naxis_sqr= (lin->naxis)*(lin->naxis);
prm:lin.c:   lin->piximg = (double*)malloc(mem);
prm:lin.c:   if (lin->piximg == (double*)0) return 1;
prm:lin.c:   lin->imgpix = (double*)malloc(mem);
prm:lin.c:   if (lin->imgpix == (double*)0) {
prm:lin.c:      free(lin->piximg);
prm:lin.c:         lin->piximg[ij] = lin->cdelt[i] * lin->pc[ij];
prm:lin.c:   if (matinv(n, lin->piximg, lin->imgpix)) return 2;
prm:lin.c:   lin->flag = LINSET;
prm:lin.c:   n = lin->naxis;
prm:lin.c:	 lin->naxis_sqr= (lin->naxis)*(lin->naxis);
prm:lin.c:   if (lin->flag != LINSET) {
prm:lin.c:         pixcrd[i] += lin->imgpix[ij] * imgcrd[j];
prm:lin.c:      pixcrd[j] += lin->crpix[j];
prm:lin.c:   n = lin->naxis;
prm:lin.c:   lin->naxis_sqr= (lin->naxis)*(lin->naxis);
prm:lin.c:   if (lin->flag != LINSET) {
prm:lin.c:      temp = pixcrd[j] - lin->crpix[j];
prm:lin.c:         imgcrd[i] += lin->piximg[ij] * temp;
prm:wcslib.c:      if (wcsset(lin->naxis, ctype, wcs)) return 1;
prm:wcslib.c:   for (j = 0; j < lin->naxis; j++) {
prm:wcslib.c:      if (wcsset(lin->naxis, ctype, wcs)) return 1;
prm:wcslib.c:   for (j = 0; j < lin->naxis; j++) {
prm:wcslib.c:      if (wcsset(lin->naxis, ctype, wcs)) return 1;
proj.c:*   WCSLIB - an implementation of the FITS WCS proposal.
proj.c:*   Copyright (C) 1995-2002, Mark Calabretta
proj.c:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
proj.c:*   -------------------
proj.c:*   projection parameters but need not be called explicitly - see the
proj.c:*      sflset sflfwd sflrev   SFL: Sanson-Flamsteed
proj.c:*      aitset aitfwd aitrev   AIT: Hammer-Aitoff
proj.c:*   ----------------------------------------------
proj.c:*   ------------------------------
proj.c:*   -----------------------------
proj.c:*   -----------------------------
proj.c:*   ---------------------
proj.c:*         intermediaries.  flag may also be set to -1 to disable strict bounds
proj.c:*         Three-letter projection code.
proj.c:*   -----------------
proj.c:*      normally lie in the range [-180,180] for phi, and [-90,90] for theta.
proj.c:*      within the range [-90,90].  They do check for any value of theta which
proj.c:*      relaxed by setting prj->flag to -1 (rather than 0) when these
proj.c:*      within the ranges [-180,180] for phi, and [-90,90] for theta.
proj.c:*   --------
proj.c:*   Closure to a precision of at least 1E-10 degree of longitude and latitude
proj.c:#define copysgn(X, Y) ((Y) < 0.0 ? -fabs(X) : fabs(X))
proj.c:#define copysgni(X, Y) ((Y) < 0 ? -abs(X) : abs(X))
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   return prj->prjfwd(phi, theta, prj, x, y);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   return prj->prjrev(x, y, prj, phi, theta);
proj.c:*      prj->p[1]    Distance parameter, mu in units of r0.
proj.c:*      prj->p[2]    Tilt angle, gamma in degrees.
proj.c:*      prj->flag    AZP, or -AZP if prj->flag is given < 0.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "AZP"
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->w[0]    r0*(mu+1)
proj.c:*      prj->w[1]    tan(gamma)
proj.c:*      prj->w[2]    sec(gamma)
proj.c:*      prj->w[3]    cos(gamma)
proj.c:*      prj->w[4]    sin(gamma)
proj.c:*      prj->w[5]    asin(-1/mu) for |mu| >= 1, -90 otherwise
proj.c:*      prj->w[6]    mu*cos(gamma)
proj.c:*      prj->w[7]    1 if |mu*cos(gamma)| < 1, 0 otherwise
proj.c:*      prj->prjfwd  Pointer to azpfwd().
proj.c:*      prj->prjrev  Pointer to azprev().
proj.c:   strcpy(prj->code, "AZP");
proj.c:   prj->flag   = copysgni (AZP, prj->flag);
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->w[0] = prj->r0*(prj->p[1] + 1.0);
proj.c:   if (prj->w[0] == 0.0) {
proj.c:   prj->w[3] = cosdeg (prj->p[2]);
proj.c:   if (prj->w[3] == 0.0) {
proj.c:   prj->w[2] = 1.0/prj->w[3];
proj.c:   prj->w[4] = sindeg (prj->p[2]);
proj.c:   prj->w[1] = prj->w[4] / prj->w[3];
proj.c:   if (fabs(prj->p[1]) > 1.0) {
proj.c:      prj->w[5] = asindeg (-1.0/prj->p[1]);
proj.c:      prj->w[5] = -90.0;
proj.c:   prj->w[6] = prj->p[1] * prj->w[3];
proj.c:   prj->w[7] = (fabs(prj->w[6]) < 1.0) ? 1.0 : 0.0;
proj.c:   prj->prjfwd = azpfwd;
proj.c:   prj->prjrev = azprev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != AZP) {
proj.c:   s = prj->w[1]*cphi;
proj.c:   t = (prj->p[1] + sindeg (theta)) + cthe*s;
proj.c:   r  =  prj->w[0]*cthe/t;
proj.c:   *y = -r*cphi*prj->w[2];
proj.c:   if (prj->flag > 0) {
proj.c:      if (theta < prj->w[5]) {
proj.c:      if (prj->w[7] > 0.0) {
proj.c:         t = prj->p[1] / sqrt(1.0 + s*s);
proj.c:            s = atandeg (-s);
proj.c:            a = s - t;
proj.c:            if (a > 90.0) a -= 360.0;
proj.c:            if (b > 90.0) b -= 360.0;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-13;
proj.c:   if (abs(prj->flag) != AZP) {
proj.c:   ycosg = y*prj->w[3];
proj.c:      *phi = atan2deg (x, -ycosg);
proj.c:      s = r / (prj->w[0] + y*prj->w[4]);
proj.c:      t = s*prj->p[1]/sqrt(s*s + 1.0);
proj.c:      a = s - t;
proj.c:      if (a > 90.0) a -= 360.0;
proj.c:      if (b > 90.0) b -= 360.0;
proj.c:*      prj->p[1]    Distance of the point of projection from the centre of the
proj.c:*      prj->p[2]    Native longitude, phi_c, and ...
proj.c:*      prj->p[3]    Native latitude, theta_c, on the planewards side of the
proj.c:*      prj->flag    SZP, or -SZP if prj->flag is given < 0.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "SZP"
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->w[0]    1/r0
proj.c:*      prj->w[1]    xp = -mu*cos(theta_c)*sin(phi_c)
proj.c:*      prj->w[2]    yp =  mu*cos(theta_c)*cos(phi_c)
proj.c:*      prj->w[3]    zp =  mu*sin(theta_c) + 1
proj.c:*      prj->w[4]    r0*xp
proj.c:*      prj->w[5]    r0*yp
proj.c:*      prj->w[6]    r0*zp
proj.c:*      prj->w[7]    (zp - 1)^2
proj.c:*      prj->w[8]    asin(1-zp) if |1 - zp| < 1, -90 otherwise
proj.c:*      prj->prjfwd  Pointer to szpfwd().
proj.c:*      prj->prjrev  Pointer to szprev().
proj.c:   strcpy(prj->code, "SZP");
proj.c:   prj->flag   = copysgni (SZP, prj->flag);
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->w[0] = 1.0/prj->r0;
proj.c:   prj->w[3] = prj->p[1] * sindeg (prj->p[3]) + 1.0;
proj.c:   if (prj->w[3] == 0.0) {
proj.c:   prj->w[1] = -prj->p[1] * cosdeg (prj->p[3]) * sindeg (prj->p[2]);
proj.c:   prj->w[2] =  prj->p[1] * cosdeg (prj->p[3]) * cosdeg (prj->p[2]);
proj.c:   prj->w[4] =  prj->r0 * prj->w[1];
proj.c:   prj->w[5] =  prj->r0 * prj->w[2];
proj.c:   prj->w[6] =  prj->r0 * prj->w[3];
proj.c:   prj->w[7] =  (prj->w[3] - 1.0) * prj->w[3] - 1.0;
proj.c:   if (fabs(prj->w[3] - 1.0) < 1.0) {
proj.c:      prj->w[8] = asindeg (1.0 - prj->w[3]);
proj.c:      prj->w[8] = -90.0;
proj.c:   prj->prjfwd = szpfwd;
proj.c:   prj->prjrev = szprev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != SZP) {
proj.c:   s = 1.0 - sindeg (theta);
proj.c:   t = prj->w[3] - s;
proj.c:   *x =  (prj->w[6]*cthe*sphi - prj->w[4]*s)/t;
proj.c:   *y = -(prj->w[6]*cthe*cphi + prj->w[5]*s)/t;
proj.c:   if (prj->flag > 0) {
proj.c:      if (theta < prj->w[8]) {
proj.c:      if (fabs(prj->p[1]) > 1.0) {
proj.c:         s = prj->w[1]*sphi - prj->w[2]*cphi;
proj.c:         t = 1.0/sqrt(prj->w[7] + s*s);
proj.c:            s = atan2deg (s, prj->w[3] - 1.0);
proj.c:            a = s - t;
proj.c:            if (a > 90.0) a -= 360.0;
proj.c:            if (b > 90.0) b -= 360.0;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-13;
proj.c:   if (abs(prj->flag) != SZP) {
proj.c:   xp = x*prj->w[0];
proj.c:   yp = y*prj->w[0];
proj.c:   x1 = (xp - prj->w[1])/prj->w[3];
proj.c:   y1 = (yp - prj->w[2])/prj->w[3];
proj.c:   if (r2 < 1.0e-10) {
proj.c:      *theta = 90.0 - R2D*sqrt(r2/(1.0 + sxy));
proj.c:      b = sxy - t;
proj.c:      c = r2 - sxy - sxy + t - 1.0;
proj.c:      d = b*b - a*c;
proj.c:      sth1 = (-b + d)/a;
proj.c:      sth2 = (-b - d)/a;
proj.c:         if (sthe-1.0 < tol) {
proj.c:      if (sthe < -1.0) {
proj.c:         if (sthe+1.0 > -tol) {
proj.c:            sthe = -1.0;
proj.c:      if (sthe > 1.0 || sthe < -1.0) {
proj.c:      z = 1.0 - sthe;
proj.c:   *phi = atan2deg (xp - x1*z, -(yp - y1*z));
proj.c:*      prj->flag    TAN, or -TAN if prj->flag is given < 0.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "TAN"
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->prjfwd  Pointer to tanfwd().
proj.c:*      prj->prjrev  Pointer to tanrev().
proj.c:   strcpy(prj->code, "TAN");
proj.c:   prj->flag   = copysgni (TAN, prj->flag);
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->prjfwd = tanfwd;
proj.c:   prj->prjrev = tanrev;
proj.c:   for (k = (MAXPV-1); k >= 0 && prj->ppv[k] == 0.0 && prj->ppv[k+MAXPV] == 0.0; k--);
proj.c:   prj->npv = k;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != TAN) {
proj.c:   r =  prj->r0*cosdeg (theta)/s;
proj.c:   xp[1] = -r*cosdeg (phi);
proj.c:   *x = prj->inv_x? poly_func(prj->inv_x, xp) : xp[0];
proj.c:   *y = prj->inv_y? poly_func(prj->inv_y, xp) : xp[1];
proj.c:   if (prj->flag > 0 && s < 0.0) {
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != TAN) {
proj.c:   if (prj->npv) {
proj.c:      *phi = atan2deg (xp, -yp);
proj.c:   *theta = atan2deg (prj->r0, r);
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "STG"
proj.c:*      prj->flag     STG
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->w[0]    2*r0
proj.c:*      prj->w[1]    1/(2*r0)
proj.c:*      prj->prjfwd  Pointer to stgfwd().
proj.c:*      prj->prjrev  Pointer to stgrev().
proj.c:   strcpy(prj->code, "STG");
proj.c:   prj->flag   =  STG;
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      //prj->w[0] = 360.0/PI;
proj.c:			prj->w[0] = 360.0/WCS_PI;
proj.c:      //prj->w[1] = PI/360.0;
proj.c:			prj->w[1] = WCS_PI/360.0;
proj.c:      prj->w[0] = 2.0*prj->r0;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = stgfwd;
proj.c:   prj->prjrev = stgrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != STG) {
proj.c:   r =  prj->w[0]*cosdeg (theta)/s;
proj.c:   *y = -r*cosdeg (phi);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != STG) {
proj.c:      *phi = atan2deg (x, -y);
proj.c:   *theta = 90.0 - 2.0*atandeg (r*prj->w[1]);
proj.c:*      prj->p[1:2]  Obliqueness parameters, xi and eta.
proj.c:*      prj->flag    SIN, or -SIN if prj->flag is given < 0.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "SIN"
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->w[0]    1/r0
proj.c:*      prj->w[1]    xi**2 + eta**2
proj.c:*      prj->w[2]    xi**2 + eta**2 + 1
proj.c:*      prj->w[3]    xi**2 + eta**2 - 1
proj.c:*      prj->prjfwd  Pointer to sinfwd().
proj.c:*      prj->prjrev  Pointer to sinrev().
proj.c:   strcpy(prj->code, "SIN");
proj.c:   prj->flag   = copysgni (SIN, prj->flag);
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->w[0] = 1.0/prj->r0;
proj.c:   prj->w[1] = prj->p[1]*prj->p[1] + prj->p[2]*prj->p[2];
proj.c:   prj->w[2] = prj->w[1] + 1.0;
proj.c:   prj->w[3] = prj->w[1] - 1.0;
proj.c:   prj->prjfwd = sinfwd;
proj.c:   prj->prjrev = sinrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != SIN) {
proj.c:   t = (90.0 - fabs(theta))*D2R;
proj.c:   if (t < 1.0e-5) {
proj.c:         z = 2.0 - t*t/2.0;
proj.c:      z =  1.0 - sindeg (theta);
proj.c:   *x =  prj->r0*(cthe*sphi + prj->p[1]*z);
proj.c:   *y = -prj->r0*(cthe*cphi - prj->p[2]*z);
proj.c:   if (prj->flag > 0) {
proj.c:      if (prj->w[1] == 0.0) {
proj.c:         t = -atandeg (prj->p[1]*sphi - prj->p[2]*cphi);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-13;
proj.c:   if (abs(prj->flag) != SIN) {
proj.c:   x0 = x*prj->w[0];
proj.c:   y0 = y*prj->w[0];
proj.c:   if (prj->w[1] == 0.0) {
proj.c:         *phi = atan2deg (x0, -y0);
proj.c:         *theta = asindeg (sqrt(1.0 - r2));
proj.c:      x1 = prj->p[1];
proj.c:      y1 = prj->p[2];
proj.c:      if (r2 < 1.0e-10) {
proj.c:         *theta = 90.0 - R2D*sqrt(r2/(1.0 + sxy));
proj.c:         a = prj->w[2];
proj.c:         b = sxy - prj->w[1];
proj.c:         c = r2 - sxy - sxy + prj->w[3];
proj.c:         d = b*b - a*c;
proj.c:         sth1 = (-b + d)/a;
proj.c:         sth2 = (-b - d)/a;
proj.c:            if (sthe-1.0 < tol) {
proj.c:         if (sthe < -1.0) {
proj.c:            if (sthe+1.0 > -tol) {
proj.c:               sthe = -1.0;
proj.c:         if (sthe > 1.0 || sthe < -1.0) {
proj.c:         z = 1.0 - sthe;
proj.c:      xp = -y0 + prj->p[2]*z;
proj.c:      yp =  x0 - prj->p[1]*z;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "ARC"
proj.c:*      prj->flag     ARC
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->w[0]    r0*(pi/180)
proj.c:*      prj->w[1]    (180/pi)/r0
proj.c:*      prj->prjfwd  Pointer to arcfwd().
proj.c:*      prj->prjrev  Pointer to arcrev().
proj.c:   strcpy(prj->code, "ARC");
proj.c:   prj->flag   =  ARC;
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 1.0;
proj.c:      prj->w[1] = 1.0;
proj.c:      prj->w[0] = prj->r0*D2R;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = arcfwd;
proj.c:   prj->prjrev = arcrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != ARC) {
proj.c:   r =  prj->w[0]*(90.0 - theta);
proj.c:   *y = -r*cosdeg (phi);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != ARC) {
proj.c:      *phi = atan2deg (x, -y);
proj.c:   *theta = 90.0 - r*prj->w[1];
proj.c:*      prj->p[0:9]  Polynomial coefficients.
proj.c:*      prj->flag    ZPN, or -ZPN if prj->flag is given < 0.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "ZPN"
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->n       Degree of the polynomial, N.
proj.c:*      prj->w[0]    Co-latitude of the first point of inflection (N > 2).
proj.c:*      prj->w[1]    Radius of the first point of inflection (N > 2).
proj.c:*      prj->prjfwd  Pointer to zpnfwd().
proj.c:*      prj->prjrev  Pointer to zpnrev().
proj.c:   const double tol = 1.0e-13;
proj.c:   strcpy(prj->code, "ZPN");
proj.c:   prj->flag   = copysgni (ZPN, prj->flag);
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   /* Find the highest non-zero coefficient. */
proj.c:   for (k = 9; k >= 0 && prj->p[k] == 0.0; k--){
proj.c:   prj->n = k;
proj.c:   /* No negative derivative -> no point of inflection. */
proj.c:   prj->prjfwd = zpnfwd;
proj.c:   prj->prjrev = zpnrev;
proj.c:      d1  = prj->p[1];
proj.c:         for (j = k; j > 0; j--) {
proj.c:            d2 = d2*zd2 + j*prj->p[j];
proj.c:         /* No negative derivative -> no point of inflection. */
proj.c:            zd = zd1 - d1*(zd2-zd1)/(d2-d1);
proj.c:            for (j = k; j > 0; j--) {
proj.c:               d = d*zd + j*prj->p[j];
proj.c:      for (j = k; j >= 0; j--) {
proj.c:         r = r*zd + prj->p[j];
proj.c:      prj->w[0] = zd;
proj.c:      prj->w[1] = r;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != ZPN) {
proj.c:   s = (90.0 - theta)*D2R;
proj.c:   for (j = 9; j >= 0; j--) {
proj.c:      r = r*s + prj->p[j];
proj.c:   r = prj->r0*r;
proj.c:   *y = -r*cosdeg (phi);
proj.c:   if (prj->flag > 0 && s > prj->w[0]) {
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-13;
proj.c:   if (abs(prj->flag) != ZPN) {
proj.c:   k = prj->n;
proj.c:   r = sqrt(x*x + y*y)/prj->r0;
proj.c:      /* Constant - no solution. */
proj.c:      zd = (r - prj->p[0])/prj->p[1];
proj.c:      a = prj->p[2];
proj.c:      b = prj->p[1];
proj.c:      c = prj->p[0] - r;
proj.c:      d = b*b - 4.0*a*c;
proj.c:      zd1 = (-b + d)/(2.0*a);
proj.c:      zd2 = (-b - d)/(2.0*a);
proj.c:      if (zd < -tol) zd = (zd1>zd2) ? zd1 : zd2;
proj.c:         if (zd < -tol) {
proj.c:      /* Higher order - solve iteratively. */
proj.c:      r1  = prj->p[0];
proj.c:      zd2 = prj->w[0];
proj.c:      r2  = prj->w[1];
proj.c:         if (r < r1-tol) {
proj.c:            lambda = (r2 - r)/(r2 - r1);
proj.c:            zd = zd2 - lambda*(zd2 - zd1);
proj.c:            for (i = k; i >= 0; i--) {
proj.c:                rt = (rt * zd) + prj->p[i];
proj.c:                if (r-rt < tol) break;
proj.c:                if (rt-r < tol) break;
proj.c:            if (fabs(zd2-zd1) < tol) break;
proj.c:      *phi = atan2deg (x, -y);
proj.c:   *theta = 90.0 - zd*R2D;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "ZEA"
proj.c:*      prj->flag     ZEA
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->w[0]    2*r0
proj.c:*      prj->w[1]    1/(2*r0)
proj.c:*      prj->prjfwd  Pointer to zeafwd().
proj.c:*      prj->prjrev  Pointer to zearev().
proj.c:   strcpy(prj->code, "ZEA");
proj.c:   prj->flag   =  ZEA;
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      //prj->w[0] = 360.0/PI;
proj.c:			prj->w[0] = 360.0/WCS_PI;
proj.c:      //prj->w[1] = PI/360.0;
proj.c:			prj->w[1] = WCS_PI/360.0;
proj.c:      prj->w[0] = 2.0*prj->r0;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = zeafwd;
proj.c:   prj->prjrev = zearev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != ZEA) {
proj.c:   r =  prj->w[0]*sindeg ((90.0 - theta)/2.0);
proj.c:   *y = -r*cosdeg (phi);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != ZEA) {
proj.c:      *phi = atan2deg (x, -y);
proj.c:   s = r*prj->w[1];
proj.c:      if (fabs(r - prj->w[0]) < tol) {
proj.c:         *theta = -90.0;
proj.c:      *theta = 90.0 - 2.0*asindeg (s);
proj.c:*      prj->p[1]    Latitude theta_b within which the error is minimized, in
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "AIR"
proj.c:*      prj->flag     AIR
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  90.0
proj.c:*      prj->w[0]    2*r0
proj.c:*      prj->w[1]    ln(cos(xi_b))/tan(xi_b)**2, where xi_b = (90-theta_b)/2
proj.c:*      prj->w[2]    1/2 - prj->w[1]
proj.c:*      prj->w[3]    2*r0*prj->w[2]
proj.c:*      prj->w[4]    tol, cutoff for using small angle approximation, in
proj.c:*      prj->w[5]    prj->w[2]*tol
proj.c:*      prj->w[6]    (180/pi)/prj->w[2]
proj.c:*      prj->prjfwd  Pointer to airfwd().
proj.c:*      prj->prjrev  Pointer to airrev().
proj.c:   const double tol = 1.0e-4;
proj.c:   strcpy(prj->code, "AIR");
proj.c:   prj->flag   =  AIR;
proj.c:   prj->phi0   =  0.0;
proj.c:   prj->theta0 = 90.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->w[0] = 2.0*prj->r0;
proj.c:   if (prj->p[1] == 90.0) {
proj.c:      prj->w[1] = -0.5;
proj.c:      prj->w[2] =  1.0;
proj.c:   } else if (prj->p[1] > -90.0) {
proj.c:      cxi = cosdeg ((90.0 - prj->p[1])/2.0);
proj.c:      prj->w[1] = log(cxi)*(cxi*cxi)/(1.0-cxi*cxi);
proj.c:      prj->w[2] = 0.5 - prj->w[1];
proj.c:   prj->w[3] = prj->w[0] * prj->w[2];
proj.c:   prj->w[4] = tol;
proj.c:   prj->w[5] = prj->w[2]*tol;
proj.c:   prj->w[6] = R2D/prj->w[2];
proj.c:   prj->prjfwd = airfwd;
proj.c:   prj->prjrev = airrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != AIR) {
proj.c:   } else if (theta > -90.0) {
proj.c:      xi = D2R*(90.0 - theta)/2.0;
proj.c:      if (xi < prj->w[4]) {
proj.c:         r = xi*prj->w[3];
proj.c:         cxi = cosdeg ((90.0 - theta)/2.0);
proj.c:         txi = sqrt(1.0-cxi*cxi)/cxi;
proj.c:         r = -prj->w[0]*(log(cxi)/txi + prj->w[1]*txi);
proj.c:   *y = -r*cosdeg (phi);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != AIR) {
proj.c:   r = sqrt(x*x + y*y)/prj->w[0];
proj.c:   } else if (r < prj->w[5]) {
proj.c:      xi = r*prj->w[6];
proj.c:         txi = sqrt(1.0-x2*x2)/x2;
proj.c:         r2 = -(log(x2)/txi + prj->w[1]*txi);
proj.c:         lambda = (r2-r)/(r2-r1);
proj.c:         cxi = x2 - lambda*(x2-x1);
proj.c:         txi = sqrt(1.0-cxi*cxi)/cxi;
proj.c:         rt = -(log(cxi)/txi + prj->w[1]*txi);
proj.c:             if (r-rt < tol) break;
proj.c:             if (rt-r < tol) break;
proj.c:      *phi = atan2deg (x, -y);
proj.c:   *theta = 90.0 - 2.0*xi;
proj.c:*      prj->p[1]    Distance of point of projection from the centre of the
proj.c:*      prj->p[2]    Radius of the cylinder of projection, lambda, in units of
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "CYP"
proj.c:*      prj->flag    CYP
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*lambda*(pi/180)
proj.c:*      prj->w[1]    (180/pi)/(r0*lambda)
proj.c:*      prj->w[2]    r0*(mu + lambda)
proj.c:*      prj->w[3]    1/(r0*(mu + lambda))
proj.c:*      prj->prjfwd  Pointer to cypfwd().
proj.c:*      prj->prjrev  Pointer to cyprev().
proj.c:   strcpy(prj->code, "CYP");
proj.c:   prj->flag   = CYP;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = prj->p[2];
proj.c:      if (prj->w[0] == 0.0) {
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:      prj->w[2] = R2D*(prj->p[1] + prj->p[2]);
proj.c:      if (prj->w[2] == 0.0) {
proj.c:      prj->w[3] = 1.0/prj->w[2];
proj.c:      prj->w[0] = prj->r0*prj->p[2]*D2R;
proj.c:      if (prj->w[0] == 0.0) {
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:      prj->w[2] = prj->r0*(prj->p[1] + prj->p[2]);
proj.c:      if (prj->w[2] == 0.0) {
proj.c:      prj->w[3] = 1.0/prj->w[2];
proj.c:   prj->prjfwd = cypfwd;
proj.c:   prj->prjrev = cyprev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != CYP) {
proj.c:   s = prj->p[1] + cosdeg (theta);
proj.c:   *x = prj->w[0]*phi;
proj.c:   *y = prj->w[2]*sindeg (theta)/s;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != CYP) {
proj.c:   *phi   = x*prj->w[1];
proj.c:   eta    = y*prj->w[3];
proj.c:   *theta = atan2deg (eta,1.0) + asindeg (eta*prj->p[1]/sqrt(eta*eta+1.0));
proj.c:*      prj->p[1]    Square of the cosine of the latitude at which the
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "CEA"
proj.c:*      prj->flag    CEA
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/180)
proj.c:*      prj->w[1]    (180/pi)/r0
proj.c:*      prj->w[2]    r0/lambda
proj.c:*      prj->w[3]    lambda/r0
proj.c:*      prj->prjfwd  Pointer to ceafwd().
proj.c:*      prj->prjrev  Pointer to cearev().
proj.c:   strcpy(prj->code, "CEA");
proj.c:   prj->flag   = CEA;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 1.0;
proj.c:      prj->w[1] = 1.0;
proj.c:      if (prj->p[1] <= 0.0 || prj->p[1] > 1.0) {
proj.c:      prj->w[2] = prj->r0/prj->p[1];
proj.c:      prj->w[3] = prj->p[1]/prj->r0;
proj.c:      prj->w[0] = prj->r0*D2R;
proj.c:      prj->w[1] = R2D/prj->r0;
proj.c:      if (prj->p[1] <= 0.0 || prj->p[1] > 1.0) {
proj.c:      prj->w[2] = prj->r0/prj->p[1];
proj.c:      prj->w[3] = prj->p[1]/prj->r0;
proj.c:   prj->prjfwd = ceafwd;
proj.c:   prj->prjrev = cearev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != CEA) {
proj.c:   *x = prj->w[0]*phi;
proj.c:   *y = prj->w[2]*sindeg (theta);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-13;
proj.c:   if (prj->flag != CEA) {
proj.c:   s = y*prj->w[3];
proj.c:   *phi   = x*prj->w[1];
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "CAR"
proj.c:*      prj->flag    CAR
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/180)
proj.c:*      prj->w[1]    (180/pi)/r0
proj.c:*      prj->prjfwd  Pointer to carfwd().
proj.c:*      prj->prjrev  Pointer to carrev().
proj.c:   strcpy(prj->code, "CAR");
proj.c:   //prj->flag   = CAR;
proj.c:	 prj->flag   = kCAR;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 1.0;
proj.c:      prj->w[1] = 1.0;
proj.c:      prj->w[0] = prj->r0*D2R;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = carfwd;
proj.c:   prj->prjrev = carrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   //if (prj->flag != CAR) {
proj.c:	 if (prj->flag != kCAR) {
proj.c:   *x = prj->w[0]*phi;
proj.c:   *y = prj->w[0]*theta;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   //if (prj->flag != CAR) {
proj.c:	 if (prj->flag != kCAR) {
proj.c:   *phi   = prj->w[1]*x;
proj.c:   *theta = prj->w[1]*y;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "MER"
proj.c:*      prj->flag    MER
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/180)
proj.c:*      prj->w[1]    (180/pi)/r0
proj.c:*      prj->prjfwd  Pointer to merfwd().
proj.c:*      prj->prjrev  Pointer to merrev().
proj.c:   strcpy(prj->code, "MER");
proj.c:   prj->flag   = MER;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 1.0;
proj.c:      prj->w[1] = 1.0;
proj.c:      prj->w[0] = prj->r0*D2R;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = merfwd;
proj.c:   prj->prjrev = merrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != MER) {
proj.c:   if (theta <= -90.0 || theta >= 90.0) {
proj.c:   *x = prj->w[0]*phi;
proj.c:   *y = prj->r0*log(tandeg ((90.0+theta)/2.0));
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != MER) {
proj.c:   *phi   = x*prj->w[1];
proj.c:   *theta = 2.0*atandeg (exp(y/prj->r0)) - 90.0;
proj.c:*   SFL: Sanson-Flamsteed ("global sinusoid") projection.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "SFL"
proj.c:*      prj->flag    SFL
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/180)
proj.c:*      prj->w[1]    (180/pi)/r0
proj.c:*      prj->prjfwd  Pointer to sflfwd().
proj.c:*      prj->prjrev  Pointer to sflrev().
proj.c:   strcpy(prj->code, "SFL");
proj.c:   prj->flag   = SFL;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 1.0;
proj.c:      prj->w[1] = 1.0;
proj.c:      prj->w[0] = prj->r0*D2R;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = sflfwd;
proj.c:   prj->prjrev = sflrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != SFL) {
proj.c:   *x = prj->w[0]*phi*cosdeg (theta);
proj.c:   *y = prj->w[0]*theta;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != SFL) {
proj.c:   w = cos(y/prj->r0);
proj.c:      *phi = x*prj->w[1]/cos(y/prj->r0);
proj.c:   *theta = y*prj->w[1];
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "PAR"
proj.c:*      prj->flag    PAR
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/180)
proj.c:*      prj->w[1]    (180/pi)/r0
proj.c:*      prj->w[2]    pi*r0
proj.c:*      prj->w[3]    1/(pi*r0)
proj.c:*      prj->prjfwd  Pointer to parfwd().
proj.c:*      prj->prjrev  Pointer to parrev().
proj.c:   strcpy(prj->code, "PAR");
proj.c:   prj->flag   = PAR;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 1.0;
proj.c:      prj->w[1] = 1.0;
proj.c:      prj->w[2] = 180.0;
proj.c:      prj->w[3] = 1.0/prj->w[2];
proj.c:      prj->w[0] = prj->r0*D2R;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:      //prj->w[2] = PI*prj->r0;
proj.c:			prj->w[2] = WCS_PI*prj->r0;
proj.c:      prj->w[3] = 1.0/prj->w[2];
proj.c:   prj->prjfwd = parfwd;
proj.c:   prj->prjrev = parrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != PAR) {
proj.c:   *x = prj->w[0]*phi*(1.0 - 4.0*s*s);
proj.c:   *y = prj->w[2]*s;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != PAR) {
proj.c:   s = y*prj->w[3];
proj.c:   if (s > 1.0 || s < -1.0) {
proj.c:   t = 1.0 - 4.0*s*s;
proj.c:      *phi = prj->w[1]*x/t;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "MOL"
proj.c:*      prj->flag    MOL
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    sqrt(2)*r0
proj.c:*      prj->w[1]    sqrt(2)*r0/90
proj.c:*      prj->w[2]    1/(sqrt(2)*r0)
proj.c:*      prj->w[3]    90/r0
proj.c:*      prj->prjfwd  Pointer to molfwd().
proj.c:*      prj->prjrev  Pointer to molrev().
proj.c:   strcpy(prj->code, "MOL");
proj.c:   prj->flag   = MOL;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->w[0] = SQRT2*prj->r0;
proj.c:   prj->w[1] = prj->w[0]/90.0;
proj.c:   prj->w[2] = 1.0/prj->w[0];
proj.c:   prj->w[3] = 90.0/prj->r0;
proj.c:   //prj->w[4] = 2.0/PI;
proj.c:	 prj->w[4] = 2.0/WCS_PI;
proj.c:   prj->prjfwd = molfwd;
proj.c:   prj->prjrev = molrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-13;
proj.c:   if (prj->flag != MOL) {
proj.c:      *y = copysgn (prj->w[0],theta);
proj.c:      *x = prj->w[1]*phi;
proj.c:		  //v0 = -PI;
proj.c:			v0 = -WCS_PI;
proj.c:         resid = (v - u) + sin(v);
proj.c:            if (resid > -tol) break;
proj.c:      *x = prj->w[1]*phi*cos(gamma);
proj.c:      *y = prj->w[0]*sin(gamma);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != MOL) {
proj.c:   y0 = y/prj->r0;
proj.c:   s  = 2.0 - y0*y0;
proj.c:      if (s < -tol) {
proj.c:      *phi = prj->w[3]*x/s;
proj.c:   z = y*prj->w[2];
proj.c:      //z = asin(z)*prj->w[4] + y0*s/PI;
proj.c:      z = asin(z)*prj->w[4] + y0*s/WCS_PI;
proj.c:*   AIT: Hammer-Aitoff projection.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "AIT"
proj.c:*      prj->flag    AIT
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    2*r0**2
proj.c:*      prj->w[1]    1/(2*r0)**2
proj.c:*      prj->w[2]    1/(4*r0)**2
proj.c:*      prj->w[3]    1/(2*r0)
proj.c:*      prj->prjfwd  Pointer to aitfwd().
proj.c:*      prj->prjrev  Pointer to aitrev().
proj.c:   strcpy(prj->code, "AIT");
proj.c:   prj->flag   = AIT;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->w[0] = 2.0*prj->r0*prj->r0;
proj.c:   prj->w[1] = 1.0/(2.0*prj->w[0]);
proj.c:   prj->w[2] = prj->w[1]/4.0;
proj.c:   prj->w[3] = 1.0/(2.0*prj->r0);
proj.c:   prj->prjfwd = aitfwd;
proj.c:   prj->prjrev = aitrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != AIT) {
proj.c:   w = sqrt(prj->w[0]/(1.0 + cthe*cosdeg (phi/2.0)));
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-13;
proj.c:   if (prj->flag != AIT) {
proj.c:   u = 1.0 - x*x*prj->w[2] - y*y*prj->w[1];
proj.c:      if (u < -tol) {
proj.c:   s = z*y/prj->r0;
proj.c:   xp = 2.0*z*z - 1.0;
proj.c:   yp = z*x*prj->w[3];
proj.c:*      prj->p[1]    sigma = (theta2+theta1)/2
proj.c:*      prj->p[2]    delta = (theta2-theta1)/2, where theta1 and theta2 are the
proj.c:*      prj->flag    COP, or -COP if prj->flag is given < 0.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "COP"
proj.c:*      prj->phi0     0.0
proj.c:*      prj->theta0  sigma
proj.c:*      prj->w[0]    C  = sin(sigma)
proj.c:*      prj->w[1]    1/C
proj.c:*      prj->w[2]    Y0 = r0*cos(delta)*cot(sigma)
proj.c:*      prj->w[3]    r0*cos(delta)
proj.c:*      prj->w[4]    1/(r0*cos(delta)
proj.c:*      prj->w[5]    cot(sigma)
proj.c:*      prj->prjfwd  Pointer to copfwd().
proj.c:*      prj->prjrev  Pointer to coprev().
proj.c:   strcpy(prj->code, "COP");
proj.c:   prj->flag   = copysgni (COP, prj->flag);
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = prj->p[1];
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   prj->w[0] = sindeg (prj->p[1]);
proj.c:   if (prj->w[0] == 0.0) {
proj.c:   prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->w[3] = prj->r0*cosdeg (prj->p[2]);
proj.c:   if (prj->w[3] == 0.0) {
proj.c:   prj->w[4] = 1.0/prj->w[3];
proj.c:   prj->w[5] = 1.0/tandeg (prj->p[1]);
proj.c:   prj->w[2] = prj->w[3]*prj->w[5];
proj.c:   prj->prjfwd = copfwd;
proj.c:   prj->prjrev = coprev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != COP) {
proj.c:   t = theta - prj->p[1];
proj.c:   a = prj->w[0]*phi;
proj.c:   r = prj->w[2] - prj->w[3]*sindeg (t)/s;
proj.c:   *y = prj->w[2] - r*cosdeg (a);
proj.c:   if (prj->flag > 0 && r*prj->w[0] < 0.0) {
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (abs(prj->flag) != COP) {
proj.c:   dy = prj->w[2] - y;
proj.c:   if (prj->p[1] < 0.0) r = -r;
proj.c:   *phi   = a*prj->w[1];
proj.c:   *theta = prj->p[1] + atandeg (prj->w[5] - r*prj->w[4]);
proj.c:*      prj->p[1]    sigma = (theta2+theta1)/2
proj.c:*      prj->p[2]    delta = (theta2-theta1)/2, where theta1 and theta2 are the
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "COE"
proj.c:*      prj->flag    COE
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  sigma
proj.c:*      prj->w[0]    C = (sin(theta1) + sin(theta2))/2
proj.c:*      prj->w[1]    1/C
proj.c:*      prj->w[2]    Y0 = chi*sqrt(psi - 2C*sindeg (sigma))
proj.c:*      prj->w[3]    chi = r0/C
proj.c:*      prj->w[4]    psi = 1 + sin(theta1)*sin(theta2)
proj.c:*      prj->w[5]    2C
proj.c:*      prj->w[6]    (1 + sin(theta1)*sin(theta2))*(r0/C)**2
proj.c:*      prj->w[7]    C/(2*r0**2)
proj.c:*      prj->w[8]    chi*sqrt(psi + 2C)
proj.c:*      prj->prjfwd  Pointer to coefwd().
proj.c:*      prj->prjrev  Pointer to coerev().
proj.c:   strcpy(prj->code, "COE");
proj.c:   prj->flag   = COE;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = prj->p[1];
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   theta1 = prj->p[1] - prj->p[2];
proj.c:   theta2 = prj->p[1] + prj->p[2];
proj.c:   prj->w[0] = (sindeg (theta1) + sindeg (theta2))/2.0;
proj.c:   if (prj->w[0] == 0.0) {
proj.c:   prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->w[3] = prj->r0/prj->w[0];
proj.c:   prj->w[4] = 1.0 + sindeg (theta1)*sindeg (theta2);
proj.c:   prj->w[5] = 2.0*prj->w[0];
proj.c:   prj->w[6] = prj->w[3]*prj->w[3]*prj->w[4];
proj.c:   prj->w[7] = 1.0/(2.0*prj->r0*prj->w[3]);
proj.c:   prj->w[8] = prj->w[3]*sqrt(prj->w[4] + prj->w[5]);
proj.c:   prj->w[2] = prj->w[3]*sqrt(prj->w[4] - prj->w[5]*sindeg (prj->p[1]));
proj.c:   prj->prjfwd = coefwd;
proj.c:   prj->prjrev = coerev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != COE) {
proj.c:   a = phi*prj->w[0];
proj.c:   if (theta == -90.0) {
proj.c:      r = prj->w[8];
proj.c:      r = prj->w[3]*sqrt(prj->w[4] - prj->w[5]*sindeg (theta));
proj.c:   *y = prj->w[2] - r*cosdeg (a);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != COE) {
proj.c:   dy = prj->w[2] - y;
proj.c:   if (prj->p[1] < 0.0) r = -r;
proj.c:   *phi = a*prj->w[1];
proj.c:   if (fabs(r - prj->w[8]) < tol) {
proj.c:      *theta = -90.0;
proj.c:      w = (prj->w[6] - r*r)*prj->w[7];
proj.c:         if (fabs(w-1.0) < tol) {
proj.c:            *theta = -90.0;
proj.c:*      prj->p[1]    sigma = (theta2+theta1)/2
proj.c:*      prj->p[2]    delta = (theta2-theta1)/2, where theta1 and theta2 are the
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "COD"
proj.c:*      prj->flag    COD
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  sigma
proj.c:*      prj->w[0]    C = r0*sin(sigma)*sin(delta)/delta
proj.c:*      prj->w[1]    1/C
proj.c:*      prj->w[2]    Y0 = delta*cot(delta)*cot(sigma)
proj.c:*      prj->w[3]    Y0 + sigma
proj.c:*      prj->prjfwd  Pointer to codfwd().
proj.c:*      prj->prjrev  Pointer to codrev().
proj.c:   strcpy(prj->code, "COD");
proj.c:   prj->flag   = COD;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = prj->p[1];
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   if (prj->p[2] == 0.0) {
proj.c:      prj->w[0] = prj->r0*sindeg (prj->p[1])*D2R;
proj.c:      prj->w[0] = prj->r0*sindeg (prj->p[1])*sindeg (prj->p[2])/prj->p[2];
proj.c:   if (prj->w[0] == 0.0) {
proj.c:   prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->w[2] = prj->r0*cosdeg (prj->p[2])*cosdeg (prj->p[1])/prj->w[0];
proj.c:   prj->w[3] = prj->w[2] + prj->p[1];
proj.c:   prj->prjfwd = codfwd;
proj.c:   prj->prjrev = codrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != COD) {
proj.c:   a = prj->w[0]*phi;
proj.c:   r = prj->w[3] - theta;
proj.c:   *y = prj->w[2] - r*cosdeg (a);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != COD) {
proj.c:   dy = prj->w[2] - y;
proj.c:   if (prj->p[1] < 0.0) r = -r;
proj.c:   *phi   = a*prj->w[1];
proj.c:   *theta = prj->w[3] - r;
proj.c:*      prj->p[1]    sigma = (theta2+theta1)/2
proj.c:*      prj->p[2]    delta = (theta2-theta1)/2, where theta1 and theta2 are the
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "COO"
proj.c:*      prj->flag    COO
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  sigma
proj.c:*      prj->w[0]    C = ln(cos(theta2)/cos(theta1))/ln(tan(tau2)/tan(tau1))
proj.c:*                       where tau1 = (90 - theta1)/2
proj.c:*                             tau2 = (90 - theta2)/2
proj.c:*      prj->w[1]    1/C
proj.c:*      prj->w[2]    Y0 = psi*tan((90-sigma)/2)**C
proj.c:*      prj->w[3]    psi = (r0*cos(theta1)/C)/tan(tau1)**C
proj.c:*      prj->w[4]    1/psi
proj.c:*      prj->prjfwd  Pointer to coofwd().
proj.c:*      prj->prjrev  Pointer to coorev().
proj.c:   strcpy(prj->code, "COO");
proj.c:   prj->flag   = COO;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = prj->p[1];
proj.c:   if (prj->r0 == 0.0) prj->r0 = R2D;
proj.c:   theta1 = prj->p[1] - prj->p[2];
proj.c:   theta2 = prj->p[1] + prj->p[2];
proj.c:   tan1 = tandeg ((90.0 - theta1)/2.0);
proj.c:      prj->w[0] = sindeg (theta1);
proj.c:      tan2 = tandeg ((90.0 - theta2)/2.0);
proj.c:      prj->w[0] = log(cos2/cos1)/log(tan2/tan1);
proj.c:   if (prj->w[0] == 0.0) {
proj.c:   prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->w[3] = prj->r0*(cos1/prj->w[0])/pow(tan1,prj->w[0]);
proj.c:   if (prj->w[3] == 0.0) {
proj.c:   prj->w[2] = prj->w[3]*pow(tandeg ((90.0 - prj->p[1])/2.0),prj->w[0]);
proj.c:   prj->w[4] = 1.0/prj->w[3];
proj.c:   prj->prjfwd = coofwd;
proj.c:   prj->prjrev = coorev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != COO) {
proj.c:   a = prj->w[0]*phi;
proj.c:   if (theta == -90.0) {
proj.c:      if (prj->w[0] < 0.0) {
proj.c:      r = prj->w[3]*pow(tandeg ((90.0 - theta)/2.0),prj->w[0]);
proj.c:   *y = prj->w[2] - r*cosdeg (a);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != COO) {
proj.c:   dy = prj->w[2] - y;
proj.c:   if (prj->p[1] < 0.0) r = -r;
proj.c:   *phi = a*prj->w[1];
proj.c:      if (prj->w[0] < 0.0) {
proj.c:         *theta = -90.0;
proj.c:      *theta = 90.0 - 2.0*atandeg (pow(r*prj->w[4],prj->w[1]));
proj.c:*      prj->p[1]    Bonne conformal latitude, theta1, in degrees.
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "BON"
proj.c:*      prj->flag    BON
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[1]    r0*pi/180
proj.c:*      prj->w[2]    Y0 = r0*(cot(theta1) + theta1*pi/180)
proj.c:*      prj->prjfwd  Pointer to bonfwd().
proj.c:*      prj->prjrev  Pointer to bonrev().
proj.c:   strcpy(prj->code, "BON");
proj.c:   prj->flag   = BON;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[1] = 1.0;
proj.c:      prj->w[2] = prj->r0*cosdeg (prj->p[1])/sindeg (prj->p[1]) + prj->p[1];
proj.c:      prj->w[1] = prj->r0*D2R;
proj.c:      prj->w[2] = prj->r0*(cosdeg (prj->p[1])/sindeg (prj->p[1]) + prj->p[1]*D2R);
proj.c:   prj->prjfwd = bonfwd;
proj.c:   prj->prjrev = bonrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->p[1] == 0.0) {
proj.c:      /* Sanson-Flamsteed. */
proj.c:   if (prj->flag != BON) {
proj.c:   r = prj->w[2] - theta*prj->w[1];
proj.c:   a = prj->r0*phi*cosdeg (theta)/r;
proj.c:   *y = prj->w[2] - r*cosdeg (a);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->p[1] == 0.0) {
proj.c:      /* Sanson-Flamsteed. */
proj.c:   if (prj->flag != BON) {
proj.c:   dy = prj->w[2] - y;
proj.c:   if (prj->p[1] < 0.0) r = -r;
proj.c:   *theta = (prj->w[2] - r)/prj->w[1];
proj.c:      *phi = a*(r/prj->r0)/cthe;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "PCO"
proj.c:*      prj->flag    PCO
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/180)
proj.c:*      prj->w[1]    1/r0
proj.c:*      prj->w[2]    2*r0
proj.c:*      prj->prjfwd  Pointer to pcofwd().
proj.c:*      prj->prjrev  Pointer to pcorev().
proj.c:   strcpy(prj->code, "PCO");
proj.c:   prj->flag   = PCO;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 1.0;
proj.c:      prj->w[1] = 1.0;
proj.c:      //prj->w[2] = 360.0/PI;
proj.c:      prj->w[2] = 360.0/WCS_PI;
proj.c:      prj->w[0] = prj->r0*D2R;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:      prj->w[2] = 2.0*prj->r0;
proj.c:   prj->prjfwd = pcofwd;
proj.c:   prj->prjrev = pcorev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != PCO) {
proj.c:      *x = prj->w[0]*phi;
proj.c:      *x = prj->r0*cotthe*sindeg (a);
proj.c:      *y = prj->r0*(cotthe*(1.0 - cosdeg (a)) + theta*D2R);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != PCO) {
proj.c:   w = fabs(y*prj->w[1]);
proj.c:      *phi = x*prj->w[1];
proj.c:   } else if (fabs(w-90.0) < tol) {
proj.c:         thepos = -90.0;
proj.c:      ymthe = y - prj->w[0]*thepos;
proj.c:      fneg = -999.0;
proj.c:         if (fneg < -100.0) {
proj.c:            lambda = fpos/(fpos-fneg);
proj.c:            *theta = thepos - lambda*(thepos-theneg);
proj.c:         ymthe = y - prj->w[0]*(*theta);
proj.c:         f = xx + ymthe*(ymthe - prj->w[2]/tanthe);
proj.c:         if (fabs(thepos-theneg) < tol) break;
proj.c:      xp = prj->r0 - ymthe*tanthe;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "TSC"
proj.c:*      prj->flag    TSC
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/4)
proj.c:*      prj->w[1]    (4/pi)/r0
proj.c:*      prj->prjfwd  Pointer to tscfwd().
proj.c:*      prj->prjrev  Pointer to tscrev().
proj.c:   strcpy(prj->code, "TSC");
proj.c:   prj->flag   = TSC;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 45.0;
proj.c:      prj->w[1] = 1.0/45.0;
proj.c:      //prj->w[0] = prj->r0*PI/4.0;
proj.c:			prj->w[0] = prj->r0*WCS_PI/4.0;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = tscfwd;
proj.c:   prj->prjrev = tscrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != TSC) {
proj.c:   if (-l > rho) {
proj.c:      rho  = -l;
proj.c:   if (-m > rho) {
proj.c:      rho  = -m;
proj.c:   if (-n > rho) {
proj.c:      rho  = -n;
proj.c:      yf = -l/rho;
proj.c:      xf = -l/rho;
proj.c:      xf = -m/rho;
proj.c:      y0 = -2.0;
proj.c:   *x = prj->w[0]*(xf + x0);
proj.c:   *y = prj->w[0]*(yf + y0);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   if (prj->flag != TSC) {
proj.c:   xf = x*prj->w[1];
proj.c:   yf = y*prj->w[1];
proj.c:   if (xf < -1.0) xf += 8.0;
proj.c:      xf = xf - 6.0;
proj.c:      m  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
proj.c:      l  = -m*xf;
proj.c:      n  = -m*yf;
proj.c:      xf = xf - 4.0;
proj.c:      l  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
proj.c:      n  = -l*yf;
proj.c:      xf = xf - 2.0;
proj.c:      l  = -m*xf;
proj.c:      yf = yf - 2.0;
proj.c:      l  = -n*yf;
proj.c:   } else if (yf < -1.0) {
proj.c:      n  = -1.0/sqrt(1.0 + xf*xf + yf*yf);
proj.c:      l  = -n*yf;
proj.c:      m  = -n*xf;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "CSC"
proj.c:*      prj->flag    CSC
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/4)
proj.c:*      prj->w[1]    (4/pi)/r0
proj.c:*      prj->prjfwd  Pointer to cscfwd().
proj.c:*      prj->prjrev  Pointer to cscrev().
proj.c:   strcpy(prj->code, "CSC");
proj.c:   prj->flag   = CSC;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 45.0;
proj.c:      prj->w[1] = 1.0/45.0;
proj.c:      //prj->w[0] = prj->r0*PI/4.0;
proj.c:			prj->w[0] = prj->r0*WCS_PI/4.0;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = cscfwd;
proj.c:   prj->prjrev = cscrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const float tol = 1.0e-7;
proj.c:   const float gamma  = -0.13161671474;
proj.c:   const float omega1 = -0.159596235474;
proj.c:   const float d1  = -0.0217762490699;
proj.c:   const float c01 = -0.281528535557;
proj.c:   const float c20 = -0.178251207466;
proj.c:   if (prj->flag != CSC) {
proj.c:   if (-l > rho) {
proj.c:      rho  = -l;
proj.c:   if (-m > rho) {
proj.c:      rho  = -m;
proj.c:   if (-n > rho) {
proj.c:      rho  = -n;
proj.c:      eta = -l;
proj.c:      xi  = -l;
proj.c:      xi  = -m;
proj.c:      y0  = -2.0;
proj.c:   ca2 = 1.0 - a2;
proj.c:   cb2 = 1.0 - b2;
proj.c:   a4   = (a2 > 1.0e-16) ? a2*a2 : 0.0;
proj.c:   b4   = (b2 > 1.0e-16) ? b2*b2 : 0.0;
proj.c:   a2b2 = (ab > 1.0e-16) ? a2*b2 : 0.0;
proj.c:          a2*(omega1 - ca2*(d0 + d1*a2))));
proj.c:          b2*(omega1 - cb2*(d0 + d1*b2))));
proj.c:   *x = prj->w[0]*(x0 + xf);
proj.c:   *y = prj->w[0]*(y0 + yf);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const float p00 = -0.27292696;
proj.c:   const float p10 = -0.07629969;
proj.c:   const float p20 = -0.22797056;
proj.c:   const float p40 = -0.62930065;
proj.c:   const float p01 = -0.02819452;
proj.c:   const float p11 = -0.01471565;
proj.c:   const float p31 = -1.74114454;
proj.c:   const float p51 = -0.53022337;
proj.c:   const float p12 = -0.56800938;
proj.c:   const float p42 = -0.83180469;
proj.c:   const float p03 = -0.60441560;
proj.c:   const float p23 = -0.93678576;
proj.c:   const float p14 = -1.41601920;
proj.c:   const float p05 = -0.63915306;
proj.c:   if (prj->flag != CSC) {
proj.c:   xf = x*prj->w[1];
proj.c:   yf = y*prj->w[1];
proj.c:   if (xf < -1.0) xf += 8.0;
proj.c:      xf = xf - 6.0;
proj.c:      xf = xf - 4.0;
proj.c:      xf = xf - 2.0;
proj.c:      yf = yf - 2.0;
proj.c:   } else if (yf < -1.0) {
proj.c:   a = xf + xf*(1.0 - xx)*a;
proj.c:   b = yf + yf*(1.0 - yy)*b;
proj.c:      l = -b*n;
proj.c:      l = -a*m;
proj.c:      l = -1.0/sqrt(a*a + b*b + 1.0);
proj.c:      n = -b*l;
proj.c:      m = -1.0/sqrt(a*a + b*b + 1.0);
proj.c:      l = -a*m;
proj.c:      n = -b*m;
proj.c:      n = -1.0/sqrt(a*a + b*b + 1.0);
proj.c:      l = -b*n;
proj.c:      m = -a*n;
proj.c:*      prj->r0      r0; reset to 180/pi if 0.
proj.c:*      prj->code    "QSC"
proj.c:*      prj->flag    QSC
proj.c:*      prj->phi0    0.0
proj.c:*      prj->theta0  0.0
proj.c:*      prj->w[0]    r0*(pi/4)
proj.c:*      prj->w[1]    (4/pi)/r0
proj.c:*      prj->prjfwd  Pointer to qscfwd().
proj.c:*      prj->prjrev  Pointer to qscrev().
proj.c:   strcpy(prj->code, "QSC");
proj.c:   prj->flag   = QSC;
proj.c:   prj->phi0   = 0.0;
proj.c:   prj->theta0 = 0.0;
proj.c:   if (prj->r0 == 0.0) {
proj.c:      prj->r0 = R2D;
proj.c:      prj->w[0] = 45.0;
proj.c:      prj->w[1] = 1.0/45.0;
proj.c:      //prj->w[0] = prj->r0*PI/4.0;
proj.c:      prj->w[0] = prj->r0*WCS_PI/4.0;
proj.c:      prj->w[1] = 1.0/prj->w[0];
proj.c:   prj->prjfwd = qscfwd;
proj.c:   prj->prjrev = qscrev;
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != QSC) {
proj.c:      *y = copysgn (2.0*prj->w[0],theta);
proj.c:   if (-l > rho) {
proj.c:      rho  = -l;
proj.c:   if (-m > rho) {
proj.c:      rho  = -m;
proj.c:   if (-n > rho) {
proj.c:      rho  = -n;
proj.c:   rhu = 1.0 - rho;
proj.c:      eta = -l;
proj.c:      if (rhu < 1.0e-8) {
proj.c:         t = (90.0 - theta)*D2R;
proj.c:      if (rhu < 1.0e-8) {
proj.c:         if (p < -180.0) p += 360.0;
proj.c:         if (p >  180.0) p -= 360.0;
proj.c:      xi  = -l;
proj.c:      if (rhu < 1.0e-8) {
proj.c:         if (p < -180.0) p += 360.0;
proj.c:         p = (90.0 - p)*D2R;
proj.c:      xi  = -m;
proj.c:      if (rhu < 1.0e-8) {
proj.c:         p = (180.0 - p)*D2R;
proj.c:      if (rhu < 1.0e-8) {
proj.c:         if (p > 180.0) p -= 360.0;
proj.c:      if (rhu < 1.0e-8) {
proj.c:      y0  = -2;
proj.c:   } else if (-xi >= fabs(eta)) {
proj.c:      xf  = -sqrt(rhu/(1.0-1.0/sqrt(1.0+tau)));
proj.c:      yf  = (xf/15.0)*(atandeg (omega) - asindeg (omega/sqrt(tau+tau)));
proj.c:      xf  =  sqrt(rhu/(1.0-1.0/sqrt(1.0+tau)));
proj.c:      yf  = (xf/15.0)*(atandeg (omega) - asindeg (omega/sqrt(tau+tau)));
proj.c:   } else if (-eta > fabs(xi)) {
proj.c:      yf  = -sqrt(rhu/(1.0-1.0/sqrt(1.0+tau)));
proj.c:      xf  = (yf/15.0)*(atandeg (omega) - asindeg (omega/sqrt(tau+tau)));
proj.c:      yf  =  sqrt(rhu/(1.0-1.0/sqrt(1.0+tau)));
proj.c:      xf  = (yf/15.0)*(atandeg (omega) - asindeg (omega/sqrt(tau+tau)));
proj.c:   *x = prj->w[0]*(xf + x0);
proj.c:   *y = prj->w[0]*(yf + y0);
proj.c:/*--------------------------------------------------------------------------*/
proj.c:   const double tol = 1.0e-12;
proj.c:   if (prj->flag != QSC) {
proj.c:   xf = x*prj->w[1];
proj.c:   yf = y*prj->w[1];
proj.c:   if (xf < -1.0) xf += 8.0;
proj.c:      xf = xf - 6.0;
proj.c:      xf = xf - 4.0;
proj.c:      xf = xf - 2.0;
proj.c:      yf = yf - 2.0;
proj.c:   } else if (yf < -1.0) {
proj.c:         omega = sindeg (w)/(cosdeg (w) - SQRT2INV);
proj.c:         rhu = xf*xf*(1.0 - 1.0/sqrt(1.0 + tau));
proj.c:         rho = 1.0 - rhu;
proj.c:         omega = sindeg (w)/(cosdeg (w) - SQRT2INV);
proj.c:         rhu = yf*yf*(1.0 - 1.0/sqrt(1.0 + tau));
proj.c:         rho = 1.0 - rhu;
proj.c:   if (rho < -1.0) {
proj.c:      if (rho < -1.0-tol) {
proj.c:      rho = -1.0;
proj.c:      w = sqrt(rhu*(2.0-rhu)/tau);
proj.c:         if (xf < 0.0) m = -m;
proj.c:         l = -m*omega;
proj.c:         if (yf > 0.0) l = -l;
proj.c:         m = -l*omega;
proj.c:         if (xf < 0.0) m = -m;
proj.c:         if (yf < 0.0) n = -n;
proj.c:         if (xf > 0.0) l = -l;
proj.c:         n = -l*omega;
proj.c:         if (yf < 0.0) n = -n;
proj.c:         l = -n*omega;
proj.c:      l = -rho;
proj.c:         if (xf > 0.0) m = -m;
proj.c:         n = -m*omega;
proj.c:         if (yf < 0.0) n = -n;
proj.c:         m = -n*omega;
proj.c:      m = -rho;
proj.c:         if (xf < 0.0) l = -l;
proj.c:         if (yf < 0.0) n = -n;
proj.c:      n = -rho;
proj.c:         if (xf < 0.0) m = -m;
proj.c:         if (yf < 0.0) l = -l;
proj.c:/* This routine comes from E. Bertin  sextractor-2.8.6 */
proj.c:   k=prj->npv;
proj.c:   a = prj->ppv+MAXPV;		/* Latitude comes first for compatibility */
proj.c:   b = prj->ppv;			/* Longitude */
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:   if (!--k) goto poly_end;
proj.c:/* Dec 20 1999  Doug Mink - Change cosd() and sind() to cosdeg() and sindeg()
proj.c: * Dec 20 1999  Doug Mink - Include wcslib.h, which includes proj.h, wcsmath.h
proj.c: * Dec 20 1999  Doug Mink - Define copysign only if it is not defined
proj.c: * Dec 20 1999  Doug Mink - tanfwd() returns error if s<=0.0, not only if s==0.0
proj.c: * Jun  2 2000  Doug Mink - include stdlib.h to get abs()
proj.c: * Feb 15 2001  Doug Mink - update zearev() for WCSLIB 2.6
proj.c: * Sep 19 2001  Doug Mink - Make above changes for WCSLIB 2.7
proj.c: * Mar 15 2002	Doug Mink - Make above changes for WCSLIB 2.8.2
proj.c: * Feb  3 2003	Doug Mink - Use locally defined copysgn() and copysgni(),
proj.c: * Apr  1 2003	Doug Mink - include string.h for strcpy() and strcmp()
proj.c: * Mar 14 2011	Doug Mink - If no coefficients in ZPN, make ARC
proj.c: * Mar 14 2011	Doug Mink - Add Emmanuel Bertin's TAN polynomial from Ed Los
Readme:    http://tdc-www.harvard.edu/software/wcstools/
Readme:A self-contained subset of these programs which deal with image world
sdssread.c: *** Harvard-Smithsonian Center for Astrophysics
sdssread.c: *** Copyright (C) 2004-2013
sdssread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
sdssread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
sdssread.c:/* SDSSREAD -- Read Sloan Digital Sky Survey catalog stars over the web */
sdssread.c:double	ddec;		/* Search half-width in declination in degrees */
sdssread.c:double	**gmag;		/* 2-D array of magnitudes (returned) */
sdssread.c:	nlog = -1;
sdssread.c:	cmag = sdssmag[sortmag - 1];
sdssread.c:    if (tabtable->tabdata == NULL || strlen (tabtable->tabdata) == 0 ||
sdssread.c:	!strncasecmp (tabtable->tabdata, "[EOD]", 5)) {
sdssread.c:	(void) fwrite  (tabtable->tabbuff, tabtable->lbuff, 1, stdout);
sdssread.c:    starcat->coorsys = WCS_J2000;
sdssread.c:    starcat->epoch = 2000.0;
sdssread.c:    starcat->equinox = 2000.0;
sdssread.c:    starcat->nmag = 5;
sdssread.c:    char *csvbuff;	/* Input comma-separated table */
sdssread.c:    char colsep[180]="------------------	---	-----	------	-----	---	----	----------	---------	------	------	------	------	------	--------	------	--------	--------	-------\n";
sdssread.c:    char *tabbuff;	/* Output tab-separated table */
sdssread.c:    if (lastbuff - databuff < lbuff)
sdssread.c:    /* Allocate buffer for tab-separated table with header */
sdssread.c: * Oct 30 2006	Print URL in verbose mode when printing web-returned sources
shrink.c: * By Jessica Mink, Harvard-Smithsonian Center for Astrophysics
shrink.c:	bytesin = -bytesin;
shrink.c:    else if (bitpix == -32) {
shrink.c:    else if (bitpix == -64) {
shrink.c:		nyf = ny - ky + 1;
shrink.c:		    nxf = nx - kx + 1;
shrink.c:		    pixfal = pixval - floor;
shrink.c:		    case -32:
shrink.c:		    case -64:
shrink.c:		    case -32:
shrink.c:		    case -64:
skybotread.c: *** Harvard-Smithsonian Center for Astrophysics
skybotread.c: *** Copyright (C) 2004-2009
skybotread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
skybotread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
skybotread.c:/* skybotread -- Read IMCCE SkyBot server astroids over the web */
skybotread.c:double	ddec;		/* Search half-width in declination in degrees */
skybotread.c:double	**gmag;		/* 2-D array of magnitudes and other info (returned) */
skybotread.c:	nlog = -1;
skybotread.c:    sprintf (srchurl, "?-ep=%.5f&", jdout);
skybotread.c:    sprintf (temp, "-ra=%.5f&-dec=%.5f&", ra, dec);
skybotread.c:	    dradx = -drad * sqrt (2.0);
skybotread.c:	    sprintf (temp, "-rd=%.5f&", dradx);
skybotread.c:	    sprintf (tstr, "dra\t%.5f\n", -drad);
skybotread.c:	    sprintf (tstr, "ddec\t%.5f\n", -drad);
skybotread.c:	    sprintf (temp, "-rd=%.5f&", dradx);
skybotread.c:	sprintf (temp, "-rd=%.5f&", dradx);
skybotread.c:    strcat (srchurl, "-mime=text&");
skybotread.c:    strcat (srchurl, "-objFilter=110&");
skybotread.c:    strcat (srchurl, "-objFilter=100&"); */
skybotread.c:    strcat (srchurl, "-from=WCSTools");
skybotread.c:    if (tabtable->tabdata == NULL || strlen (tabtable->tabdata) == 0 ||
skybotread.c:	!strncasecmp (tabtable->tabdata, "[EOD]", 5)) {
skybotread.c:	(void) fwrite  (tabtable->tabbuff, tabtable->lbuff, 1, stdout);
skybotread.c:    starcat->coorsys = WCS_J2000;
skybotread.c:    starcat->epoch = 2000.0;
skybotread.c:    starcat->equinox = 2000.0;
skybotread.c:    starcat->nmag = 3;
skybotread.c:    char *skybuff;	/* Input comma-separated table */
skybotread.c:    char *tabbuff;	/* Output tab-separated table */
skybotread.c:    char cminus = '-';
skybotread.c:	    colsep[i] = '-';
skybotread.c:	    lobj = tbuff - tbuffi;
skybotread.c:		colend = strchr (dbuff, cbar) - 1;
skybotread.c:		lra = colend - dbuff;
skybotread.c:		sprintf (format,"%%%d.%df",lra,lra-4);
skybotread.c:		dbuff--;
skybotread.c:		    dbuff--;
skybotread.c: * May  5 2009	Add -objFilter=110 to drop comets (someday, this might be optional)
sortstar.c: *** Harvard-Smithsonian Center for Astrophysics
sortstar.c: *** Copyright (C) 1996-2009
sortstar.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
sortstar.c:    int    c;		/* Other 4-byte information */
sortstar.c:/* StarFluxSort -- Order stars in decreasing flux called by qsort */
sortstar.c:    double b1 = ((StarInfo *)ssp1)->b;
sortstar.c:    double b2 = ((StarInfo *)ssp2)->b;
sortstar.c:	return (-1);
sortstar.c:/* MagSortStars -- Sort image stars by increasing magnitude */
sortstar.c:int    *sc;		/* Other 4-byte information */
sortstar.c:	magsort = ms - 1;
sortstar.c:/* StarMagSort -- Order stars in decreasing flux called by qsort */
sortstar.c:    double b1 = ((StarInfo *)ssp1)->m[magsort];
sortstar.c:    double b2 = ((StarInfo *)ssp2)->m[magsort];
sortstar.c:	b1 = b1 - 100.0;
sortstar.c:	b1 = ((StarInfo *)ssp1)->m[0];
sortstar.c:	b1 = ((StarInfo *)ssp1)->m[1];
sortstar.c:	b1 = ((StarInfo *)ssp1)->m[2];
sortstar.c:	b1 = ((StarInfo *)ssp1)->m[3];
sortstar.c:	b2 = b2 - 100.0;
sortstar.c:	b2 = ((StarInfo *)ssp2)->m[0];
sortstar.c:	b2 = ((StarInfo *)ssp2)->m[1];
sortstar.c:	b2 = ((StarInfo *)ssp2)->m[2];
sortstar.c:	b2 = ((StarInfo *)ssp2)->m[3];
sortstar.c:	return (-1);
sortstar.c:/* IDSortStars -- Sort image stars by increasing ID Number value */
sortstar.c:int    *sc;		/* Other 4-byte information */
sortstar.c:/* StarIDSort -- Order stars in increasing ID value called by qsort */
sortstar.c:    double n1 = ((StarInfo *)ssp1)->n;
sortstar.c:    double n2 = ((StarInfo *)ssp2)->n;
sortstar.c:	return (-1);
sortstar.c:int    *sc;		/* Other 4-byte information */
sortstar.c:    double ra1 = ((StarInfo *)ssp1)->ra;
sortstar.c:    double ra2 = ((StarInfo *)ssp2)->ra;
sortstar.c:	return (-1);
sortstar.c:int    *sc;		/* Other 4-byte information */
sortstar.c:    double dec1 = ((StarInfo *)ssp1)->dec;
sortstar.c:    double dec2 = ((StarInfo *)ssp2)->dec;
sortstar.c:	return (-1);
sortstar.c:/* XSortStars -- Sort image stars by increasing X value */
sortstar.c:int    *sc;		/* Other 4-byte information */
sortstar.c:/* StarXSort -- Order stars in decreasing X value called by qsort */
sortstar.c:    double x1 = ((StarInfo *)ssp1)->x;
sortstar.c:    double x2 = ((StarInfo *)ssp2)->x;
sortstar.c:	return (-1);
sortstar.c:/* YSortStars -- Sort image stars by increasing Y value */
sortstar.c:int    *sc;		/* Other 4-byte information */
sortstar.c:/* StarYSort -- Order stars in decreasing Y value called by qsort */
sortstar.c:    double y1 = ((StarInfo *)ssp1)->y;
sortstar.c:    double y2 = ((StarInfo *)ssp2)->y;
sortstar.c:	return (-1);
sortstar.c:/* MergeStars -- Merge multiple entries within given radius */
sortstar.c:int    *sc;		/* Other 4-byte information */
sortstar.c:    /* Merge RA-sorted catalogued stars within drad arcseconds of each other */
sortstar.c:    /* Re-sort stars by right ascension */
sortstar.c:/* StarMerge -- Merge stars, called by MergeStars() */
sortstar.c:	if (stars[is].y == -999.0)
sortstar.c:	    dsec = (stars[js].ra - stars[is].ra) * 3600.0;
sortstar.c:	    if (is != js && stars[js].y != -999.0) {
sortstar.c:	for (js = is; js > 0; js--) {
sortstar.c:	    dsec = (stars[is].ra - stars[js].ra) * 3600.0;
sortstar.c:	    if (is != js && stars[js].y != -999.0) {
sortstar.c:	    dsec = (stars[js].ra - rai) * 3600.0;
sortstar.c:	    if (stars[js].y != -999.0) {
sortstar.c:		    stars[js].y = -999.0;
sortstar.c:	for (js = is; js > -1; js--) {
sortstar.c:	    dsec = (rai - stars[js].ra) * 3600.0;
sortstar.c:	    if (stars[js].y != -999.0) {
sortstar.c:		    stars[js].y = -999.0;
sortstar.c: * Nov 20 1998	Add USNO A-2.0 catalog and return different code
sortstar.c: * Mar 17 2004	RA-sort before and after merging catalog in MergeStars()
sortstar.c: * Mar 17 2004	Rewrite StarMerge() to merge RA-sorted catalog quickly
sph.c:*   WCSLIB - an implementation of the FITS WCS proposal.
sph.c:*   Copyright (C) 1995-2002, Mark Calabretta
sph.c:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
sph.c:*   -------------------
sph.c:*   --------------------------------
sph.c:*   --------------------------------
sph.c:const double tol = 1.0e-5;
sph.c:   dlng = lng - eul[0];
sph.c:   x = sinlat*eul[4] - coslat*eul[3]*coslng;
sph.c:      x = -cosdeg (lat+eul[1]) + coslat*eul[3]*(1.0 - coslng);
sph.c:   y = -coslat*sinlng;
sph.c:      dphi = dlng - 180.0;
sph.c:      *phi -= 360.0;
sph.c:   } else if (*phi < -180.0) {
sph.c:      if (*theta >  90.0) *theta =  180.0 - *theta;
sph.c:      if (*theta < -90.0) *theta = -180.0 - *theta;
sph.c:           *theta = -acosdeg (sqrt(x*x+y*y));
sph.c:/*-----------------------------------------------------------------------*/
sph.c:   dphi = phi - eul[2];
sph.c:   x = sinthe*eul[4] - costhe*eul[3]*cosphi;
sph.c:      x = -cosdeg (theta+eul[1]) + costhe*eul[3]*(1.0 - cosphi);
sph.c:   y = -costhe*sinphi;
sph.c:      if (*lng > 0.0) *lng -= 360.0;
sph.c:      *lng -= 360.0;
sph.c:   } else if (*lng < -360.0) {
sph.c:      if (*lat >  90.0) *lat =  180.0 - *lat;
sph.c:      if (*lat < -90.0) *lat = -180.0 - *lat;
sph.c:            *lat = -acosdeg (sqrt(x*x+y*y));
sph.c:/* Dec 20 1999	Doug Mink - Change cosd() and sind() to cosdeg() and sindeg()
sph.c: * Dec 20 1999	Doug Mink - Include wcslib.h, which includes wcstrig.h, sph.h
sph.c: * Dec 20 1999	Doug Mink - Define copysign only if it is not already defined
sph.c: * Jan  5 2000	Doug Mink - Drop copysign
sph.c: * Sep 19 2001	Doug Mink - No change for WCSLIB 2.7
str2ang.c:    /* Translate value from ASCII colon-delimited string to binary */
str2ang.c:	if (*value == '-') {
str2ang.c:	    sign = -1.0;
str2ang.c:	while (value[lval-1] == ' ')
str2ang.c:	    lval--;
str2dcpp.c:    case '-': negative = 1; // Fall through to increment position
str2dcpp.c:    number = number * 10. + (*p - '0');
str2dcpp.c:      number = number * 10. + (*p - '0');
str2dcpp.c:    exponent -= num_decimals;
str2dcpp.c:  if (negative) number = -number;
str2dcpp.c:      case '-': negative = 1;   // Fall through to increment pos
str2dcpp.c:      n = n * 10 + (*p - '0');
str2dcpp.c:      exponent -= n;
str2dcpp.c:  if (n < 0) n = -n;
str2dsun.c: * strtod.c --
str2dsun.c: * Copyright (c) 1988-1993 The Regents of the University of California.
str2dsun.c:    100.,			/* exponents into floating-point numbers. */
str2dsun.c: *----------------------------------------------------------------------
str2dsun.c: * strtod --
str2dsun.c: *	This procedure converts a floating-point number from an ASCII
str2dsun.c: *	decimal representation to internal double-precision format.
str2dsun.c: *	The return value is the double-precision floating-point
str2dsun.c: *	floating-point number.
str2dsun.c: *----------------------------------------------------------------------
str2dsun.c:    CONST char *string,		/* A decimal ASCII floating-point number,
str2dsun.c:				 * have form "-I.FE-X", where I is the integer
str2dsun.c:				 * "-", or omitted. Either I or F may be
str2dsun.c:    char **endPtr)		/* If non-NULL, store terminating character's
str2dsun.c:    if (*p == '-') {
str2dsun.c:    decPt = -1;
str2dsun.c:     * digits each (this is faster than using floating-point). If the mantissa
str2dsun.c:    p -= mantSize;
str2dsun.c:	mantSize -= 1;		/* One of the digits was the point. */
str2dsun.c:	fracExp = decPt - 18;
str2dsun.c:	fracExp = decPt - mantSize;
str2dsun.c:	for ( ; mantSize > 9; mantSize -= 1) {
str2dsun.c:	    frac1 = 10*frac1 + (c - '0');
str2dsun.c:	for (; mantSize > 0; mantSize -= 1) {
str2dsun.c:	    frac2 = 10*frac2 + (c - '0');
str2dsun.c:	if (*p == '-') {
str2dsun.c:	    exp = exp * 10 + (*p - '0');
str2dsun.c:	exp = fracExp - exp;
str2dsun.c:     * Generate a floating-point number that represents the exponent. Do this
str2dsun.c:	exp = -exp;
str2dsun.c:	return -fraction;
tabread.c: *** Harvard-Smithsonian Center for Astrophysics
tabread.c: *** Copyright (C) 1996-2014
tabread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
tabread.c: * double tabgetr8()	Return 8-byte floating point number from tab table line
tabread.c: * int tabgeti4()	Return 4-byte integer from tab table line
tabread.c: * int tabhgetr8()	Return 8-byte floating point keyword value from header
tabread.c: * int tabhgeti4()	Return 4-byte integer keyword value from header
tabread.c: * int tabcol()		Find entry in a table of column headings (case-dependent)
tabread.c: * int tabccol()	Find entry in a table of column headings (case-independent)
tabread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
tabread.c:/* TABREAD -- Read tab table stars in specified region */
tabread.c:double	ddec;		/* Search half-width in declination in degrees */
tabread.c:double	**tmag;		/* 2-D Array of magnitudes (returned) */
tabread.c:    if (sc == NULL || sc->nstars <= 0) {
tabread.c:    nstars = sc->nstars;
tabread.c:    if (sortmag > 0 && sortmag <= sc->nmag)
tabread.c:	magsort = sortmag - 1;
tabread.c:    if (sc->equinox != 0.0)
tabread.c:	eqref = sc->equinox;
tabread.c:    if (sc->epoch != 0.0)
tabread.c:	epref = sc->epoch;
tabread.c:    if (sc->coorsys)
tabread.c:	sysref = sc->coorsys;
tabread.c:    if (sc->mprop > 0)
tabread.c:	if (sc->nmag > 0) {
tabread.c:	    magt = star->xmag[magsort];
tabread.c:		while (magt == 99.90 && imag < sc->nmag)
tabread.c:		    magt = star->xmag[imag++];
tabread.c:		    magt = magt - 100.0;
tabread.c:	ra = star->ra;
tabread.c:	dec = star->dec;
tabread.c:	    sysref = star->coorsys;
tabread.c:	    eqref = star->equinox;
tabread.c:	    epref = star->epoch;
tabread.c:	    num = star->num;
tabread.c:	    rapm = star->rapm;
tabread.c:	    decpm = star->decpm;
tabread.c:	    parallax = star->parallax;
tabread.c:	    rv = star->radvel;
tabread.c:	    if (sc->entpx || sc->entrv)
tabread.c:	    else if (sc->mprop == 1)
tabread.c:	    if (sc->sptype)
tabread.c:		peak = (1000 * (int) star->isp[0]) + (int)star->isp[1];
tabread.c:		peak = star->peak;
tabread.c:		if (sc->mprop == 1) {
tabread.c:		for (imag = 0; imag < sc->nmag; imag++) {
tabread.c:			tmag[imag][nstar] = star->xmag[imag];
tabread.c:		lname = strlen (star->objname);
tabread.c:		    strcpy (objname, star->objname);
tabread.c:		if (sc->nmag > 0 && magt > faintmag) {
tabread.c:		    if (sc->mprop == 1) {
tabread.c:		    for (imag = 0; imag < sc->nmag; imag++) {
tabread.c:			    tmag[imag][farstar] = star->xmag[imag];
tabread.c:		    lname = strlen (star->objname);
tabread.c:			strcpy (objname, star->objname);
tabread.c:	    else if (sc->nmag > 0 && magt < faintmag) {
tabread.c:		if (sc->mprop == 1) {
tabread.c:		for (imag = 0; imag < sc->nmag; imag++) {
tabread.c:			tmag[imag][faintstar] = star->xmag[imag];
tabread.c:		lname = strlen (star->objname);
tabread.c:		    strcpy (objname, star->objname);
tabread.c:		    while (magt == 99.90 && imag < sc->nmag)
tabread.c:			magt = magt - 100.0;
tabread.c:/* TABRNUM -- Read tab table stars with specified numbers */
tabread.c:double	**tmag;		/* 2-D array of magnitudes (returned) */
tabread.c:    if (sc == NULL || sc->nstars <= 0) {
tabread.c:    startab = sc->startab;
tabread.c:    nstars = sc->nstars;
tabread.c:    if (sc->equinox != 0.0)
tabread.c:	eqref = sc->equinox;
tabread.c:    if (sc->epoch != 0.0)
tabread.c:	epref = sc->epoch;
tabread.c:    if (sc->coorsys)
tabread.c:	sysref = sc->coorsys;
tabread.c:	if (sc->nnfld > 0)
tabread.c:	    nnfld = sc->nnfld;
tabread.c:	    nnfld = CatNumLen (TABCAT, tnum[nnum-1], sc->nndec);
tabread.c:	for (i = 1; i < sc->nmag+1; i++) {
tabread.c:	    if (i == sc->nmag && sc->entepoch)
tabread.c:		printf ("	%s", sc->keymag[i-1]);
tabread.c:	printf ("-----	------------	------------");
tabread.c:	for (i = 1; i < sc->nmag+1; i++) {
tabread.c:	    if (i == sc->nmag && sc->entepoch)
tabread.c:		printf ("	--------");
tabread.c:		printf ("	-----");
tabread.c:	    printf ("	---------\n");
tabread.c:    star->num = 0.0;
tabread.c:    line = startab->tabdata;
tabread.c:	    if (!strcmp (sc->isfil,"gsc-server")) {
tabread.c:   		if (tabgetc (&startok, sc->entid, str, 24))
tabread.c:		    inum = (int) (((num - (double)ireg) * 100000.0) + 0.5);
tabread.c:		num = tabgetr8 (&startok,sc->entid);
tabread.c:	    sc->istar = startab->iline;
tabread.c:		sysref = star->coorsys;
tabread.c:		eqref = star->equinox;
tabread.c:		num = star->num;
tabread.c:		ra = star->ra;
tabread.c:		dec = star->dec;
tabread.c:		rapm = star->rapm;
tabread.c:		decpm = star->decpm;
tabread.c:		parallax = star->parallax;
tabread.c:		rv = star->radvel;
tabread.c:		if (sc->entrv > 0)
tabread.c:		    star->xmag[sc->nmag-1] = rv;
tabread.c:		if (sc->entpx || sc->entrv)
tabread.c:		else if (sc->mprop == 1)
tabread.c:		if (sc->nmag > 0)
tabread.c:		    mag = star->xmag[0];
tabread.c:		if (sc->sptype)
tabread.c:		    peak = (1000 * (int) star->isp[0]) + (int)star->isp[1];
tabread.c:		    peak = star->peak;
tabread.c:		    CatNum (TABCAT, -nnfld, sc->nndec, num, numstr);
tabread.c:		    for (imag = 0; imag < sc->nmag; imag++)
tabread.c:			if (imag == sc->nmag-1 && sc->entepoch) {
tabread.c:			    datestring = DateString (star->xmag[imag], 1);
tabread.c:			    printf ("	%.2f", star->xmag[imag]);
tabread.c:			printf ("	%s\n", star->objname);
tabread.c:		if (sc->mprop == 1) {
tabread.c:		for (imag = 0; imag < sc->nmag; imag++) {
tabread.c:			tmag[imag][jnum] = star->xmag[imag];
tabread.c:		lname = strlen (star->objname);
tabread.c:		    strcpy (objname, star->objname);
tabread.c:		CatNum (TABCAT, -nnfld, sc->nndec, tnum[jnum], numstr);
tabread.c:		for (imag = 0; imag < sc->nmag; imag++)
tabread.c:/* TABBIN -- Bin tab table stars in specified region into an image */
tabread.c:    double ddec;	/* Search half-width in declination in degrees */
tabread.c:    sysout = wcs->syswcs;
tabread.c:    eqout = wcs->equinox;
tabread.c:    epout = wcs->epoch;
tabread.c:    if (sc == NULL || sc->nstars <= 0) {
tabread.c:    nstars = sc->nstars;
tabread.c:    if (sortmag > 0 && sortmag <= sc->nmag)
tabread.c:	magsort = sortmag - 1;
tabread.c:    if (sc->equinox != 0.0)
tabread.c:	eqref = sc->equinox;
tabread.c:    if (sc->epoch != 0.0)
tabread.c:	epref = sc->epoch;
tabread.c:    if (sc->coorsys)
tabread.c:	sysref = sc->coorsys;
tabread.c:    if (sc->mprop > 0)
tabread.c:	if (sc->nmag > 0) {
tabread.c:	    magt = star->xmag[magsort];
tabread.c:	    while (magt == 99.90 && imag < sc->nmag)
tabread.c:		magt = star->xmag[imag++];
tabread.c:		magt = magt - 100.0;
tabread.c:	ra = star->ra;
tabread.c:	dec = star->dec;
tabread.c:	    sysref = star->coorsys;
tabread.c:	    eqref = star->equinox;
tabread.c:	    epref = star->epoch;
tabread.c:	    num = star->num;
tabread.c:	    rapm = star->rapm;
tabread.c:	    decpm = star->decpm;
tabread.c:	    parallax = star->parallax;
tabread.c:	    rv = star->radvel;
tabread.c:	    if (sc->entpx || sc->entrv)
tabread.c:	    else if (sc->mprop == 1)
tabread.c:	    if (sc->sptype)
tabread.c:		peak = (1000 * (int) star->isp[0]) + (int)star->isp[1];
tabread.c:		peak = star->peak;
tabread.c:		    flux = magscale * exp (logt * (-magt / 2.5));
tabread.c:/* TABXYREAD -- Read X, Y, and magnitude of tab table stars */
tabread.c:    if (startab == NULL || startab->nlines <= 0) {
tabread.c:    nstars = startab->nlines;
tabread.c:	flux = 1000000000.0 * pow (10.0, (-magi / 2.5));
tabread.c:    if (istar < nstars-1)
tabread.c:/* TABRKEY -- Read single keyword from tab table stars with specified numbers */
tabread.c:    if (sc == NULL || sc->nstars <= 0) {
tabread.c:    startab = sc->startab;
tabread.c:    if (startab == NULL || startab->nlines <= 0) {
tabread.c:    nstars = startab->nlines;
tabread.c:	    if ((num = tabgetr8 (&startok,sc->entid)) == 0.0)
tabread.c:/* TABCATOPEN -- Open tab table catalog, returning number of entries */
tabread.c:    sc->startab = startab;
tabread.c:	strcpy (sc->isfil, tabname);
tabread.c:	strncpy (sc->isfil, tabname, 23);
tabread.c:	sc->isfil[23] = (char) 0;
tabread.c:    sc->entid = -1;
tabread.c:    sc->keyid[0] = (char) 0;
tabread.c:    if ((sc->entid = tabccol (startab, "id"))) {
tabread.c:	i = sc->entid - 1;
tabread.c:	strncpy (sc->keyid, startab->colname[i], startab->lcol[i]);
tabread.c:    else if ((sc->entid = tabccont (startab, "_id"))) {
tabread.c:	i = sc->entid - 1;
tabread.c:	strncpy (sc->keyid, startab->colname[i], startab->lcol[i]);
tabread.c:    else if ((sc->entid = tabccont (startab, "id"))) {
tabread.c:	i = sc->entid - 1;
tabread.c:	strncpy (sc->keyid, startab->colname[i], startab->lcol[i]);
tabread.c:    else if ((sc->entid = tabccont (startab, "num"))) {
tabread.c:	i = sc->entid - 1;
tabread.c:	strncpy (sc->keyid, startab->colname[i], startab->lcol[i]);
tabread.c:    else if ((sc->entid = tabccont (startab, "name"))) {
tabread.c:	i = sc->entid - 1;
tabread.c:	strncpy (sc->keyid, startab->colname[i], startab->lcol[i]);
tabread.c:    else if ((sc->entid = tabccont (startab, "obj"))) {
tabread.c:	i = sc->entid - 1;
tabread.c:	strncpy (sc->keyid, startab->colname[i], startab->lcol[i]);
tabread.c:    sc->nndec = nndec;
tabread.c:	    sc->coorsys = WCS_GALACTIC;
tabread.c:	    sc->coorsys = WCS_ECLIPTIC;
tabread.c:	    sc->coorsys = WCS_B1950;
tabread.c:	    sc->coorsys = WCS_J2000;
tabread.c:	sc->coorsys = WCS_J2000;
tabread.c:    sc->entra = -1;
tabread.c:    sc->keyra[0] = (char) 0;
tabread.c:    if (sc->coorsys == WCS_GALACTIC) {
tabread.c:	if ((sc->entra = tabccol (startab, "long_gal")))
tabread.c:	    strcpy (sc->keyra, "long_gal");
tabread.c:	else if ((sc->entra = tabccol (startab, "long")))
tabread.c:	    strcpy (sc->keyra, "long_gal");
tabread.c:	else if ((sc->entra = tabccont (startab, "long"))) {
tabread.c:	    i = sc->entra - 1;
tabread.c:	    strncpy (sc->keyra, startab->colname[i], startab->lcol[i]);
tabread.c:    else if (sc->coorsys == WCS_ECLIPTIC) {
tabread.c:	if ((sc->entra = tabccol (startab, "long_ecl")))
tabread.c:	    strcpy (sc->keyra, "long_ecl");
tabread.c:	else if ((sc->entra = tabccol (startab, "long")))
tabread.c:	    strcpy (sc->keyra, "long_ecl");
tabread.c:	else if ((sc->entra = tabccont (startab, "long"))) {
tabread.c:	    i = sc->entra - 1;
tabread.c:	    strncpy (sc->keyra, startab->colname[i], startab->lcol[i]);
tabread.c:	if ((sc->entra = tabccol (startab, "ra"))) {
tabread.c:	    i = sc->entra - 1;
tabread.c:	    strncpy (sc->keyra, startab->colname[i], startab->lcol[i]);
tabread.c:	else if ((sc->entra = tabccont (startab, "ra"))) {
tabread.c:	    i = sc->entra - 1;
tabread.c:	    strncpy (sc->keyra, startab->colname[i], startab->lcol[i]);
tabread.c:    sc->entdec = -1;
tabread.c:    sc->keydec[0] = (char) 0;
tabread.c:    if (sc->coorsys == WCS_GALACTIC) {
tabread.c:	if ((sc->entdec = tabccol (startab, "lat_gal")))
tabread.c:	    strcpy (sc->keydec, "lat_gal");
tabread.c:	else if ((sc->entdec = tabccol (startab, "lat")))
tabread.c:	    strcpy (sc->keydec, "lat_gal");
tabread.c:	else if ((sc->entdec = tabccont (startab, "lat"))) {
tabread.c:	    i = sc->entdec - 1;
tabread.c:	    strncpy (sc->keydec, startab->colname[i], startab->lcol[i]);
tabread.c:    else if (sc->coorsys == WCS_ECLIPTIC) {
tabread.c:	if ((sc->entdec = tabccol (startab, "lat_ecl")))
tabread.c:	    strcpy (sc->keydec, "lat_ecl");
tabread.c:	else if ((sc->entdec = tabccol (startab, "lat")))
tabread.c:	    strcpy (sc->keydec, "lat_ecl");
tabread.c:	else if ((sc->entdec = tabccont (startab, "lat"))) {
tabread.c:	    i = sc->entdec - 1;
tabread.c:	    strncpy (sc->keydec, startab->colname[i], startab->lcol[i]);
tabread.c:	if ((sc->entdec = tabccol (startab, "de(deg)"))) {
tabread.c:	    i = sc->entdec - 1;
tabread.c:	    strcpy (sc->keydec, "dec");
tabread.c:	else if ((sc->entdec = tabccol (startab, "dec"))) {
tabread.c:	    i = sc->entdec - 1;
tabread.c:	    strncpy (sc->keydec, startab->colname[i], startab->lcol[i]);
tabread.c:	else if ((sc->entdec = tabccont (startab, "dec"))) {
tabread.c:	    i = sc->entdec - 1;
tabread.c:	    strncpy (sc->keydec, startab->colname[i], startab->lcol[i]);
tabread.c:    sc->nmag = 0;
tabread.c:    for (i = 0; i < startab->ncols; i++) {
tabread.c:	if (icol == sc->entid) continue;
tabread.c:	if (icol == sc->entra) continue;
tabread.c:	if (icol == sc->entdec) continue;
tabread.c:	if (startab->lcol[i] < 16)
tabread.c:	    strncpy (keyword, startab->colname[i], startab->lcol[i]);
tabread.c:	    strncpy (keyword, startab->colname[i], 15);
tabread.c:	    strcpy (sc->keymag[sc->nmag], keyword);
tabread.c:	    sc->entmag[sc->nmag] = icol;
tabread.c:	    sc->nmag++;
tabread.c:	    strcpy (sc->keymag[sc->nmag], keyword);
tabread.c:	    sc->entmag[sc->nmag] = icol;
tabread.c:	    sc->nmag++;
tabread.c:	    strcpy (sc->keymag[sc->nmag], keyword);
tabread.c:	    sc->entmag[sc->nmag] = icol;
tabread.c:	    sc->nmag++;
tabread.c:	    strcpy (sc->keymag[sc->nmag], keyword);
tabread.c:	    sc->entmag[sc->nmag] = icol;
tabread.c:	    sc->nmag++;
tabread.c:    sc->entrpm = -1;
tabread.c:    sc->keyrpm[0] = (char) 0;
tabread.c:    if ((sc->entrpm = tabccol (startab, "ura")))
tabread.c:	strcpy (sc->keyrpm, "ura");
tabread.c:    else if ((sc->entrpm = tabccol (startab, "rapm")))
tabread.c:	strcpy (sc->keyrpm, "rapm");
tabread.c:    else if ((sc->entrpm = tabccol (startab, "pmra")))
tabread.c:	strcpy (sc->keyrpm, "pmra");
tabread.c:    else if ((sc->entrpm = tabccol (startab, "dra")))
tabread.c:	strcpy (sc->keyrpm, "dra");
tabread.c:    else if ((sc->entrpm = tabccol (startab, "ux")))
tabread.c:	strcpy (sc->keyrpm, "ux");
tabread.c:    sc->entdpm = -1;
tabread.c:    sc->keydpm[0] = (char) 0;
tabread.c:    if ((sc->entdpm = tabccol (startab, "udec")))
tabread.c:	strcpy (sc->keydpm, "udec");
tabread.c:    else if ((sc->entdpm = tabccol (startab, "decpm")))
tabread.c:	strcpy (sc->keydpm, "decpm");
tabread.c:    else if ((sc->entdpm = tabccol (startab, "pmdec")))
tabread.c:	strcpy (sc->keydpm, "pmdec");
tabread.c:    else if ((sc->entrpm = tabccol (startab, "ddec")))
tabread.c:	strcpy (sc->keyrpm, "ddec");
tabread.c:    else if ((sc->entdpm = tabccol (startab, "uy")))
tabread.c:	strcpy (sc->keydpm, "uy");
tabread.c:    sc->mprop = 0;
tabread.c:		if (sc->entdpm > 0 && sc->entrpm > 0)
tabread.c:	sc->mprop = 1;
tabread.c:	    sc->rpmunit = PM_MASYR;
tabread.c:	    sc->rpmunit = PM_MTSYR;
tabread.c:	    sc->rpmunit = PM_ARCSECYR;
tabread.c:	    sc->rpmunit = PM_ARCSECHR;
tabread.c:	    sc->rpmunit = PM_ARCSECCEN;
tabread.c:	    sc->rpmunit = PM_RADYR;
tabread.c:	    sc->rpmunit = PM_TSECYR;
tabread.c:	    sc->rpmunit = PM_TSECYR;
tabread.c:	    sc->rpmunit = PM_TSECCEN;
tabread.c:	    sc->rpmunit = PM_DEGYR;
tabread.c:    else if (sc->entrpm > 0)
tabread.c:	sc->rpmunit = PM_TSECCEN;
tabread.c:	sc->mprop = 1;
tabread.c:	    sc->dpmunit = PM_MASYR;
tabread.c:	    sc->dpmunit = PM_ARCSECYR;
tabread.c:	    sc->dpmunit = PM_ARCSECYR;
tabread.c:	    sc->dpmunit = PM_ARCSECHR;
tabread.c:	    sc->dpmunit = PM_ARCSECCEN;
tabread.c:	    sc->dpmunit = PM_ARCSECYR;
tabread.c:	    sc->dpmunit = PM_RADYR;
tabread.c:	    sc->dpmunit = PM_DEGYR;
tabread.c:    else if (sc->entdpm > 0)
tabread.c:	sc->dpmunit = PM_ARCSECCEN;
tabread.c:    sc->entpx = 0;
tabread.c:    sc->entpx = tabccol (startab, "px");
tabread.c:    sc->entpxe = 0;
tabread.c:    sc->entpxe = tabccol (startab, "pxerr");
tabread.c:    sc->entrv = 0;
tabread.c:    sc->keyrv[0] = (char) 0;
tabread.c:    if ((sc->entrv = tabccol (startab, "rv")))
tabread.c:	strcpy (sc->keyrv, "rv");
tabread.c:    else if ((sc->entrv = tabccol (startab, "cz")))
tabread.c:	strcpy (sc->keyrv, "cz");
tabread.c:    if (sc->entrv > 0 && sc->nmag < 10) {
tabread.c:	strcpy (sc->keymag[sc->nmag], sc->keyrv);
tabread.c:	sc->entmag[sc->nmag] = sc->entrv;
tabread.c:	sc->nmag++;
tabread.c:    sc->entepoch = 0;
tabread.c:    sc->keyepoch[0] = (char) 0;
tabread.c:    if ((sc->entepoch = tabccol (startab, "epoch")))
tabread.c:	strcpy (sc->keyepoch, "epoch");
tabread.c:    else if ((sc->entepoch = tabccol (startab, "ep")))
tabread.c:	strcpy (sc->keyepoch, "ep");
tabread.c:    if (sc->entepoch > 0 && sc->nmag < 10) {
tabread.c:	strcpy (sc->keymag[sc->nmag], sc->keyepoch);
tabread.c:	sc->entmag[sc->nmag] = sc->entepoch;
tabread.c:	sc->nmag++;
tabread.c:	sc->nepoch = 1;
tabread.c:    sc->entdate = 0;
tabread.c:    sc->entdate = tabccol (startab, "date");
tabread.c:    sc->entpeak = -1;
tabread.c:    sc->keypeak[0] = (char) 0;
tabread.c:    if ((sc->entpeak = tabccol (startab, "PEAK")))
tabread.c:	strcpy (sc->keypeak, "PEAK");
tabread.c:    else if ((sc->entpeak = tabccol (startab, "peak")))
tabread.c:	strcpy (sc->keypeak, "peak");
tabread.c:    else if ((sc->entpeak = tabccol (startab, "plate"))) {
tabread.c:	strcpy (sc->keypeak, "plate");
tabread.c:	sc->plate = 1;
tabread.c:    else if ((sc->entpeak = tabccol (startab, "field"))) {
tabread.c:	strcpy (sc->keypeak, "field");
tabread.c:	sc->plate = 1;
tabread.c:    else if ((sc->entpeak = tabccol (startab, "Class"))) {
tabread.c:	strcpy (sc->keypeak, "class");
tabread.c:	sc->plate = 1;
tabread.c:    else if ((sc->entpeak = tabcol (startab, "c"))) {
tabread.c:	strcpy (sc->keypeak, "class");
tabread.c:	sc->plate = 1;
tabread.c:	sc->entpeak = (entpmq * 100) + entnid;
tabread.c:    sc->enttype = 0;
tabread.c:    sc->keytype[0] = (char) 0;
tabread.c:    if ((sc->enttype = tabccol (startab, "SpT")))
tabread.c:	strcpy (sc->keytype, "spt");
tabread.c:    else if ((sc->enttype = tabccol (startab, "TYPE")))
tabread.c:	strcpy (sc->keytype, "type");
tabread.c:    else if ((sc->enttype = tabccont (startab, "typ"))) {
tabread.c:	i = sc->enttype - 1;
tabread.c:	strncpy (sc->keytype, startab->colname[i], startab->lcol[i]);
tabread.c:    if (sc->enttype > 0)
tabread.c:	sc->sptype = 1;
tabread.c:    sc->entadd = -1;
tabread.c:    sc->keyadd[0] = (char) 0;
tabread.c:	sc->entadd = tabccol (startab, kwo);
tabread.c:	strcpy (sc->keyadd, kwo);
tabread.c:    sc->coorsys = 0;
tabread.c:    sc->equinox = 0.0;
tabread.c:    sc->epoch = 0.0;
tabread.c:	sc->coorsys = wcscsys (cstr);
tabread.c:	if (!tabhgetr8 (startab,"EQUINOX", &sc->equinox))
tabread.c:	    sc->equinox = wcsceq (cstr);
tabread.c:	if (!tabhgetr8 (startab,"EPOCH",&sc->epoch))
tabread.c:	    sc->epoch = sc->equinox;
tabread.c:	sc->coorsys = wcscsys (cstr);
tabread.c:	if (!tabhgetr8 (startab,"equinox", &sc->equinox))
tabread.c:	    sc->equinox = wcsceq (cstr);
tabread.c:	if (!tabhgetr8 (startab,"epoch",&sc->epoch))
tabread.c:	    sc->epoch = sc->equinox;
tabread.c:    else if (tabhgetr8 (startab,"EQUINOX", &sc->equinox)) {
tabread.c:	if (!tabhgetr8 (startab,"EPOCH",&sc->epoch))
tabread.c:	    sc->epoch = sc->equinox;
tabread.c:	if (sc->equinox == 1950.0)
tabread.c:	    sc->coorsys = WCS_B1950;
tabread.c:	    sc->coorsys = WCS_J2000;
tabread.c:    else if (tabhgetr8 (startab,"equinox", &sc->equinox)) {
tabread.c:	if (!tabhgetr8 (startab,"epoch",&sc->epoch))
tabread.c:	    sc->epoch = sc->equinox;
tabread.c:	if (sc->equinox == 1950.0)
tabread.c:	    sc->coorsys = WCS_B1950;
tabread.c:	    sc->coorsys = WCS_J2000;
tabread.c:    else if (tabhgetr8 (startab,"EPOCH", &sc->epoch)) {
tabread.c:	sc->equinox = sc->epoch;
tabread.c:	if (sc->equinox == 1950.0)
tabread.c:	    sc->coorsys = WCS_B1950;
tabread.c:	    sc->coorsys = WCS_J2000;
tabread.c:    else if (tabhgetr8 (startab,"epoch", &sc->epoch)) {
tabread.c:	sc->equinox = sc->epoch;
tabread.c:	if (sc->equinox == 1950.0)
tabread.c:	    sc->coorsys = WCS_B1950;
tabread.c:	    sc->coorsys = WCS_J2000;
tabread.c:	sc->rasorted = 1;
tabread.c:	sc->rasorted = 0;
tabread.c:    sc->nstars = startab->nlines;
tabread.c:    if (sc->entid)
tabread.c:	sc->stnum = 1;
tabread.c:	sc->stnum = 0;
tabread.c:    if (sc->entid) {
tabread.c:	tabgetc (&startok, sc->entid, cstr, 32);
tabread.c:	    sc->nnfld = nnfld;
tabread.c:	    sc->nnfld = strlen (cstr);
tabread.c:	    sc->nndec = nndec;
tabread.c:		sc->stnum = -nndec;
tabread.c:	    dnum = tabgetr8 (&startok,sc->entid);
tabread.c:		if (cstr[lnum-i-1] != '0') {
tabread.c:		    ndec = 8 - i;
tabread.c:			sc->nndec = nndec;
tabread.c:	    sc->nndec = nndec;
tabread.c:	    sc->stnum = -strlen (cstr);
tabread.c:	    sc->nndec = nndec;
tabread.c:    sc->refcat = TABCAT;
tabread.c:/* TABCATCLOSE -- Close tab table catalog and free associated data structures */
tabread.c:    tabclose (sc->startab);
tabread.c:/* TABSTAR -- Get tab table catalog entry for one star;
tabread.c:   return 0 if successful, else -1 */
tabread.c:    struct TabTable *startab = sc->startab;
tabread.c:	return (-1);
tabread.c:	return (-1);
tabread.c:    st->objname[0] = (char) 0;
tabread.c:    if (sc->entid) {
tabread.c:	tabgetc (&startok, sc->entid, cnum, 64);
tabread.c:	if (!strcmp (sc->isfil,"usnoa-server")) {
tabread.c:	else if (!strcmp (sc->isfil,"gsc-server"))
tabread.c:		    st->num = atof (cn + lcn - 15);
tabread.c:		    st->num = atof (cn);
tabread.c:		    st->num = -atof (cn+1);
tabread.c:		    st->num = atof (cn+1);
tabread.c:	    if (!strcmp (sc->isfil,"gsc-server")) {
tabread.c:		st->num = (double) ireg + 0.0001 * (double) inum;
tabread.c:	    sc->nnfld = strlen (cn);
tabread.c:		sc->nndec = nndec;
tabread.c:		sprintf (cn,"%.0f", (st->num * 100000000.0) + 0.1);
tabread.c:		    if (cn[lnum-i-1] != '0') {
tabread.c:			ndec = 8 - i;
tabread.c:			    sc->nndec = nndec;
tabread.c:	    strcpy (st->objname, cnum);
tabread.c:	    st->num = st->num + 1.0;
tabread.c:	st->num = (double) istar;
tabread.c:	sc->nndec = nndec;
tabread.c:    st->ra = tabgetra (&startok, sc->entra);
tabread.c:    st->dec = tabgetdec (&startok, sc->entdec);
tabread.c:    for (imag = 0; imag < sc->nmag; imag++) {
tabread.c:	if (sc->entmag[imag]) {
tabread.c:	    if (tabgetc (&startok, sc->entmag[imag], str, 24))
tabread.c:	    if (str[ltok-1] == 'L') {
tabread.c:		str[ltok-1] = (char) 0;
tabread.c:		    st->xmag[imag] = 100.0 + atof (str);
tabread.c:		    st->xmag[imag] = 0.0;
tabread.c:		st->xmag[imag] = tabgetr8 (&startok, sc->entmag[imag]);
tabread.c:	    st->xmag[imag] = 0.0;
tabread.c:    st->rapm = tabgetr8 (&startok, sc->entrpm);
tabread.c:    if (sc->rpmunit == PM_MASYR)
tabread.c:	st->rapm = (st->rapm / 3600000.0) / cosdeg(st->dec);
tabread.c:    else if (sc->rpmunit == PM_MTSYR)
tabread.c:	st->rapm = st->rapm / 240000.0;
tabread.c:    else if (sc->rpmunit == PM_ARCSECYR)
tabread.c:	st->rapm = (st->rapm / 3600.0) / cosdeg (st->dec);
tabread.c:    else if (sc->rpmunit == PM_ARCSECCEN)
tabread.c:	st->rapm = (st->rapm / 360000.0) / cosdeg (st->dec);
tabread.c:    else if (sc->rpmunit == PM_TSECYR)
tabread.c:	st->rapm = st->rapm / 240.0;
tabread.c:    else if (sc->rpmunit == PM_TSECCEN)
tabread.c:	st->rapm = st->rapm / 24000.0;
tabread.c:    else if (sc->rpmunit == PM_RADYR)
tabread.c:	st->rapm = raddeg (st->rapm);
tabread.c:	st->rapm = 0.0;
tabread.c:    st->decpm = tabgetr8 (&startok, sc->entdpm);
tabread.c:    if (sc->dpmunit == PM_MASYR)
tabread.c:	st->decpm = st->decpm / 3600000.0;
tabread.c:    else if (sc->dpmunit == PM_ARCSECYR)
tabread.c:	st->decpm = st->decpm / 3600.0;
tabread.c:    else if (sc->dpmunit == PM_ARCSECCEN)
tabread.c:	st->decpm = st->decpm / 360000.0;
tabread.c:    else if (sc->dpmunit == PM_RADYR)
tabread.c:	st->decpm = raddeg (st->decpm);
tabread.c:	st->decpm = 0.0;
tabread.c:    if (sc->entpx)
tabread.c:	st->parallax = tabgetr8 (&startok, sc->entpx);
tabread.c:	st->parallax = 0.0;
tabread.c:    if (sc->entrv)
tabread.c:	st->radvel = tabgetr8 (&startok, sc->entrv);
tabread.c:	st->radvel = 0.0;
tabread.c:    if (sc->entepoch) {
tabread.c:	tabgetc (&startok, sc->entepoch, temp, 10);
tabread.c:	    if (sc->entdate > 0) {
tabread.c:		tabgetc (&startok, sc->entdate, temp, 10);
tabread.c:		st->epoch = fd2ep (temp);
tabread.c:		st->epoch = sc->epoch;
tabread.c:	else if (strchr (temp, '-') != NULL)
tabread.c:	    st->epoch = fd2ep (temp);
tabread.c:	    ydate = tabgetr8 (&startok, sc->entepoch);
tabread.c:		st->epoch = dt2ep (ydate, 12.0);
tabread.c:		st->epoch = mjd2ep (ydate);
tabread.c:		st->epoch = jd2ep (ydate);
tabread.c:	    if (st->epoch > 2005.000)
tabread.c:		printf ("TABSTAR: %s = %.5f -> %.5f\n", temp, ydate, st->epoch);
tabread.c:	st->xmag[sc->nmag-1] = st->epoch;
tabread.c:	st->epoch = sc->epoch;
tabread.c:    if (sc->entpeak > 100) {
tabread.c:	pmq = tabgeti4 (&startok, sc->entpeak/100);
tabread.c:	nid = tabgeti4 (&startok, sc->entpeak%100);
tabread.c:	st->peak = (pmq * 100) + nid;
tabread.c:    else if (sc->entpeak > 0)
tabread.c:	st->peak = tabgeti4 (&startok, sc->entpeak);
tabread.c:	st->peak = 0;
tabread.c:    if (sc->enttype > 0) {
tabread.c:	strcpy (st->isp, "__");
tabread.c:	tabgetc (&startok, sc->enttype, st->isp, 24);
tabread.c:	(void) tabgetk (startab, &startok, kwo, st->objname, 79);
tabread.c:    st->coorsys = sc->coorsys;
tabread.c:    st->equinox = sc->equinox;
tabread.c:/* TABOPEN -- Open tab table file, returning number of entries */
tabread.c:    tabtable->tabname = tabname;
tabread.c:    if ((tabtable->filename = (char *)calloc (1, lname)) == NULL) {
tabread.c:    strcpy (tabtable->filename, tabfile);
tabread.c:    if ((tabtable->tabbuff = (char *) calloc (1, lfile+2)) == NULL) {
tabread.c:	nr = fread (tabtable->tabbuff, 1, lfile, fcat);
tabread.c:	tabtable->tabbuff[lfile] = (char) 0;
tabread.c:		thisname = tabtable->tabbuff;
tabread.c:		    nchar = tabline - thisname;
tabread.c:			strncpy (tabtable->tabname, thisname, nchar);
tabread.c:		thisname = tabtable->tabbuff;
tabread.c:		tabtable->tabheader = strchr (thisname, newline) + 1;
tabread.c:	    tabtable->tabheader = tabtable->tabbuff;
tabread.c:	tabline = tabtable->tabheader;
tabread.c:	while (*tabline!='-' && tabline!=NULL && tabline < tabtable->tabbuff+lfile) {
tabread.c:	if (tabline == NULL || *tabline != '-') {
tabread.c:	    sprintf (taberr,"TABOPEN: No - line in tab table %s",tabfile);
tabread.c:	if ( tabline[1] != '-' && tabline[1] != (char)9 ) {
tabread.c:	    sprintf (taberr,"TABOPEN: No - line in tab table %s",tabfile);
tabread.c:	tabtable->tabhead = lastline;
tabread.c:	tabtable->tabdash = tabline;
tabread.c:	tabtable->tabdata = strchr (tabline, newline) + 1;
tabread.c:	    tabtable->nlines = 10000000;
tabread.c:	    tabnew = tabtable->tabdata;
tabread.c:	    tabtable->nlines = 0;
tabread.c:		tabtable->nlines = tabtable->nlines + 1;
tabread.c:	    fprintf (stderr,"TABOPEN: %d lines in tab table %s", tabtable->nlines, tabfile);
tabread.c:	tabtable->lhead = tabtable->tabdata - tabtable->tabheader;
tabread.c:	tabtable->tcat = fcat;
tabread.c:	nextline = strchr (tabtable->tabdata, newline) + 1;
tabread.c:	tabtable->lline = (nextline - tabtable->tabdata) * 2;
tabread.c:	tabtable->tabline = (char *) calloc (tabtable->lline, 1);
tabread.c:	fseek (tabtable->tcat, (long) tabtable->lhead, SEEK_SET);
tabread.c:	(void) fgets (tabtable->tabline, tabtable->lline, tabtable->tcat);
tabread.c:	lline = strlen (tabtable->tabline);
tabread.c:	if (tabtable->tabline[lline-1] < 32)
tabread.c:	     tabtable->tabline[lline-1] = (char) 0;
tabread.c:	tabtable->tabdata = tabtable->tabline;
tabread.c:	tabtable->lhead = 0;
tabread.c:	tabtable->tcat = NULL;
tabread.c:    tabtable->tabline = tabtable->tabdata;
tabread.c:    tabtable->iline = 1;
tabread.c:	if (tabtable->filename != NULL) free (tabtable->filename);
tabread.c:	if (tabtable->tabname != NULL) free (tabtable->tabname);
tabread.c:	if (tabtable->tabbuff != NULL) free (tabtable->tabbuff);
tabread.c:	if (tabtable->colname != NULL) free (tabtable->colname);
tabread.c:	if (tabtable->lcol != NULL) free (tabtable->lcol);
tabread.c:	if (tabtable->lcfld != NULL) free (tabtable->lcfld);
tabread.c:	if (tabtable->tcat != NULL) fclose (tabtable->tcat);
tabread.c:/* TABLINE -- Get tab table entry for one line;
tabread.c:    char *nextline = tabtable->tabline;
tabread.c:    if (tabtable->tcat != NULL) {
tabread.c:	if (iline == tabtable->iline)
tabread.c:	    return (tabtable->tabline);
tabread.c:	if (iline < 1 || iline > tabtable->iline) {
tabread.c:	    for (i = tabtable->iline; i < iline; i++) {
tabread.c:		next = fgets (tabtable->tabline, tabtable->lline, tabtable->tcat);
tabread.c:		tabtable->iline++;
tabread.c:	    lline = strlen (tabtable->tabline);
tabread.c:	    if (tabtable->tabline[lline-1] < 32)
tabread.c:		tabtable->tabline[lline-1] = (char) 0;
tabread.c:	else if (iline < tabtable->iline) {
tabread.c:	    fseek (tabtable->tcat, (long) tabtable->lhead, SEEK_SET);
tabread.c:	    tabtable->iline = 0;
tabread.c:	    for (i = tabtable->iline; i < iline; i++) {
tabread.c:		(void) fgets (tabtable->tabline, tabtable->lline, tabtable->tcat);
tabread.c:		tabtable->iline++;
tabread.c:	    lline = strlen (tabtable->tabline);
tabread.c:	    if (tabtable->tabline[lline-1] < 32)
tabread.c:		tabtable->tabline[lline-1] = (char) 0;
tabread.c:	return (tabtable->tabline);
tabread.c:    if (iline > tabtable->nlines) {
tabread.c:	tabtable->iline++;
tabread.c:	if (tabtable->iline > tabtable->nlines) {
tabread.c:    else if (iline < tabtable->iline) {
tabread.c:	tabtable->iline = 1;
tabread.c:	tabtable->tabline = tabtable->tabdata;
tabread.c:	while (tabtable->iline < iline) {
tabread.c:	    tabtable->tabline = strchr (tabtable->tabline, newline) + 1;
tabread.c:	    tabtable->iline ++;
tabread.c:    else if (iline > tabtable->iline) {
tabread.c:	while (tabtable->iline < iline) {
tabread.c:	    tabtable->tabline = strchr (tabtable->tabline, newline) + 1;
tabread.c:	    tabtable->iline ++;
tabread.c:    return (tabtable->tabline);
tabread.c:/* TABGETRA -- returns double right ascension in degrees */
tabread.c:/* TABGETDEC -- returns double declination in degrees */
tabread.c:/* TABGETR8 -- returns 8-byte floating point number from tab table line */
tabread.c:/* TABGETI4 -- returns a 4-byte integer from tab table line */
tabread.c:/* TABGETK -- returns a character entry from tab table line for named column */
tabread.c:/* TABGETC -- returns n'th entry from tab table line as character string */
tabread.c:int	ientry;		/* Sequence of entry on line (1-ncol) */
tabread.c:    if (ientry > tabtok->ntok)
tabread.c:	return (-1);
tabread.c:/* TABHGETR8 -- read an 8-byte floating point number from a tab table header */
tabread.c:/* TABHGETI4 -- read a 4-byte integer from a tab table header */
tabread.c:/* TABHGETC -- read a string from a tab table header */
tabread.c:    head = tabtable->tabbuff;
tabread.c:    /* Make all-upper-case and all-lower-case versions of keyword */
tabread.c:	    keyup[i] = keyword[i] - 32;
tabread.c:    /* Find keyword or all-upper-case or all-lower-case version in header */
tabread.c:    while (head < tabtable->tabhead) {
tabread.c:	if (line == tabtable->tabbuff || line[-1] == newline) {
tabread.c:	ncstr = str1 - str0;
tabread.c:/* TABPARSE -- Make a table of column headings */
tabread.c:    if (tabtable->tabhead ==  NULL)
tabread.c:    headlast = strchr (tabtable->tabhead, newline);
tabread.c:    if (headlast == tabtable->tabhead)
tabread.c:    tabtable->ncols = 1;
tabread.c:    for (colhead = tabtable->tabhead; colhead < headlast; colhead++) {
tabread.c:	    tabtable->ncols++;
tabread.c:    nbytes = tabtable->ncols * sizeof (char *);
tabread.c:    tabtable->colname = (char **)calloc (tabtable->ncols, sizeof (char *));
tabread.c:    tabtable->lcol = (int *) calloc (tabtable->ncols, sizeof (int));
tabread.c:    colhead = tabtable->tabhead;
tabread.c:    for (icol = 0; icol < tabtable->ncols; icol++) {
tabread.c:	    endcol = nextab - 1;
tabread.c:	    endcol = headlast - 1;
tabread.c:	    endcol = endcol - 1;
tabread.c:	tabtable->lcol[icol] = (int) (endcol - colhead) + 1;
tabread.c:	tabtable->colname[icol] = colhead;
tabread.c:    tabtable->lcfld = (int *) calloc (tabtable->ncols, sizeof (int));
tabread.c:    for (icol = 0; icol < tabtable->ncols; icol++) {
tabread.c:	    endcol = hyphlast - 1;
tabread.c:	    endcol = nextab - 1;
tabread.c:	tabtable->lcfld[icol] = (int) (endcol - colhead) + 1;
tabread.c:    return (tabtable->ncols);
tabread.c:/* Search table of column headings for a particlar entry (case-dependent) */
tabread.c:    for (i = 0; i < tabtable->ncols; i++) {
tabread.c:	lcol = tabtable->lcol[i];
tabread.c:	    !strncmp (keyword, tabtable->colname[i], lcol)) {
tabread.c:/* Search table of column headings for a particlar entry (case-independent) */
tabread.c:    for (i = 0; i < tabtable->ncols; i++) {
tabread.c:	lcol = tabtable->lcol[i];
tabread.c:	    !strncasecmp (keyword, tabtable->colname[i], lcol)) {
tabread.c:/* Search table of column headings for first with string (case-dependent) */
tabread.c:    for (i = 0; i < tabtable->ncols; i++) {
tabread.c:	if (strnsrch (tabtable->colname[i], keyword, tabtable->lcol[i])) {
tabread.c:/* Search table of column headings for first with string (case-independent) */
tabread.c:    for (i = 0; i < tabtable->ncols; i++) {
tabread.c:	if (strncsrch (tabtable->colname[i], keyword, tabtable->lcol[i])) {
tabread.c:/* TABSIZE -- return size of file in bytes */
tabread.c:	return (-1);
tabread.c:	filesize = -1;
tabread.c:/* ISTAB -- Return 1 if tab table file, else 0 */
tabread.c: * Feb 10 2000	Accept first mag-containing column as first magnitude
tabread.c: * Feb 10 2000	Clean up id reading: no. decimals, non-numeric id
tabread.c: * May 26 2000	Add ability to read named tables in a multi-table file
tabread.c: * Jun 11 2001	Add one-line-at-a-time catalog reading from tabcatopen()
tabread.c: * Sep 20 2001	Change _ to . in ESO server USNO-A2.0 numbers
tabread.c: * Aug  5 2002	Deal correctly with magnitude-less catalogs
tabread.c: * Jan 26 2003	Add code to pass USNO-B1.0 pm quality and no. of ids
tabread.c: * Aug 11 2005	Do not re-read lines if missing object numbers in tabrnum()
tabread.c: * Aug 17 2005	If nmax is -1, print magnitude keywords from file
tabread.c: * Mar 13 2007	Return object name if first character of ID is non-numeric
tabread.c: * Jul 18 2007	Add tabccol() and tabccont() case-insensitive header searches
tabsort.c:char	*buffer;	/* White-space separated table */
tabsort.c:	nchar = line2 - line1 + 1;
tabsort.c:	table[i]->entry = (char *)calloc (1, nchar);
tabsort.c:	line = table[i]->entry;
tabsort.c:		table[i]->ang = str2dec (token);
tabsort.c:		table[i]->ang = atof (token);
tabsort.c:    strcpy (buffout, table[0]->entry);
tabsort.c:	strcat (buffout, table[i]->entry);
tabsort.c:	free (table[i]->entry);
tabsort.c:/* TabSort -- Order stars in decreasing flux called by qsort */
tabsort.c:    double b1 = ((TabInfo *)ssp1)->ang;
tabsort.c:    double b2 = ((TabInfo *)ssp2)->ang;
tabsort.c:	return (-1);
tmcread.c: *** Harvard-Smithsonian Center for Astrophysics
tmcread.c: *** Copyright (C) 2001-2010
tmcread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
tmcread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
tmcread.c:/* TMCREAD -- Read 2MASS catalog stars from disk files */
tmcread.c:double	ddec;		/* Search half-width in declination in degrees */
tmcread.c:    double size = 0.0;		/* Semi-major axis of extended source */
tmcread.c:    star->num = 0.0;
tmcread.c:	magsort = sortmag - 1;
tmcread.c:	printf ("----------	------------	------------	");
tmcread.c:	printf ("------	------	------");
tmcread.c:	    printf ("------	------	------");
tmcread.c:	    printf ("	------");
tmcread.c:	printf ("	------\n");
tmcread.c:		istar2 = starcat->nstars; */
tmcread.c:			istar1, istar2-1, zone);
tmcread.c:		num = star->num;
tmcread.c:		mag = star->xmag[0];
tmcread.c:		/* Semi-major axis of extended source */
tmcread.c:		    size = star->size;
tmcread.c:		    ra = star->ra;
tmcread.c:		    dec = star->dec;
tmcread.c:			CatNum (TMPSC, -10, 0, num, numstr);
tmcread.c:			    if (star->xmag[imag] > 100.0)
tmcread.c:				printf ("	%.3fL", star->xmag[imag]-100.0);
tmcread.c:				printf ("	%.3f ", star->xmag[imag]);
tmcread.c:				printf ("	%.3f ", star->xmag[imag]);
tmcread.c:				gmag[imag][nstar] = star->xmag[imag];
tmcread.c:				    gmag[imag][farstar] = star->xmag[imag];
tmcread.c:				gmag[imag][faintstar] = star->xmag[imag];
tmcread.c:				 num,ra,dec,star->xmag[0],star->xmag[1],star->xmag[2]);
tmcread.c:			     nstar,jstar,starcat->nstars);
tmcread.c:	    ntot = ntot + starcat->nstars;
tmcread.c:		 	 ireg+1,nreg,nstar,jstar,starcat->nstars,zone);
tmcread.c:/* TMCRNUM -- Read HST Guide Star Catalog stars from CDROM */
tmcread.c:double	**gmag;		/* 2-D array of magnitudes (returned) */
tmcread.c:    star->num = 0.0;
tmcread.c:	    dstar = (gnum[jstar] - (double)rnum) * 10000000.0;
tmcread.c:	    dstar = (gnum[jstar] - (double)rnum) * 1000000.0;
tmcread.c:	num = star->num;
tmcread.c:	ra = star->ra;
tmcread.c:	dec = star->dec;
tmcread.c:	rapm = star->rapm;
tmcread.c:	decpm = star->decpm;
tmcread.c:	    gmag[imag][jstar] = star->xmag[imag];
tmcread.c:	    gtype[jstar] = (int) ((star->size * 10.0) + 0.5);
tmcread.c:		     num, ra, dec, star->xmag[0],star->xmag[1],star->xmag[2]);
tmcread.c:			 star->xmag[3],star->xmag[4],star->xmag[5]);
tmcread.c:/* TMCBIN -- Fill FITS WCS image with 2MASS point source catalog objects */
tmcread.c:    double ddec;	/* Search half-width in declination in degrees */
tmcread.c:    sysout = wcs->syswcs;
tmcread.c:    eqout = wcs->equinox;
tmcread.c:    epout = wcs->epoch;
tmcread.c:    star->num = 0.0;
tmcread.c:	magsort = sortmag - 1;
tmcread.c:			istar1, istar2-1);
tmcread.c:		num = star->num;
tmcread.c:		mag = star->xmag[0];
tmcread.c:		    ra = star->ra;
tmcread.c:		    dec = star->dec;
tmcread.c:			    flux = magscale * exp (logt * (-mag / 2.5));
tmcread.c:			     nstar,jstar,starcat->nstars);
tmcread.c:	    ntot = ntot + starcat->nstars;
tmcread.c:		 	 ireg+1,nreg,nstar,jstar,starcat->nstars,zone);
tmcread.c:/* TMCREG -- find the regions contained by the given RA/Dec limits
tmcread.c:		iz1 = i - 1;
tmcread.c:		iz2 = i - 1;
tmcread.c:	    nsrch = iz2 - iz1 + 1;
tmcread.c:	    nsrch = 48 - iz1 + 1 + iz2 + 1;
tmcread.c:	    fprintf(stderr,"TMCREG: RA: %.5f - %.5f, Dec: %.5f - %.5f\n",
tmcread.c:		fprintf (stderr,"TMCREG: searching %d regions: %d - %d",
tmcread.c:		fprintf (stderr,", %d - %d", jr1, jr2);
tmcread.c:    /* Compute SPD regions for all-sky release of point source catalog */
tmcread.c:/* TMCOPEN -- Open 2MASS point source catalog file, returning catalog structure */
tmcread.c:    sc->byteswapped = 0;
tmcread.c:    sc->refcat = refcat;
tmcread.c:	sc->entra = 0;
tmcread.c:	sc->entdec = 10;
tmcread.c:	sc->entname = 0;
tmcread.c:	sc->entmag[0] = 39;
tmcread.c:	sc->entmag[1] = 46;
tmcread.c:	sc->entmag[2] = 53;
tmcread.c:	sc->entadd = 61;
tmcread.c:	sc->nbent = 69;
tmcread.c:	sc->entra = 0;
tmcread.c:	sc->entdec = 10;
tmcread.c:	sc->entname = 0;
tmcread.c:	sc->entmag[0] = 39;
tmcread.c:	sc->entmag[1] = 46;
tmcread.c:	sc->entmag[2] = 53;
tmcread.c:	sc->entmag[3] = 60;
tmcread.c:	sc->entmag[4] = 66;
tmcread.c:	sc->entmag[5] = 72;
tmcread.c:	sc->entadd = 79;
tmcread.c:	sc->nbent = 87;
tmcread.c:	sc->entra = 0;
tmcread.c:	sc->entdec = 10;
tmcread.c:	sc->entname = 0;
tmcread.c:	sc->entmag[0] = 39;
tmcread.c:	sc->entmag[1] = 46;
tmcread.c:	sc->entmag[2] = 53;
tmcread.c:	sc->entsize = 60;
tmcread.c:	sc->nbent = 68;
tmcread.c:	sc->entra = 0;
tmcread.c:	sc->entdec = 10;
tmcread.c:	sc->entmag[0] = 53;
tmcread.c:	sc->entmag[1] = 72;
tmcread.c:	sc->entmag[2] = 91;
tmcread.c:	sc->entadd = 110;
tmcread.c:	sc->nbent = 302;
tmcread.c:    sc->nstars = lfile / sc->nbent;
tmcread.c:	strcpy (sc->isfil, zonefile);
tmcread.c:	strncpy (sc->isfil, zonefile, 23);
tmcread.c:    sc->inform = 'J';
tmcread.c:    sc->coorsys = WCS_J2000;
tmcread.c:    sc->epoch = 2000.0;
tmcread.c:    sc->equinox = 2000.0;
tmcread.c:    sc->ifcat = fcat;
tmcread.c:    sc->sptype = 2;
tmcread.c:    /* All-sky release 2MASS catalogs are RA-sorted within Dec zones */
tmcread.c:	sc->rasorted = 1;
tmcread.c:    /* Pre-release 2MASS catalogs were Dec-sorted within RA zones */
tmcread.c:	sc->rasorted = 0;
tmcread.c:    fclose (sc->ifcat);
tmcread.c:    if (sc->catdata != NULL)
tmcread.c:	free (sc->catdata);
tmcread.c:/* TMCSDEC -- Find 2MASS star closest to specified declination */
tmcread.c:    dec1 = star->dec;
tmcread.c:    istar = starcat->nstars;
tmcread.c:	    dec = star->dec;
tmcread.c:	    rdiff = dec1 - dec;
tmcread.c:	    rdiff1 = dec1 - decx;
tmcread.c:	    rdiff2 = dec - decx;
tmcread.c:	    sdiff = (double)(istar - istar1) * rdiff1 / rdiff;
tmcread.c:	    if (istar > starcat->nstars)
tmcread.c:		istar = starcat->nstars;
tmcread.c:/* TMCSRA -- Find 2MASS star closest to specified right ascension */
tmcread.c:    ra0 = -1.0;
tmcread.c:    ra1 = star->ra;
tmcread.c:	nrep = -1;
tmcread.c:	istar = (int) star->num;
tmcread.c:    ra0 = star->ra;
tmcread.c:    istar1 = starcat->nstars;
tmcread.c:    ra1 = star->ra;
tmcread.c:    istar = starcat->nstars / 2;
tmcread.c:    ra = star->ra;
tmcread.c:	    sdiff = 0.5 * (double) (istar1 - istar);
tmcread.c:	    sdiff = 0.5 * (double) (istar - istar0);
tmcread.c:	    istar = istar - (int) (sdiff + 0.5);
tmcread.c:	ra = star->ra;
tmcread.c:	    istar0 = istar - 1;
tmcread.c:	    if (star->ra < rax)
tmcread.c:	    if (istar0 > starcat->nstars)
tmcread.c:	    if (star->ra > rax)
tmcread.c:/* TMCSTAR -- Get 2MASS Point Source Catalog entry for one star;
tmcread.c:int	zone;		/* Zone catalog number (1-49) */
tmcread.c:    if (sc->ifcat == NULL)
tmcread.c:    if (istar > sc->nstars) {
tmcread.c:		 istar, sc->nstars);
tmcread.c:    nbskip = sc->nbent * (istar - 1);
tmcread.c:    if (fseek (sc->ifcat,nbskip,SEEK_SET))
tmcread.c:	return (-1);
tmcread.c:    nbr = fread (line, sc->nbent, 1, sc->ifcat) * sc->nbent;
tmcread.c:    if (nbr < sc->nbent) {
tmcread.c:	fprintf (stderr, "tmcstar %d / %d bytes read\n",nbr, sc->nbent);
tmcread.c:	return (-2);
tmcread.c:    if (sc->refcat == TMIDR2)
tmcread.c:	st->num = zone + (0.0000001 * (double) istar);
tmcread.c:	st->num = zone + (0.000001 * (double) istar);
tmcread.c:    st->ra = atof (line);
tmcread.c:    st->dec = atof (line+sc->entdec);
tmcread.c:    st->rapm = 0.0;
tmcread.c:    st->decpm = 0.0;
tmcread.c:    st->xmag[0] = atof (line+sc->entmag[0]);
tmcread.c:    st->xmag[1] = atof (line+sc->entmag[1]);
tmcread.c:    st->xmag[2] = atof (line+sc->entmag[2]);
tmcread.c:    if (sc->refcat == TMPSCE) {
tmcread.c:	st->xmag[3] = atof (line+sc->entmag[3]);
tmcread.c:	st->xmag[4] = atof (line+sc->entmag[4]);
tmcread.c:	st->xmag[5] = atof (line+sc->entmag[5]);
tmcread.c:    if (sc->refcat == TMPSC || sc->refcat == TMPSCE || sc->refcat == TMXSC) {
tmcread.c:	if (line[sc->entadd] == 'U')
tmcread.c:	    st->xmag[0] = st->xmag[0] + 100.0;
tmcread.c:	if (line[sc->entadd + 1] == 'U')
tmcread.c:	    st->xmag[1] = st->xmag[1] + 100.0;
tmcread.c:	if (line[sc->entadd + 2] == 'U')
tmcread.c:	    st->xmag[2] = st->xmag[2] + 100.0;
tmcread.c:	iflag = ((int) line[sc->entadd]) - 48;
tmcread.c:	    st->xmag[0] = st->xmag[0] + 100.0;
tmcread.c:	iflag = ((int) line[sc->entadd + 1]) - 48;
tmcread.c:	    st->xmag[1] = st->xmag[1] + 100.0;
tmcread.c:	iflag = ((int) line[sc->entadd + 2]) - 48;
tmcread.c:	    st->xmag[2] = st->xmag[2] + 100.0;
tmcread.c:    if (sc->refcat == TMXSC)
tmcread.c:	st->size = atof (line+sc->entsize);
tmcread.c:	st->size = 0.0;
tmcread.c: * May 19 2003	Add code to read dec-zoned, ra-sorted All-Sky release
tmcread.c: * May 21 2003	Add catfile argument to read both IDR2 and All-Sky releases
tmcread.c: * May 28 2003	Star ID numbers from All-Sky release have 6 decimal places
tmcread.c: * Jul  2 2003	Fix limiting magnitude for All-Sky Release
tnxpos.c: *** Harvard-Smithsonian Center for Astrophysics
tnxpos.c: *** Copyright (C) 1998-2008
tnxpos.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
tnxpos.c:/* wftnx -- wcs function driver for the gnomonic projection with correction.
tnxpos.c:/* tnxinit -- initialize the gnomonic forward or inverse transform.
tnxpos.c:    if (wcs->longpole > 360.0) {
tnxpos.c:	if (!igetr8 (str1, "longpole", &wcs->longpole)) {
tnxpos.c:	    if (!igetr8 (str2, "longpole", &wcs->longpole))
tnxpos.c:		wcs->longpole = 180.0;
tnxpos.c:    if (!igetr8 (str1, "ro", &wcs->rodeg)) {
tnxpos.c:	if (!igetr8 (str2, "ro", &wcs->rodeg))
tnxpos.c:	    //wcs->rodeg = 180.0 / PI;
tnxpos.c:	    wcs->rodeg = 180.0 / WCS_PI;
tnxpos.c:	    wcs->lngcor = NULL;
tnxpos.c:	    wcs->lngcor = wf_gsopen (lngstr);
tnxpos.c:	wcs->lngcor = wf_gsopen (lngstr);
tnxpos.c:	    wcs->latcor = NULL;
tnxpos.c:	    wcs->latcor = wf_gsopen (latstr);
tnxpos.c:	wcs->latcor = wf_gsopen (latstr);
tnxpos.c:    if (wcs->latcor == NULL && wcs->lngcor == NULL)
tnxpos.c:/* tnxpos -- forward transform (physical to world) gnomonic projection. */
tnxpos.c:    xpix = xpix - wcs->crpix[0];
tnxpos.c:    ypix = ypix - wcs->crpix[1];
tnxpos.c:    if (wcs->rotmat) {
tnxpos.c:	x = xpix * wcs->cd[0] + ypix * wcs->cd[1];
tnxpos.c:	y = xpix * wcs->cd[2] + ypix * wcs->cd[3];
tnxpos.c:	/* Check axis increments - bail out if either 0 */
tnxpos.c:	if (wcs->cdelt[0] == 0.0 || wcs->cdelt[1] == 0.0) {
tnxpos.c:	xs = xpix * wcs->cdelt[0];
tnxpos.c:	ys = ypix * wcs->cdelt[1];
tnxpos.c:	if (wcs->rot != 0.0) {
tnxpos.c:	    double cosr = cos (degrad (wcs->rot));
tnxpos.c:	    double sinr = sin (degrad (wcs->rot));
tnxpos.c:	    x = xs * cosr - ys * sinr;
tnxpos.c:    if (wcs->coorflip) {
tnxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
tnxpos.c:    longp = degrad(wcs->longpole);
tnxpos.c:    if (wcs->lngcor != NULL)
tnxpos.c:	xp = x + wf_gseval (wcs->lngcor, x, y);
tnxpos.c:    if (wcs->latcor != NULL)
tnxpos.c:	yp = y + wf_gseval (wcs->latcor, x, y);
tnxpos.c:	phi = atan2 (x, -y);
tnxpos.c:    theta = atan2 (wcs->rodeg, r);
tnxpos.c:    dphi = phi - longp;
tnxpos.c:    x = sinthe * sinlatp - costhe * coslatp * cosphi;
tnxpos.c:	x = -cos (theta + colatp) + costhe * coslatp * (1.0 - cosphi);
tnxpos.c:    y = -costhe * sinphi;
tnxpos.c:    ra =  wcs->crval[ira] + raddeg(dlng);
tnxpos.c:    if (wcs->crval[ira] >= 0.0) {
tnxpos.c:	    ra = ra - 360.0;
tnxpos.c:	ra = ra - 360.0;
tnxpos.c:    else if (ra < -360.0)
tnxpos.c:	    dec = 180.0 - dec;
tnxpos.c:	if (dec < -90.0)
tnxpos.c:	    dec = -180.0 - dec;
tnxpos.c:		dec = raddeg(-acos (sqrt(x * x + y * y)));
tnxpos.c:/* tnxpix -- inverse transform (world to physical) gnomonic projection */
tnxpos.c:    if (wcs->coorflip) {
tnxpos.c:    ra  = degrad (xpos - wcs->crval[ira]);
tnxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
tnxpos.c:    if (wcs->longpole == 999.0)
tnxpos.c:	longp = degrad(wcs->longpole);
tnxpos.c:    x = sindec * sinlatp - cosdec * coslatp * cosra;
tnxpos.c:	x = -cos (dec + colatp) + cosdec * coslatp * (1.0 - cosra);
tnxpos.c:    y = -cosdec * sinra;
tnxpos.c:	dphi = ra - dpi;
tnxpos.c:	phi = phi - twopi;
tnxpos.c:    else if (phi < -dpi)
tnxpos.c:	    theta = dpi - theta;
tnxpos.c:	if (theta < -dhalfpi)
tnxpos.c:	    theta = -dpi - theta;
tnxpos.c:		theta = -acos (sqrt(x * x + y * y));
tnxpos.c:	r = wcs->rodeg * cos (theta) / s;
tnxpos.c:	if (wcs->lngcor == NULL && wcs->latcor == NULL) {
tnxpos.c:	    if (wcs->coorflip) {
tnxpos.c:		x = -r * cos (phi);
tnxpos.c:		y = -r * cos (phi);
tnxpos.c:	    ym = -r * cos (phi);
tnxpos.c:		if (wcs->lngcor != NULL) {
tnxpos.c:		    f = x + wf_gseval (wcs->lngcor, x, y) - xm;
tnxpos.c:		    fx = wf_gsder (wcs->lngcor, x, y, 1, 0);
tnxpos.c:		    fy = wf_gsder (wcs->lngcor, x, y, 0, 1);
tnxpos.c:		    f = x - xm;
tnxpos.c:		if (wcs->latcor != NULL) {
tnxpos.c:		    g = y + wf_gseval (wcs->latcor, x, y) - ym;
tnxpos.c:		    gx = wf_gsder (wcs->latcor, x, y, 1, 0);
tnxpos.c:		    gy = wf_gsder (wcs->latcor, x, y, 0, 1);
tnxpos.c:		    g = y - ym;
tnxpos.c:		denom = fx * gy - fy * gx;
tnxpos.c:		dx = (-f * gy + g * fy) / denom;
tnxpos.c:		dy = (-g * fx + f * gx) / denom;
tnxpos.c:		if (MAX(MAX(fabs(dx),fabs(dy)),MAX(fabs(f),fabs(g))) < 2.80e-8)
tnxpos.c:	    if (wcs->coorflip) {
tnxpos.c:    if (wcs->rotmat) {
tnxpos.c:	*xpix = x * wcs->dc[0] + y * wcs->dc[1];
tnxpos.c:	*ypix = x * wcs->dc[2] + y * wcs->dc[3];
tnxpos.c:	if (wcs->rot!=0.0) {
tnxpos.c:	    double cosr = cos (degrad (wcs->rot));
tnxpos.c:	    double sinr = sin (degrad (wcs->rot));
tnxpos.c:	    *ypix = y * cosr - x * sinr;
tnxpos.c:	if (wcs->xinc != 0.)
tnxpos.c:	    *xpix = *xpix / wcs->xinc;
tnxpos.c:	if (wcs->yinc != 0.)
tnxpos.c:	    *ypix = *ypix / wcs->yinc;
tnxpos.c:    *xpix = *xpix + wcs->xrefpix;
tnxpos.c:    *ypix = *ypix + wcs->yrefpix;
tnxpos.c:/* TNXCLOSE -- free up the distortion surface pointers */
tnxpos.c:    if (wcs->lngcor != NULL)
tnxpos.c:	wf_gsclose (wcs->lngcor);
tnxpos.c:    if (wcs->latcor != NULL)
tnxpos.c:	wf_gsclose (wcs->latcor);
tnxpos.c: * wfgsurfit.x -- surface fitting package used by wcs function drivers.
tnxpos.c:/* wf_gsopen -- decode the longitude / latitude or ra / dec mwcs attribute
tnxpos.c:	    coeff[npar-1] = dval;
tnxpos.c:/* wf_gsclose -- procedure to free the surface descriptor */
tnxpos.c:	if (sf->xbasis != NULL)
tnxpos.c:	    free (sf->xbasis);
tnxpos.c:	if (sf->ybasis != NULL)
tnxpos.c:	    free (sf->ybasis);
tnxpos.c:	if (sf->coeff != NULL)
tnxpos.c:	    free (sf->coeff);
tnxpos.c:/* wf_gseval -- procedure to evaluate the fitted surface at a single point.
tnxpos.c: * the wf->ncoeff coefficients are stored in the vector pointed to by sf->coeff.
tnxpos.c:    switch (sf->type) {
tnxpos.c:            wf_gsb1cheb (x, sf->xorder, sf->xmaxmin, sf->xrange, sf->xbasis);
tnxpos.c:            wf_gsb1cheb (y, sf->yorder, sf->ymaxmin, sf->yrange, sf->ybasis);
tnxpos.c:            wf_gsb1leg (x, sf->xorder, sf->xmaxmin, sf->xrange, sf->xbasis);
tnxpos.c:            wf_gsb1leg (y, sf->yorder, sf->ymaxmin, sf->yrange, sf->ybasis);
tnxpos.c:            wf_gsb1pol (x, sf->xorder, sf->xbasis);
tnxpos.c:            wf_gsb1pol (y, sf->yorder, sf->ybasis);
tnxpos.c:    if (sf->xorder > sf->yorder)
tnxpos.c:	maxorder = sf->xorder + 1;
tnxpos.c:	maxorder = sf->yorder + 1;
tnxpos.c:    xorder = sf->xorder;
tnxpos.c:    for (i = 0; i < sf->yorder; i++) {
tnxpos.c:	    accum = accum + sf->coeff[ii] * sf->xbasis[k];
tnxpos.c:	accum = accum * sf->ybasis[i];
tnxpos.c:           are not calculated if sf->xterms = no. */
tnxpos.c:        if (sf->xterms == TNX_XNONE)
tnxpos.c:        else if (sf->xterms == TNX_XHALF) {
tnxpos.c:            if ((i + 1 + sf->xorder + 1) > maxorder)
tnxpos.c:                xorder = xorder - 1;
tnxpos.c:/* TNX_GSCOEFF -- procedure to fetch the number and magnitude of the coefficients
tnxpos.c: * if the sf->xterms = wf_xbi (yes) then the number of coefficients will be
tnxpos.c: * (sf->xorder * sf->yorder); if wf_xterms is wf_xtri then the number
tnxpos.c: * of coefficients will be (sf->xorder *  sf->yorder - order *
tnxpos.c: * (order - 1) / 2) where order is the minimum of the x and yorders;  if
tnxpos.c: * sf->xterms = TNX_XNONE then the number of coefficients will be
tnxpos.c: * (sf->xorder + sf->yorder - 1).
tnxpos.c:    ncoeff = sf->ncoeff;
tnxpos.c:	coeff[i] = sf->coeff[i];
tnxpos.c:/* wf_gsder -- procedure to calculate a new surface which is a derivative of
tnxpos.c:    nxder = MIN (nxd, sf1->xorder - 1);
tnxpos.c:    nyder = MIN (nyd, sf1->yorder - 1);
tnxpos.c:    sf2->type = sf1->type;
tnxpos.c:    if (sf2->type == TNX_LEGENDRE ||
tnxpos.c:	sf2->type == TNX_CHEBYSHEV ||
tnxpos.c:	sf2->type == TNX_POLYNOMIAL) {
tnxpos.c:	sf2->xterms = sf1->xterms;
tnxpos.c:	switch (sf2->xterms) {
tnxpos.c:		    sf2->xorder = 1;
tnxpos.c:		    sf2->yorder = 1;
tnxpos.c:		    sf2->ncoeff = 1;
tnxpos.c:		    sf2->xorder = MAX (1, sf1->xorder - nxder);
tnxpos.c:		    sf2->yorder = 1;
tnxpos.c:		    sf2->ncoeff = sf2->xorder;
tnxpos.c:		    sf2->xorder = 1;
tnxpos.c:		    sf2->yorder = MAX (1, sf1->yorder - nyder);
tnxpos.c:		    sf2->ncoeff = sf2->yorder;
tnxpos.c:		maxorder1 = MAX (sf1->xorder+1, sf1->yorder+1);
tnxpos.c:		order = MAX(1, MIN(maxorder1-1-nyder-nxder,sf1->xorder-nxder));
tnxpos.c:		sf2->xorder = order;
tnxpos.c:		order = MAX(1, MIN(maxorder1-1-nyder-nxder,sf1->yorder-nyder));
tnxpos.c:		sf2->yorder = order;
tnxpos.c:		order = MIN (sf2->xorder, sf2->yorder);
tnxpos.c:		sf2->ncoeff = sf2->xorder * sf2->yorder - (order*(order-1)/2);
tnxpos.c:		sf2->xorder = MAX (1, sf1->xorder - nxder);
tnxpos.c:		sf2->yorder = MAX (1, sf1->yorder - nyder);
tnxpos.c:		sf2->ncoeff = sf2->xorder * sf2->yorder;
tnxpos.c:	sf2->xrange = sf1->xrange;
tnxpos.c:	sf2->xmaxmin = sf1->xmaxmin;
tnxpos.c:	sf2->yrange = sf1->yrange;
tnxpos.c:	sf2->ymaxmin = sf1->ymaxmin;
tnxpos.c:	fprintf (stderr, "TNX_GSDER: unknown surface type %d\n", sf2->type);
tnxpos.c:    nbytes = sf2->ncoeff * sizeof(double);
tnxpos.c:    sf2->coeff = (double *) malloc (nbytes);
tnxpos.c:    nbytes = sf2->xorder * sizeof(double);
tnxpos.c:    sf2->xbasis = (double *) malloc (nbytes);
tnxpos.c:    nbytes = sf2->yorder * sizeof(double);
tnxpos.c:    sf2->ybasis = (double *) malloc (nbytes);
tnxpos.c:    nbytes = sf1->ncoeff * sizeof(double);
tnxpos.c:    switch (sf2->xterms) {
tnxpos.c:	    ptr2 = sf2->coeff + (sf2->yorder - 1) * sf2->xorder;
tnxpos.c:	    ptr1 = coeff + (sf1->yorder - 1) * sf1->xorder;
tnxpos.c:	    for (i = sf1->yorder - 1; i >= nyder; i--) {
tnxpos.c:		for (j = i; j >= i-nyder+1; j--) {
tnxpos.c:		    for (k = 0; k < sf2->xorder; k++)
tnxpos.c:		for (j = sf1->xorder; j >= nxder+1; j--) {
tnxpos.c:		    for (k = j; k >= j-nxder+1; k--)
tnxpos.c:			ptr1[j-1] = ptr1[j-1] * (double)(k - 1);
tnxpos.c:		for (j = 0; j < sf2->xorder; j++)
tnxpos.c:		ptr2 = ptr2 - sf2->xorder;
tnxpos.c:		ptr1 = ptr1 - sf1->xorder;
tnxpos.c:	    maxorder1 = MAX (sf1->xorder + 1, sf1->yorder + 1);
tnxpos.c:	    maxorder2 = MAX (sf2->xorder + 1, sf2->yorder + 1);
tnxpos.c:	    ptr2 = sf2->coeff + sf2->ncoeff;
tnxpos.c:	    ptr1 = coeff + sf1->ncoeff;
tnxpos.c:	    for (i = sf1->yorder; i >= nyder+1; i--) {
tnxpos.c:		nmove1 = MAX (0, MIN (maxorder1 - i, sf1->xorder));
tnxpos.c:		nmove2 = MAX (0, MIN (maxorder2 - i + nyder, sf2->xorder));
tnxpos.c:		ptr1 = ptr1 - nmove1;
tnxpos.c:		ptr2 = ptr2 - nmove2;
tnxpos.c:		for (j = i; j > i - nyder + 1; j--) {
tnxpos.c:			ptr1[nxder+k] = ptr1[nxder+k] * (double)(j-1);
tnxpos.c:		for (j = nmove1; j >= nxder+1; j--) {
tnxpos.c:		    for (k = j;  k >= j-nxder+1; k--)
tnxpos.c:			ptr1[j-1] = ptr1[j-1] * (double)(k - 1);
tnxpos.c:		sf2->coeff[0] = 0.0;
tnxpos.c:		ptr2 = sf2->coeff + sf2->ncoeff - 1;
tnxpos.c:		for (j = sf1->xorder; j >= nxder+1; j--) {
tnxpos.c:		    for (k = j; k >= j - nxder + 1; k--)
tnxpos.c:			ptr1[j-1] = ptr1[j-1] * (double)(k - 1);
tnxpos.c:		    ptr2[0] = ptr1[j-1];
tnxpos.c:		    ptr2 = ptr2 - 1;
tnxpos.c:		ptr1 = coeff + sf1->ncoeff - 1;
tnxpos.c:		ptr2 = sf2->coeff;
tnxpos.c:		for (i = sf1->yorder; i >= nyder + 1; i--) {
tnxpos.c:		    for (j = i; j >= i - nyder + 1; j--)
tnxpos.c:			*ptr1 = *ptr1 * (double)(j - 1);
tnxpos.c:		    ptr1 = ptr1 - 1;
tnxpos.c:		for (i = 0; i < sf2->ncoeff; i++)
tnxpos.c:    if (sf2->type != TNX_POLYNOMIAL) { 
tnxpos.c:	norm = pow (sf2->xrange, (double)nxder) *
tnxpos.c:	       pow (sf2->yrange, (double)nyder);
tnxpos.c:/* wf_gsrestore -- procedure to restore the surface fit encoded in the
tnxpos.c:   of the double array fit, followed by the wf->ncoeff surface coefficients.
tnxpos.c:	fprintf (stderr, "wf_gsrestore: illegal x range %f-%f\n",xmin,xmax);
tnxpos.c:	fprintf (stderr, "wf_gsrestore: illegal y range %f-%f\n",ymin,ymax);
tnxpos.c:	sf->xorder = xorder;
tnxpos.c:	sf->xrange = 2.0 / (xmax - xmin);
tnxpos.c:	sf->xmaxmin =  - (xmax + xmin) / 2.0;
tnxpos.c:	sf->yorder = yorder;
tnxpos.c:	sf->yrange = 2.0 / (ymax - ymin);
tnxpos.c:	sf->ymaxmin =  - (ymax + ymin) / 2.0;
tnxpos.c:	sf->xterms = fit[TNX_SAVEXTERMS];
tnxpos.c:	switch (sf->xterms) {
tnxpos.c:		sf->ncoeff = sf->xorder + sf->yorder - 1;
tnxpos.c:		sf->ncoeff = sf->xorder * sf->yorder - order * (order-1) / 2;
tnxpos.c:		sf->ncoeff = sf->xorder * sf->yorder;
tnxpos.c:    sf->type = surface_type;
tnxpos.c:    sf->coeff = (double *) malloc (sf->ncoeff*sizeof (double));
tnxpos.c:    for (i = 0; i < sf->ncoeff; i++)
tnxpos.c:	sf->coeff[i] = fit[TNX_SAVECOEFF+i];
tnxpos.c:    sf->xbasis = (double *) malloc (sf->xorder*sizeof (double));
tnxpos.c:    sf->ybasis = (double *) malloc (sf->yorder*sizeof (double));
tnxpos.c:/* wf_gsb1pol -- procedure to evaluate all the non-zero polynomial functions
tnxpos.c:	basis[i] = x * basis[i-1];
tnxpos.c:/* wf_gsb1leg -- procedure to evaluate all the non-zero legendre functions for
tnxpos.c:        basis[i] = ((2.0 * ri - 1.0) * xnorm * basis[i-1] -
tnxpos.c:                       (ri - 1.0) * basis[i-2]) / ri;
tnxpos.c:/* wf_gsb1cheb -- procedure to evaluate all the non-zero chebyshev function
tnxpos.c:	basis[i] = 2. * xnorm * basis[i-1] - basis[i-2];
tnxpos.c:    wcs->prjcode = WCS_TNX;
tnxpos.c:    wcs->lngcor = wf_gspset (xorder, yorder, xterms, coeff);
tnxpos.c:    ycoeff = coeff + wcs->lngcor->ncoeff;
tnxpos.c:    wcs->latcor = wf_gspset (xorder, yorder, xterms, ycoeff);
tnxpos.c:/* wf_gspset -- procedure to set the surface descriptor for use by the
tnxpos.c:	sf->xorder = xorder;
tnxpos.c:	sf->xrange = 2.0 / (xmax - xmin);
tnxpos.c:	sf->xmaxmin =  -(xmax + xmin) / 2.0;
tnxpos.c:	sf->yorder = yorder;
tnxpos.c:	sf->yrange = 2.0 / (ymax - ymin);
tnxpos.c:	sf->ymaxmin =  - (ymax + ymin) / 2.0;
tnxpos.c:	sf->xterms = xterms;
tnxpos.c:	switch (sf->xterms) {
tnxpos.c:		sf->ncoeff = sf->xorder + sf->yorder - 1;
tnxpos.c:		sf->ncoeff = sf->xorder * sf->yorder - order * (order-1) / 2;
tnxpos.c:		sf->ncoeff = sf->xorder * sf->yorder;
tnxpos.c:    sf->type = surface_type;
tnxpos.c:    sf->coeff = (double *) malloc (sf->ncoeff*sizeof (double));
tnxpos.c:    for (i = 0; i < sf->ncoeff; i++)
tnxpos.c:	sf->coeff[i] = coeff[i];
tnxpos.c:    sf->xbasis = (double *) malloc (sf->xorder*sizeof (double));
tnxpos.c:    sf->ybasis = (double *) malloc (sf->yorder*sizeof (double));
tnxpos.c: * Dec 10 1999	Compute wcs->rot using wcsrotset() in tnxinit()
tnxpos.c: * Feb 14 2001	Fixed off-by-one bug in legendre evaluation (Mike Jarvis)
tnxpos.c: * Apr 11 2002	Fix bug when .-terminated substring in wf_gsopen()
ty2read.c: *** Harvard-Smithsonian Center for Astrophysics
ty2read.c: *** Copyright (C) 2000-2007
ty2read.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
ty2read.c:/* TY2READ -- Read Tycho 2 Star Catalog stars from CDROM */
ty2read.c:double	ddec;		/* Search half-width in declination in degrees */
ty2read.c:    star->num = 0.0;
ty2read.c:	printf ("catalog	Tycho-2\n");
ty2read.c:	printf ("----------	------------	------------");
ty2read.c:	printf ("	-----	-----");
ty2read.c:	    printf ("	-----	-----");
ty2read.c:	printf ("	------	------	------\n");
ty2read.c:	    fprintf (stderr,"TY2READ:  no Tycho 2 region for %.2f-%.2f %.2f %.2f\n",
ty2read.c:			istar1, istar2-1);
ty2read.c:		num = star->num;
ty2read.c:		magb = star->xmag[0];
ty2read.c:		magv = star->xmag[1];
ty2read.c:		magbe = star->xmag[2];
ty2read.c:		magve = star->xmag[3];
ty2read.c:		mag = star->xmag[magsort];
ty2read.c:		    rapm = star->rapm;
ty2read.c:		    decpm = star->decpm;
ty2read.c:		    ra = star->ra;
ty2read.c:		    dec = star->dec;
ty2read.c:		isp = (1000 * (int) star->isp[0]) + (int)star->isp[1]; */
ty2read.c:			    gmag[2][nstar] = star->xmag[2];
ty2read.c:			    gmag[3][nstar] = star->xmag[3];
ty2read.c:				gmag[2][farstar] = star->xmag[2];
ty2read.c:				gmag[3][farstar] = star->xmag[3];
ty2read.c:			    gmag[2][faintstar] = star->xmag[2];
ty2read.c:			    gmag[3][faintstar] = star->xmag[3];
ty2read.c:			     nstar,jstar,starcat->nstars);
ty2read.c:	    ntot = ntot + starcat->nstars;
ty2read.c:		 	 ireg+1,nreg,nstar,jstar,starcat->nstars,regnum[ireg]);
ty2read.c:/* TY2RNUM -- Read HST Guide Star Catalog stars from CDROM */
ty2read.c:    star->num = 0.0;
ty2read.c:	if (gnum[jstar]-(double)rnum > 0.0000001) {
ty2read.c:	    nstar = istar2 - istar1 + 1;
ty2read.c:		    if (fabs (gnum[jstar] - star->num) < 0.0000005)
ty2read.c:	num = star->num;
ty2read.c:	ra = star->ra;
ty2read.c:	dec = star->dec;
ty2read.c:	rapm = star->rapm;
ty2read.c:	decpm = star->decpm;
ty2read.c:	magb = star->xmag[0];
ty2read.c:	magv = star->xmag[1];
ty2read.c:	isp = (1000 * (int) star->isp[0]) + (int)star->isp[1]; */
ty2read.c:	    gmag[2][jstar] = star->xmag[2];
ty2read.c:	    gmag[3][jstar] = star->xmag[3];
ty2read.c:		     num, ra, dec, magb, magv, star->isp);
ty2read.c:/* TY2BIN -- Read Tycho 2 Star Catalog stars from CDROM */
ty2read.c:    double ddec;	/* Search half-width in declination in degrees */
ty2read.c:    sysout = wcs->syswcs;
ty2read.c:    eqout = wcs->equinox;
ty2read.c:    epout = wcs->epoch;
ty2read.c:    star->num = 0.0;
ty2read.c:	    fprintf (stderr,"TY2BIN:  no Tycho 2 region for %.2f-%.2f %.2f %.2f\n",
ty2read.c:			istar1, istar2-1); */
ty2read.c:		num = star->num;
ty2read.c:		ra = star->ra;
ty2read.c:		dec = star->dec;
ty2read.c:		magb = star->xmag[0];
ty2read.c:		magv = star->xmag[1];
ty2read.c:		mag = star->xmag[magsort];
ty2read.c:			    flux = magscale * exp (logt * (-mag / 2.5));
ty2read.c:			     nstar,jstar,starcat->nstars);
ty2read.c:	    ntot = ntot + starcat->nstars;
ty2read.c:		 	 ireg+1,nreg,nstar,jstar,starcat->nstars,regnum[ireg]);
ty2read.c:/* TY2REGN -- read the range of stars in a region from the Tycho 2 Catalog
ty2read.c:    line = buffer + ((region - 1) * indnchar);
ty2read.c:/* TY2REG -- search the Tycho 2 Catalog index table for fields
ty2read.c:    nsrch = ir2 - ir1 + 1;
ty2read.c:	fprintf (stderr,"TY2REG: searching %d regions: %d - %d\n",nsrch,ir1,ir2);
ty2read.c:	nsrch1 = jr2 - jr1 + 1;
ty2read.c:	    fprintf (stderr,"TY2REG: searching %d regions: %d - %d\n",nsrch1,jr1,jr2);
ty2read.c:	fprintf(stderr,"TY2REG: RA: %.5f - %.5f, Dec: %.5f - %.5f\n",ra1,ra2,dec1,dec2);
ty2read.c:	for (irow = ir1 - 1; irow < ir2; irow++) {
ty2read.c:		decmin = declow - 0.1;
ty2read.c:		decmin = dechi - 0.1;
ty2read.c:		ralow = atof (line + 15) - 0.1;
ty2read.c:			    nstar[nrgn] = num2 - num1;
ty2read.c:			    nstar[nrgn] = num2 - num1;
ty2read.c:/* Handle wrap-around through the equator */
ty2read.c:/*  TY2ZONE -- find the zone number where a declination can be found */
ty2read.c:/* TY2OPEN -- Open Tycho 2 catalog file, returning number of entries */
ty2read.c:    sc->byteswapped = 0;
ty2read.c:	sc->nbent = 208;
ty2read.c:	sc->nbent = 207;
ty2read.c:    sc->nstars = lfile / sc->nbent;
ty2read.c:	strcpy (sc->isfil, ty2file);
ty2read.c:	strncpy (sc->isfil, ty2file, 23);
ty2read.c:    sc->inform = 'J';
ty2read.c:    sc->coorsys = WCS_J2000;
ty2read.c:    sc->epoch = 2000.0;
ty2read.c:    sc->equinox = 2000.0;
ty2read.c:    sc->ifcat = fcat;
ty2read.c:    sc->sptype = 2;
ty2read.c:    /* Tycho 2 stars are not RA-sorted within regions */
ty2read.c:    sc->rasorted = 0;
ty2read.c:    lread = nread * sc->nbent;
ty2read.c:    lskip = (nstar - 1) * sc->nbent;
ty2read.c:    sc->catdata = NULL;
ty2read.c:    if ((sc->catdata = calloc (1, lread+1)) != NULL) {
ty2read.c:	nr = fread (sc->catdata, 1, lread, fcat);
ty2read.c:	sc->catlast = sc->catdata + lread;
ty2read.c:	fprintf (stderr,"TY2OPEN: Cannot allocate %d-byte buffer.\n", lread);
ty2read.c:    sc->istar = nstar;
ty2read.c:    fclose (sc->ifcat);
ty2read.c:    if (sc->catdata != NULL)
ty2read.c:	free (sc->catdata);
ty2read.c:/* TY2STAR -- Get Tycho 2 catalog entry for one star;
ty2read.c:    if (sc->ifcat == NULL) {
ty2read.c:    if (istar > sc->nstars) {
ty2read.c:		 istar, sc->nstars);
ty2read.c:	line = sc->catdata + ((istar - sc->istar) * sc->nbent);
ty2read.c:	if (line >= sc->catlast) {
ty2read.c:	line = sc->catdata;
ty2read.c:    if (sc->nbent > sc->catlast-line) {
ty2read.c:		 sc->catlast - line, sc->nbent, istar);
ty2read.c:    st->num = regnum + (0.0001 * starnum) + (0.00001 * multnum);
ty2read.c:	fprintf (stderr, "TY2STAR:  No position for star %010.5f\n", st->num);
ty2read.c:    st->ra = atof (line+15);
ty2read.c:    st->dec = atof (line+28);
ty2read.c:    st->rapm = (atof (line+41) / 3600000.0) / cosdeg (st->dec);
ty2read.c:    st->decpm = atof (line+49) / 3600000.0;
ty2read.c:    st->xmag[0] = atof (line+110);
ty2read.c:    st->xmag[2] = atof (line+117);
ty2read.c:    st->xmag[1] = atof (line+123);
ty2read.c:    st->xmag[3] = atof (line+130);
ty2read.c:    st->isp[0] = (char)0;
ty2read.c:    st->isp[1] = (char)0;
ty2read.c:    bv2sp (NULL, st->xmag[1], st->xmag[0], st->isp); */
ty2read.c:/* TY2SIZE -- return size of Tycho 2 catalog file in bytes */
ty2read.c:	return (-1);
ty2read.c:	filesize = -1;
ty2read.c: * Sep 25 2000	Set sc->sptype to 2 to indicate presence of spectral type
ty2read.c: * Sep 29 2003	Rewrite zone computation to deal with +-90 correctly
ty2read.c: * Dec  1 2003	Add missing tab to n=-1 header
ty2read.c: * Oct  5 2006	Fix order of magnitudes to Bt-Vt from Vt-Bt
uacread.c: *** Harvard-Smithsonian Center for Astrophysics
uacread.c: *** Copyright (C) 1996-2007
uacread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
uacread.c:/* USNO A-2.0 directory pathname; replaced by UA2_PATH environment variable
uacread.c:/* Uncomment following line to use ESO USNO-A server for UA2
uacread.c:static char ua2path[64]="http://archive.eso.org/skycat/servers/usnoa-server";
uacread.c:/* USNO SA-2.0 directory pathname; replaced by USA2_PATH environment variable
uacread.c:/* USNO SA-1.0 directory pathname; replaced by USA1_PATH environment variable
uacread.c:/* USNO A-1.0 directory pathname; replaced by UA1_PATH environment variable
uacread.c:/* Disks for 24 zones of USNO A-1.0 Catalog */
uacread.c:/* Disks for 24 zones of USNO A-2.0 Catalog */
uacread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
uacread.c:/* USACREAD -- Read USNO SA Catalog stars from CDROM */
uacread.c:double	ddec;		/* Search half-width in declination in degrees */
uacread.c:/* UACREAD -- Read USNO A or SA Catalog stars from CDROM */
uacread.c:double	ddec;		/* Search half-width in declination in degrees */
uacread.c:	printf ("-------------	------------	------------	");
uacread.c:	printf ("-----	-----	------\n");
uacread.c:		nread = istar2 - istar1 + 1;
uacread.c:				    CatNum (ucat, -13, 0, num, numstr);
uacread.c:	    dstar = (unum[jnum] - znum) * 100000000.0;
uacread.c:/* USACBIN -- Fill a FITS WCS image with USNO SA Catalog stars */
uacread.c:/* UACBIN -- Fill a FITS WCS image with USNO A or SA Catalog stars */
uacread.c:    double ddec;	/* Search half-width in declination in degrees */
uacread.c:    sysout = wcs->syswcs;
uacread.c:    eqout = wcs->equinox;
uacread.c:    epout = wcs->epoch;
uacread.c:		nread = istar2 - istar1 + 1;
uacread.c:					flux = magscale * exp (logt * (-mag / 2.5));
uacread.c:/* UACZONES -- figure out which UA zones will need to be searched */
uacread.c:	fprintf(stderr,"UACZONES:  %d zones: %d - %d\n",nrgn,zones[0],zones[i-1]);
uacread.c:	fprintf(stderr,"UACZONES: RA: %.5f - %.5f, Dec: %.5f - %.5f\n",ra1,ra2,dec1,dec2);
uacread.c:/* UACRA -- returns right ascension in degrees from the UA star structure */
uacread.c:/* UACDEC -- returns the declination in degrees from the UA star structure */
uacread.c:    return ((double) (decsec - 32400000) / 360000.0);
uacread.c:/* UACMAGR -- returns the red magnitude from the UA star structure */
uacread.c:	return ((double) (-magetc % 1000) * 0.1);
uacread.c:/* UACMAGB -- returns the blue magnitude from the UA star structure */
uacread.c:	return ((double) ((-magetc / 1000) % 1000) * 0.1);
uacread.c:/* UACMAGERR -- returns 1 if magnitude is uncertain from UA star structure */
uacread.c:	return ((-magetc / 1000000000) % 10);
uacread.c:/* UACGSC -- returns 1 if UA star is in the HST Guide Star Catalog */
uacread.c:/* UACPLATE -- returns the plate number from the UA star structure */
uacread.c:	return ((-magetc / 1000000) % 1000);
uacread.c:/* UACZONE -- find the UA zone number where a declination can be found */
uacread.c:/* UACSRA -- Find UA star closest to specified right ascension */
uacread.c:	    rdiff = ra1 - ra;
uacread.c:	    rdiff1 = ra1 - rax;
uacread.c:	    rdiff2 = ra - rax;
uacread.c:	    sdiff = (double)(istar - istar1) * rdiff1 / rdiff;
uacread.c:/* UACOPEN -- Open UA Catalog zone catalog, returning number of entries */
uacread.c:/* Check to see if byte-swapping is necessary */
uacread.c:/* UACPATH -- Get UA Catalog region file pathname */
uacread.c:	fprintf (stderr, "UACPATH: zone %d out of range 0-1725\n",zn);
uacread.c:	return (-1);
uacread.c:	sprintf (path,"%s/%s/zone%04d.cat", cdroot, cdname[icd-1], zn);
uacread.c:/* UACSTAR -- Get UA catalog entry for one star; return 0 if successful */
uacread.c:	return (-1);
uacread.c:    nbskip = 12 * (istar - 1);
uacread.c:	return (-1);
uacread.c:	return (-2);
uacread.c:/* UACSWAP -- Reverse bytes of UA Catalog entry */
uacread.c:char *string;	/* Start of vector of 4-byte ints */
uacread.c: * Dec 11 1996	Set ra<0 to ra+360 and ra>360 to ra-360
uacread.c: * Mar 12 1997	Set paths for SA-1.0 and multiple CDROM A-1.0
uacread.c: * Jun 24 1998	Initialize byte-swapping flag in UACOPEN()
uacread.c: * Oct 26 1998	Fix bug in search algorith for non-J2000 searches
uacread.c: * Nov 20 1998	Add support for USNO A-2.0 and SA-2.0 catalogs
uacread.c: * Nov 24 1998	Fix bug reading SA-2.0 catalog
uacread.c: * Sep 21 2001	Add commented-out URL of ESO web catalog server
uacread.c: * Dec  1 2003	Add missing tab to n=-1 header
ubcread.c: *** Harvard-Smithsonian Center for Astrophysics
ubcread.c: *** Copyright (C) 2003-2007
ubcread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
ubcread.c: * Subroutines to read from the USNO-B1.0 catalog
ubcread.c:/* USNO B-1.0 directory pathname; replaced by UB1_PATH environment variable.
ubcread.c:static int minid = 0; /* Minimum number of plate ID's (<0 excludes Tycho-2) */
ubcread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
ubcread.c:/* UBCREAD -- Return USNO B1.0 or YB6 sources in specified region */
ubcread.c:double	ddec;		/* Search half-width in declination in degrees */
ubcread.c:	magsort = sortmag - 1;
ubcread.c:	    printf ("------------	------------	------------	");
ubcread.c:	    printf ("-----	-----	-----	-----	-----	");
ubcread.c:	    printf ("----	----	----	----	");
ubcread.c:	    printf ("-----	-----	--	--	---	------\n");
ubcread.c:	    printf ("------------	------------	------------	");
ubcread.c:	    printf ("-----	-----	-----	-----	-----	-----	");
ubcread.c:	    printf ("-----	--	--	---	------\n");
ubcread.c:			istar1 = istar1 - 1;
ubcread.c:		nread = istar2 - istar1 + 1;
ubcread.c:			    if (minid < 0 && nid < -minid)
ubcread.c:				CatNum (ucat, -12, 0, num, numstr);
ubcread.c:/* UBCRNUM -- Return USNO-B1.0 sources with specified ID numbers */
ubcread.c:	    dstar = (unum[jnum] - znum) * 10000000.0;
ubcread.c:/* UBCBIN -- Fill FITS WCS image with USNO-B1.0 sources */
ubcread.c:    double ddec;	/* Search half-width in declination in degrees */
ubcread.c:    sysout = wcs->syswcs;
ubcread.c:    eqout = wcs->equinox;
ubcread.c:    epout = wcs->epoch;
ubcread.c:	magsort = sortmag - 1;
ubcread.c:			istar1 = istar1 - 1;
ubcread.c:		nread = istar2 - istar1 + 1;
ubcread.c:			    if (minid < 0 && nid < -minid)
ubcread.c:				    flux = magscale * exp (logt * (-mag / 2.5));
ubcread.c:/* UBCZONES -- figure out which UB zones will need to be searched */
ubcread.c:	fprintf(stderr,"UBCZONES:  %d zones: %d - %d\n",nrgn,zones[0],zones[i-1]);
ubcread.c:	fprintf(stderr,"UBCZONES: RA: %.5f - %.5f, Dec: %.5f - %.5f\n",ra1,ra2,dec1,dec2);
ubcread.c:/* UBCRA -- returns right ascension in degrees from the UB star structure */
ubcread.c:/* UBCDEC -- returns the declination in degrees from the UB star structure */
ubcread.c:    return ((double) (decsec - 32400000) / 360000.0);
ubcread.c:/* UBCMAG -- returns a magnitude from the UBC star structure */
ubcread.c:	xmag = (double) (-magetc % 10000) * 0.01;
ubcread.c:/* UBCPRA -- returns RA proper motion in arcsec/year from UBC star structure */
ubcread.c:	pm = (double) (-magetc % 10000);
ubcread.c:    pm = ((pm * 0.002) - 10.0) / 3600.0;
ubcread.c:/* UBCPDEC -- returns Dec proper motion in arcsec/year from UBC star structure */
ubcread.c:	pm = (double) ((-magetc % 100000000) / 10000);
ubcread.c:    pm = ((pm * 0.002) - 10.0) / 3600.0;
ubcread.c:/* UBCPMQ -- returns proper motion probability (1-9) */
ubcread.c:	return (-magetc / 100000000);
ubcread.c:/* UBCMAGERR -- returns 1 if magnitude is uncertain from UB star structure */
ubcread.c:	return ((-magetc / 1000000000) % 10);
ubcread.c:/* UBCNDET -- returns number of detections; 0 = Tycho-2 Catalog */
ubcread.c:	return (-magetc / 100000000);
ubcread.c:/* UBCSG -- returns closeness to star PSF (0-11) */
ubcread.c:	return (-magetc / 100000000);
ubcread.c:/* UBCZONE -- find the UB zone number where a declination can be found */
ubcread.c:/* UBCSRA -- Find UB star closest to specified right ascension */
ubcread.c:	    rdiff = ra1 - ra;
ubcread.c:	    rdiff1 = ra1 - rax;
ubcread.c:	    rdiff2 = ra - rax;
ubcread.c:	    sdiff = (double)(istar - istar1) * rdiff1 / rdiff;
ubcread.c:/* UBCOPEN -- Open UB Catalog zone catalog, returning number of entries */
ubcread.c:/* Check to see if byte-swapping is necessary */
ubcread.c:/* UBCPATH -- Get UB Catalog region file pathname */
ubcread.c:	fprintf (stderr, "UBCPATH: zone %d out of range 0-1799\n",zn);
ubcread.c:	return (-1);
ubcread.c:    /* Set path for USNO-B1.0 zone catalog */
ubcread.c:/* UBCSTAR -- Get UB catalog entry for one star; return 0 if successful */
ubcread.c:	return (-1);
ubcread.c:    nbskip = nbent * (istar - 1);
ubcread.c:	return (-1);
ubcread.c:	return (-2);
ubcread.c:/* UBCSWAP -- Reverse bytes of UB Catalog entry */
ubcread.c:char *string;	/* Start of vector of 4-byte ints */
ubcread.c: * Dec  1 2003	Add missing tab to n=-1 header
ubcread.c: * Nov 19 2004	Return galaxy/star type code (qsg=0-11) in upmni vector
ucacread0.c: *** Harvard-Smithsonian Center for Astrophysics
ucacread0.c: *** Copyright (C) 2003-2011
ucacread0.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
ucacread0.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
ucacread0.c:/* UCACREAD -- Read UCAC Star Catalog stars */
ucacread0.c:double	ddec;		/* Search half-width in declination in degrees */
ucacread0.c:    else if (cdec - ddec < -90.0)
ucacread0.c:	magsort = nmag - 1;
ucacread0.c:	magsort = sortmag - 1;
ucacread0.c:    star->num = 0.0;
ucacread0.c:	fprintf (stderr,"UCACREAD:  no UCAC zone for %.2f-%.2f %.2f %.2f\n",
ucacread0.c:	    printf ("----------	------------	------------	");
ucacread0.c:	    printf ("-----	------	------	------\n");
ucacread0.c:	    printf ("----------	------------	------------    ");
ucacread0.c:	    printf ("------	------	-----	-----	-----	");
ucacread0.c:	    printf ("-----	-----	------	------	-----	-----	");
ucacread0.c:	    printf ("--	--	------\n");
ucacread0.c:	    printf ("----------	------------	------------	");
ucacread0.c:	    printf ("------	------	-----	------	-----	");
ucacread0.c:	    printf ("-----	-----	-----	-----	-----	");
ucacread0.c:	    printf ("-----	-----	-----	------	------	");
ucacread0.c:	    printf ("--	--	------\n");
ucacread0.c:			istar1 = istar1 - 5;
ucacread0.c:		    istar2 = starcat->nstars;
ucacread0.c:		    if (istar2 < starcat->nstars - 5)
ucacread0.c:			istar2 = starcat->nstars;
ucacread0.c:		nread = istar2 - istar1 + 1;
ucacread0.c:		    num = star->num;
ucacread0.c:		    mag = star->xmag[magsort];
ucacread0.c:			ra = star->ra;
ucacread0.c:			dec = star->dec;
ucacread0.c:			rapm = star->rapm;
ucacread0.c:			decpm = star->decpm;
ucacread0.c:			errra = star->errra;
ucacread0.c:			errdec = star->errdec;
ucacread0.c:			errpmr = star->errpmr;
ucacread0.c:			errpmd = star->errpmd;
ucacread0.c:			nim = star->nimage;
ucacread0.c:			ncat = star->ncat;
ucacread0.c:					star->xmag[0], star->xmag[1],
ucacread0.c:					star->xmag[2], star->xmag[3]);
ucacread0.c:					star->xmag[4], star->xmag[5],
ucacread0.c:					star->xmag[6], star->xmag[7]);
ucacread0.c:				    gmag[imag][nstar] = star->xmag[imag];
ucacread0.c:				gmag[nmag][nstar] = star->errra;
ucacread0.c:				gmag[nmag+1][nstar] = star->errdec;
ucacread0.c:				gmag[nmag+2][nstar] = star->errpmr;
ucacread0.c:				gmag[nmag+3][nstar] = star->errpmd;
ucacread0.c:					gmag[imag][farstar] = star->xmag[imag];
ucacread0.c:					gmag[nmag][farstar] = star->errra;
ucacread0.c:					gmag[nmag+1][farstar] = star->errdec;
ucacread0.c:					gmag[nmag+2][farstar] = star->errpmr;
ucacread0.c:					gmag[nmag+3][farstar] = star->errpmd;
ucacread0.c:				    gmag[imag][faintstar] = star->xmag[imag];
ucacread0.c:				gmag[nmag][faintstar] = star->errra;
ucacread0.c:				gmag[nmag+1][faintstar] = star->errdec;
ucacread0.c:				gmag[nmag+2][faintstar] = star->errpmr;
ucacread0.c:				gmag[nmag+3][faintstar] = star->errpmd;
ucacread0.c:				 nstar,jstar,starcat->nstars);
ucacread0.c:	    ntot = ntot + starcat->nstars;
ucacread0.c:		 	 iz+1,nz,nstar,jstar,starcat->nstars,zlist[iz]);
ucacread0.c:/* UCACRNUM -- Read HST Guide Star Catalog stars from CDROM */
ucacread0.c:    star->num = 0.0;
ucacread0.c:	istar = (int) ((gnum[jstar] - (double) zone + 0.0000001) * 1000000.0);
ucacread0.c:	    num = star->num;
ucacread0.c:	    ra = star->ra;
ucacread0.c:	    dec = star->dec;
ucacread0.c:	    rapm = star->rapm;
ucacread0.c:	    decpm = star->decpm;
ucacread0.c:	    mag = star->xmag[0];
ucacread0.c:    	    gtype[jstar] = (1000 * star->nimage) + star->ncat;
ucacread0.c:		gmag[0][jstar] = star->xmag[0];
ucacread0.c:		    gmag[imag][jstar] = star->xmag[imag];
ucacread0.c:		gmag[nmag][jstar] = star->errra;
ucacread0.c:		gmag[nmag+1][jstar] = star->errdec;
ucacread0.c:		gmag[nmag+2][jstar] = star->errpmr;
ucacread0.c:		gmag[nmag+3][jstar] = star->errpmd;
ucacread0.c:		gtype[jstar] = (1000 * star->nimage) + star->ncat;
ucacread0.c:			     num, ra, dec, mag, star->isp);
ucacread0.c:			     num, ra, dec, star->xmag[0]);
ucacread0.c:			     star->xmag[1],star->xmag[2],star->xmag[3]);
ucacread0.c:		    fprintf (stderr," %d %d\n",star->nimage,star->ncat);
ucacread0.c:			     num, ra, dec, star->xmag[0],star->xmag[1]);
ucacread0.c:			     star->xmag[2], star->xmag[3], star->xmag[4]);
ucacread0.c:			     star->xmag[5], star->xmag[6], star->xmag[7]);
ucacread0.c:		    fprintf (stderr," %d %d\n",star->nimage,star->ncat);
ucacread0.c:	fprintf (stderr,"UCACRNUM: %d / %d found\n",nstar,starcat->nstars);
ucacread0.c:/* UCACBIN -- Fill a FITS WCS image with UCAC Star Catalog stars */
ucacread0.c:    double ddec;	/* Search half-width in declination in degrees */
ucacread0.c:    sysout = wcs->syswcs;
ucacread0.c:    eqout = wcs->equinox;
ucacread0.c:    epout = wcs->epoch;
ucacread0.c:	magsort = sortmag - 1;
ucacread0.c:    star->num = 0.0;
ucacread0.c:	fprintf (stderr,"UCACBIN:  no UCAC zone for %.2f-%.2f %.2f %.2f\n",
ucacread0.c:		    istar2 = starcat->nstars;
ucacread0.c:		nread = istar2 - istar1 + 1;
ucacread0.c:		    num = star->num;
ucacread0.c:		    mag = star->xmag[magsort];
ucacread0.c:			rapm = star->rapm;
ucacread0.c:			decpm = star->decpm;
ucacread0.c:			ra = star->ra;
ucacread0.c:			dec = star->dec;
ucacread0.c:				flux = magscale * exp (logt * (-mag / 2.5));
ucacread0.c:				 nstar,jstar,starcat->nstars);
ucacread0.c:	    ntot = ntot + starcat->nstars;
ucacread0.c:		 	 iz+1,nz,nstar,jstar,starcat->nstars,zlist[iz]);
ucacread0.c:/* UCACZONE -- Compute the zones over which to search
ucacread0.c:    nz = iz2 - iz1 + 1;
ucacread0.c:	fprintf (stderr,"UCACZONES: searching %d zones: %d - %d\n",nz,iz1,iz2);
ucacread0.c:	fprintf(stderr,"UCACZONES: Dec: %.5f - %.5f\n", dec1,dec2);
ucacread0.c:/* UCACSRA -- Find UCAC star closest to specified right ascension */
ucacread0.c:    ra1 = st->ra;
ucacread0.c:    istar = sc->nstars;
ucacread0.c:	    ra = st->ra;
ucacread0.c:	    rdiff = ra1 - ra;
ucacread0.c:	    rdiff1 = ra1 - rax;
ucacread0.c:	    rdiff2 = ra - rax;
ucacread0.c:	    sdiff = (double)(istar - istar1) * rdiff1 / rdiff;
ucacread0.c:		istar2 = istar1 + (int) (sdiff - 0.5);
ucacread0.c:	    if (binary || istar2 < 1 || istar2 > sc->nstars) {
ucacread0.c:			istar2 = istar1 + (ABS (istar1 - istar) / 2);
ucacread0.c:			istar2 = istar1 - (ABS (istar1 - istar) / 2);
ucacread0.c:			istar2 = istar1 + (ABS (istar1 - istar) / 2);
ucacread0.c:			istar2 = istar1 - (ABS (istar1 - istar) / 2);
ucacread0.c:/* UCACOPEN -- Open UCAC catalog file, returning number of entries */
ucacread0.c:    sc->byteswapped = 0;
ucacread0.c:	sc->nbent = 67;
ucacread0.c:	sc->nbent = 44;
ucacread0.c:	sc->nbent = 84;
ucacread0.c:        sc->nstars = lfile / sc->nbent;
ucacread0.c:	strcpy (sc->isfil, zonefile);
ucacread0.c:	strncpy (sc->isfil, zonefile, 23);
ucacread0.c:    sc->inform = 'J';
ucacread0.c:    sc->coorsys = WCS_J2000;
ucacread0.c:    sc->epoch = 2000.0;
ucacread0.c:    sc->equinox = 2000.0;
ucacread0.c:    sc->ifcat = fcat;
ucacread0.c:    sc->sptype = 0;
ucacread0.c:	sc->nmag = 1;
ucacread0.c:	sc->nmag = 4;
ucacread0.c:	sc->nmag = 8;
ucacread0.c:    /* UCAC stars are RA-sorted within declination zones */
ucacread0.c:    sc->rasorted = 1;
ucacread0.c:/* Check to see if byte-swapping is necessary */
ucacread0.c:	nbr = fread (&us2, 1, sc->nbent, sc->ifcat);
ucacread0.c:	/* Dec should be between -90 and +90 degrees in milliarcseconds */
ucacread0.c:	else if (us2.decsec > 90 * 3600000 || us2.decsec < -90 * 3600000)
ucacread0.c:	/* J H K magnitudes should be near-positive */
ucacread0.c:	else if (us2.jmag < -1000 || us2.hmag < -1000  || us2.kmag < -1000)
ucacread0.c:	nbr = fread (&us3, 1, sc->nbent, sc->ifcat);
ucacread0.c:	/* Dec should be between -90 and +90 degrees in milliarcseconds */
ucacread0.c:	else if (us3.decsec > 180 * 3600000 || us3.decsec < -180 * 3600000)
ucacread0.c:	/* J H K magnitudes should be near-positive */
ucacread0.c:	else if (us3.jmag < -1000 || us3.hmag < -1000  || us3.kmag < -1000)
ucacread0.c:    sc->istar = 0;
ucacread0.c:    fclose (sc->ifcat);
ucacread0.c:/* UCACSTAR -- Get UCAC catalog entry for one star;
ucacread0.c:    if (sc->ifcat == NULL)
ucacread0.c:    if (istar < 1 || istar > sc->nstars) {
ucacread0.c:        return (-1);
ucacread0.c:    nbskip = sc->nbent * (istar - 1);
ucacread0.c:    if (fseek (sc->ifcat,nbskip,SEEK_SET))
ucacread0.c:        return (-1);
ucacread0.c:	nbr = fread (line, 1, sc->nbent, sc->ifcat);
ucacread0.c:	nbr = fread (&us2, 1, sc->nbent, sc->ifcat);
ucacread0.c:	nbr = fread (&us3, 1, sc->nbent, sc->ifcat);
ucacread0.c:    if (nbr < sc->nbent) {
ucacread0.c:        fprintf (stderr, "UCACSTAR %d / %d bytes read\n",nbr, sc->nbent);
ucacread0.c:        return (-2);
ucacread0.c:    st->num = (double) zone + (0.000001 * (double) istar);
ucacread0.c:	st->ra = atof (line) / 3600000.0;
ucacread0.c:	st->dec = (atof (line+10) / 3600000.0) - 90.0;
ucacread0.c:	st->rapm = (atof (line+41) / 3600000.0) / cosdeg (st->dec);
ucacread0.c:	st->decpm = atof (line+48) / 3600000.0;
ucacread0.c:	st->xmag[0] = atof (line+20) * 0.01;
ucacread0.c:	st->ra  = (double) us2.rasec  / 3600000.0;
ucacread0.c:	st->dec = (double) us2.decsec / 3600000.0;
ucacread0.c:	st->errra  = (double) us2.era / 3600000.0;	/* mas */
ucacread0.c:	st->errra  = st->errra / cosdeg (st->dec);	/* to RA deg */
ucacread0.c:	st->errdec = (double) us2.edec / 3600000.0;	/* mas */
ucacread0.c:	st->rapm  = (double) us2.rapm  / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->decpm = (double) us2.decpm / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->errpmr  = (double) us2.erapm / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->errpmr  = st->errpmr / cosdeg (st->dec);	/* to RA deg */
ucacread0.c:	st->errpmd = (double) us2.edecpm / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->xmag[0] = ((double) us2.jmag) / 1000.0;
ucacread0.c:	st->xmag[1] = ((double) us2.hmag) / 1000.0;
ucacread0.c:	st->xmag[2] = ((double) us2.kmag) / 1000.0;
ucacread0.c:	st->xmag[3] = ((double) us2.cmag) / 100.0;
ucacread0.c:	st->nimage = (int) us2.nobs;
ucacread0.c:	st->ncat = (int) us2.ncat;
ucacread0.c:	st->ra  = (double) us3.rasec  / 3600000.0;	/* mas */
ucacread0.c:	st->dec = (double) us3.decsec / 3600000.0;	/* mas */
ucacread0.c:	st->dec = st->dec - 90.0;
ucacread0.c:	st->errra  = (double) us3.sigra / 3600000.0;	/* mas */
ucacread0.c:	st->errra  = st->errra / cosdeg (st->dec);	/* to RA deg */
ucacread0.c:	st->errdec = (double) us3.sigdec / 3600000.0;	/* mas */
ucacread0.c:	st->rapm  = (double) us3.rapm  / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->rapm  = st->rapm / cosdeg (st->dec);	/* to RA deg */
ucacread0.c:	st->decpm = (double) us3.decpm / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->errpmr  = (double) us3.sigpmr / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->errpmr  = st->errpmr / cosdeg (st->dec);	/* to RA deg */
ucacread0.c:	st->errpmd = (double) us3.sigpmd / 36000000.0;	/* 0.1mas/yr */
ucacread0.c:	st->nimage = (int) us3.nu1;
ucacread0.c:	st->ncat = (int) us3.us1;
ucacread0.c:	    st->xmag[0] = 99.990;
ucacread0.c:	    st->xmag[0] = ((double) us3.bmag) / 1000.0;
ucacread0.c:	    st->xmag[1] = 99.990;
ucacread0.c:	    st->xmag[1] = ((double) us3.rmag) / 1000.0;
ucacread0.c:	    st->xmag[2] = 99.990;
ucacread0.c:	    st->xmag[2] = ((double) us3.imag) / 1000.0;
ucacread0.c:	    st->xmag[3] = 99.990;
ucacread0.c:	    st->xmag[3] = ((double) us3.jmag) / 1000.0;
ucacread0.c:	    st->xmag[4] = 99.990;
ucacread0.c:	    st->xmag[4] = ((double) us3.hmag) / 1000.0;
ucacread0.c:	    st->xmag[5] = 99.990;
ucacread0.c:	    st->xmag[5] = ((double) us3.kmag) / 1000.0;
ucacread0.c:	    st->xmag[6] = 99.990;
ucacread0.c:	    st->xmag[6] = ((double) us3.mmag) / 1000.0;
ucacread0.c:	    st->xmag[7] = 99.990;
ucacread0.c:	    st->xmag[7] = ((double) us3.amag) / 1000.0;
ucacread0.c:/* UCACSWAP2 -- Swap bytes in Integer*2 number in place */
ucacread0.c:/* UCACSWAP4 -- Reverse bytes of Integer*4 or Real*4 number in place */
ucacread0.c: * Nov 10 2003	Fix byte-swapping test in ucacopen() found by Ed Beshore
ucacread0.c: * Dec  1 2003	Add missing tab to n=-1 header
ucacread0.c: * Jul 11 2007	Add magnitude byte-swap check
ucacread0.c: * Nov  2 2009	Print UCAC3 errors if n = -1
ucacread.c: *** Harvard-Smithsonian Center for Astrophysics
ucacread.c: *** Copyright (C) 2003-2013
ucacread.c: Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
ucacread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
ucacread.c:  uint8_t yale_gc_flags;      /* Yale SPM g-flag * 10 + c-flag */
ucacread.c:/* UCACREAD -- Read UCAC Star Catalog stars */
ucacread.c:     double	ddec;		/* Search half-width in declination in degrees */
ucacread.c:    magsort = nmag - 1;
ucacread.c:    magsort = sortmag - 1;
ucacread.c:  star->num = 0.0;
ucacread.c:    fprintf (stderr,"UCACREAD:  no UCAC zone for %.2f-%.2f %.2f %.2f\n",
ucacread.c:	    printf ("----------	------------	------------	");
ucacread.c:	    printf ("-----	------	------	------\n");
ucacread.c:	    printf ("----------	------------	------------    ");
ucacread.c:	    printf ("------	------	-----	-----	-----	");
ucacread.c:	    printf ("-----	-----	------	------	-----	-----	");
ucacread.c:	    printf ("--	--	------\n");
ucacread.c:	    printf ("----------	------------	------------	");
ucacread.c:	    printf ("------	------	-----	------	-----	");
ucacread.c:	    printf ("-----	-----	-----	-----	-----	");
ucacread.c:	    printf ("-----	-----	-----	------	------	");
ucacread.c:	    printf ("--	--	------\n");
ucacread.c:	    printf ("----------	------------	------------	");
ucacread.c:	    printf ("------	------	-----	------	-----	");
ucacread.c:	    printf ("-----	-----	-----	-----	-----	");
ucacread.c:	    printf ("-----	-----	-----	------	------	");
ucacread.c:	    printf ("--	--	------\n");
ucacread.c:            istar = istar - 5;
ucacread.c:          if (istar2 < starcat->nstars - 5)
ucacread.c:            istar2 = starcat->nstars;
ucacread.c:          istar2 = starcat->nstars;
ucacread.c:        nread = istar2 - istar1 + 1;
ucacread.c:          num = star->num;
ucacread.c:          mag = star->xmag[magsort];
ucacread.c:            ra = star->ra;
ucacread.c:            dec = star->dec;
ucacread.c:            rapm = star->rapm;
ucacread.c:            decpm = star->decpm;
ucacread.c:            errra = star->errra;
ucacread.c:            errdec = star->errdec;
ucacread.c:            errpmr = star->errpmr;
ucacread.c:            errpmd = star->errpmd;
ucacread.c:            nim = star->nimage;
ucacread.c:            ncat = star->ncat;
ucacread.c:                        star->xmag[0], star->xmag[1],
ucacread.c:                        star->xmag[2], star->xmag[3]);
ucacread.c:                        star->xmag[4], star->xmag[5],
ucacread.c:                        star->xmag[6], star->xmag[7]);
ucacread.c:                        star->xmag[4], star->xmag[5],
ucacread.c:                        star->xmag[6], star->xmag[7]);
ucacread.c:                  gmag[imag][nstar] = star->xmag[imag];
ucacread.c:                gmag[nmag][nstar] = star->errra;
ucacread.c:                gmag[nmag+1][nstar] = star->errdec;
ucacread.c:                gmag[nmag+2][nstar] = star->errpmr;
ucacread.c:                gmag[nmag+3][nstar] = star->errpmd;
ucacread.c:                    gmag[imag][farstar] = star->xmag[imag];
ucacread.c:                  gmag[nmag][farstar] = star->errra;
ucacread.c:                  gmag[nmag+1][farstar] = star->errdec;
ucacread.c:                  gmag[nmag+2][farstar] = star->errpmr;
ucacread.c:                  gmag[nmag+3][farstar] = star->errpmd;
ucacread.c:                  gmag[imag][faintstar] = star->xmag[imag];
ucacread.c:                gmag[nmag][faintstar] = star->errra;
ucacread.c:                gmag[nmag+1][faintstar] = star->errdec;
ucacread.c:                gmag[nmag+2][faintstar] = star->errpmr;
ucacread.c:                gmag[nmag+3][faintstar] = star->errpmd;
ucacread.c:                     nstar,jstar,starcat->nstars);
ucacread.c:	    ntot = ntot + starcat->nstars;
ucacread.c:                 iz+1,nz,nstar,jstar,starcat->nstars,zlist[iz]);
ucacread.c:/* UCACRNUM -- Read HST Guide Star Catalog stars from CDROM */
ucacread.c:  star->num = 0.0;
ucacread.c:    istar = (int) ((gnum[jstar] - (double) zone + 0.0000001) * 1000000.0);
ucacread.c:	    num = star->num;
ucacread.c:	    ra = star->ra;
ucacread.c:	    dec = star->dec;
ucacread.c:	    rapm = star->rapm;
ucacread.c:	    decpm = star->decpm;
ucacread.c:	    mag = star->xmag[0];
ucacread.c:      gtype[jstar] = (1000 * star->nimage) + star->ncat;
ucacread.c:        gmag[0][jstar] = star->xmag[0];
ucacread.c:          gmag[imag][jstar] = star->xmag[imag];
ucacread.c:        gmag[nmag][jstar] = star->errra;
ucacread.c:        gmag[nmag+1][jstar] = star->errdec;
ucacread.c:        gmag[nmag+2][jstar] = star->errpmr;
ucacread.c:        gmag[nmag+3][jstar] = star->errpmd;
ucacread.c:        gtype[jstar] = (1000 * star->nimage) + star->ncat;
ucacread.c:                   num, ra, dec, mag, star->isp);
ucacread.c:                   num, ra, dec, star->xmag[0]);
ucacread.c:                   star->xmag[1],star->xmag[2],star->xmag[3]);
ucacread.c:          fprintf (stderr," %d %d\n",star->nimage,star->ncat);
ucacread.c:                   num, ra, dec, star->xmag[0],star->xmag[1]);
ucacread.c:                   star->xmag[2], star->xmag[3], star->xmag[4]);
ucacread.c:                   star->xmag[5], star->xmag[6], star->xmag[7]);
ucacread.c:          fprintf (stderr," %d %d\n",star->nimage,star->ncat);
ucacread.c:                   num, ra, dec, star->xmag[0],star->xmag[1]);
ucacread.c:                   star->xmag[2], star->xmag[3], star->xmag[4]);
ucacread.c:                   star->xmag[5], star->xmag[6], star->xmag[7]);
ucacread.c:          fprintf (stderr," %d %d\n",star->nimage,star->ncat);
ucacread.c:          exit(-1);
ucacread.c:    fprintf (stderr,"UCACRNUM: %d / %d found\n",nstar,starcat->nstars);
ucacread.c:/* UCACBIN -- Fill a FITS WCS image with UCAC Star Catalog stars */
ucacread.c:  double ddec;	/* Search half-width in declination in degrees */
ucacread.c:  sysout = wcs->syswcs;
ucacread.c:  eqout = wcs->equinox;
ucacread.c:  epout = wcs->epoch;
ucacread.c:    magsort = sortmag - 1;
ucacread.c:  star->num = 0.0;
ucacread.c:    fprintf (stderr,"UCACBIN:  no UCAC zone for %.2f-%.2f %.2f %.2f\n",
ucacread.c:          istar2 = starcat->nstars;
ucacread.c:        nread = istar2 - istar1 + 1;
ucacread.c:          num = star->num;
ucacread.c:          mag = star->xmag[magsort];
ucacread.c:            rapm = star->rapm;
ucacread.c:            decpm = star->decpm;
ucacread.c:            ra = star->ra;
ucacread.c:            dec = star->dec;
ucacread.c:                flux = magscale * exp (logt * (-mag / 2.5));
ucacread.c:                     nstar,jstar,starcat->nstars);
ucacread.c:      ntot = ntot + starcat->nstars;
ucacread.c:                 iz+1,nz,nstar,jstar,starcat->nstars,zlist[iz]);
ucacread.c:/* UCACZONE -- Compute the zones over which to search
ucacread.c:  nz = iz2 - iz1 + 1;
ucacread.c:    fprintf (stderr,"UCACZONES: searching %d zones: %d - %d\n",nz,iz1,iz2);
ucacread.c:    fprintf(stderr,"UCACZONES: Dec: %.5f - %.5f\n", dec1,dec2);
ucacread.c:/* UCACSRA -- Find UCAC star closest to specified right ascension */
ucacread.c:  ra1 = st->ra;
ucacread.c:  istar2 = sc->nstars;
ucacread.c:  maxnrep = sc->nstars;
ucacread.c:      ra = st->ra;
ucacread.c:      if (istar > sc->nstars)
ucacread.c:        istar = sc->nstars;
ucacread.c:/* UCACOPEN -- Open UCAC catalog file, returning number of entries */
ucacread.c:    exit(-1);
ucacread.c:  sc->byteswapped = 0;
ucacread.c:    sc->nbent = 67;
ucacread.c:    sc->nbent = 44;
ucacread.c:    sc->nbent = 84;
ucacread.c:    sc->nbent = sizeof(UCAC4star);
ucacread.c:    exit(-1);
ucacread.c:    sc->nstars = lfile / sc->nbent;
ucacread.c:    strcpy (sc->isfil, zonefile);
ucacread.c:    strncpy (sc->isfil, zonefile, 23);
ucacread.c:  sc->inform = 'J';
ucacread.c:  sc->coorsys = WCS_J2000;
ucacread.c:  sc->epoch = 2000.0;
ucacread.c:  sc->equinox = 2000.0;
ucacread.c:  sc->ifcat = fcat;
ucacread.c:  sc->sptype = 0;
ucacread.c:    sc->nmag = 1;
ucacread.c:    sc->nmag = 4;
ucacread.c:    sc->nmag = 8;
ucacread.c:    sc->nmag = 8;
ucacread.c:    exit(-1);
ucacread.c:  /* UCAC stars are RA-sorted within declination zones */
ucacread.c:  sc->rasorted = 1;
ucacread.c:  /* Check to see if byte-swapping is necessary */
ucacread.c:    nbr = fread (&us2, 1, sc->nbent, sc->ifcat);
ucacread.c:    /* Dec should be between -90 and +90 degrees in milliarcseconds */
ucacread.c:    else if (us2.decsec > 90 * 3600000 || us2.decsec < -90 * 3600000)
ucacread.c:    /* J H K magnitudes should be near-positive */
ucacread.c:    else if (us2.jmag < -1000 || us2.hmag < -1000  || us2.kmag < -1000)
ucacread.c:    nbr = fread (&us3, 1, sc->nbent, sc->ifcat);
ucacread.c:    /* Dec should be between -90 and +90 degrees in milliarcseconds */
ucacread.c:    else if (us3.decsec > 180 * 3600000 || us3.decsec < -180 * 3600000)
ucacread.c:    /* J H K magnitudes should be near-positive */
ucacread.c:    else if (us3.jmag < -1000 || us3.hmag < -1000  || us3.kmag < -1000)
ucacread.c:    nbr = fread (&us4, 1, sc->nbent, sc->ifcat);
ucacread.c:    /* Dec should be between -90 and +90 degrees in milliarcseconds */
ucacread.c:    /* J H K magnitudes should be near-positive */
ucacread.c:    else if (us4.mag_j < -1000 || us4.mag_h < -1000  || us4.mag_k < -1000)
ucacread.c:    exit(-1);
ucacread.c:  sc->istar = 0;
ucacread.c:  fclose (sc->ifcat);
ucacread.c:/* UCACSTAR -- Get UCAC catalog entry for one star;
ucacread.c:  if (sc->ifcat == NULL)
ucacread.c:  if (istar < 1 || istar > sc->nstars) {
ucacread.c:    return (-1);
ucacread.c:  nbskip = sc->nbent * (istar - 1);
ucacread.c:  if (fseek (sc->ifcat,nbskip,SEEK_SET))
ucacread.c:    return (-1);
ucacread.c:    nbr = fread (line, 1, sc->nbent, sc->ifcat);
ucacread.c:    nbr = fread (&us2, 1, sc->nbent, sc->ifcat);
ucacread.c:    nbr = fread (&us3, 1, sc->nbent, sc->ifcat);
ucacread.c:    nbr = fread (&us4, 1, sc->nbent, sc->ifcat);
ucacread.c:    exit(-1);
ucacread.c:  if (nbr < sc->nbent) {
ucacread.c:    fprintf (stderr, "UCACSTAR %d / %d bytes read\n",nbr, sc->nbent);
ucacread.c:    return (-2);
ucacread.c:  st->num = (double) zone + (0.000001 * (double) istar);
ucacread.c:    st->ra = atof (line) / 3600000.0;
ucacread.c:    st->dec = (atof (line+10) / 3600000.0) - 90.0;
ucacread.c:    st->rapm = (atof (line+41) / 3600000.0) / cosdeg (st->dec);
ucacread.c:    st->decpm = atof (line+48) / 3600000.0;
ucacread.c:    st->xmag[0] = atof (line+20) * 0.01;
ucacread.c:    st->ra  = (double) us2.rasec  / 3600000.0;
ucacread.c:    st->dec = (double) us2.decsec / 3600000.0;
ucacread.c:    st->errra  = (double) us2.era / 3600000.0;	/* mas */
ucacread.c:    st->errra  = st->errra / cosdeg (st->dec);	/* to RA deg */
ucacread.c:    st->errdec = (double) us2.edec / 3600000.0;	/* mas */
ucacread.c:    st->rapm  = (double) us2.rapm  / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->decpm = (double) us2.decpm / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->errpmr  = (double) us2.erapm / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->errpmr  = st->errpmr / cosdeg (st->dec);	/* to RA deg */
ucacread.c:    st->errpmd = (double) us2.edecpm / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->xmag[0] = ((double) us2.jmag) / 1000.0;
ucacread.c:    st->xmag[1] = ((double) us2.hmag) / 1000.0;
ucacread.c:    st->xmag[2] = ((double) us2.kmag) / 1000.0;
ucacread.c:    st->xmag[3] = ((double) us2.cmag) / 100.0;
ucacread.c:    st->nimage = (int) us2.nobs;
ucacread.c:    st->ncat = (int) us2.ncat;
ucacread.c:    st->ra  = (double) us3.rasec  / 3600000.0;	/* mas */
ucacread.c:    st->dec = (double) us3.decsec / 3600000.0;	/* mas */
ucacread.c:    st->dec = st->dec - 90.0;
ucacread.c:    st->errra  = (double) us3.sigra / 3600000.0;	/* mas */
ucacread.c:    st->errra  = st->errra / cosdeg (st->dec);	/* to RA deg */
ucacread.c:    st->errdec = (double) us3.sigdec / 3600000.0;	/* mas */
ucacread.c:    st->rapm  = (double) us3.rapm  / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->rapm  = st->rapm / cosdeg (st->dec);	/* to RA deg */
ucacread.c:    st->decpm = (double) us3.decpm / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->errpmr  = (double) us3.sigpmr / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->errpmr  = st->errpmr / cosdeg (st->dec);	/* to RA deg */
ucacread.c:    st->errpmd = (double) us3.sigpmd / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->nimage = (int) us3.nu1;
ucacread.c:    st->ncat = (int) us3.us1;
ucacread.c:      st->xmag[0] = 99.990;
ucacread.c:      st->xmag[0] = ((double) us3.bmag) / 1000.0;
ucacread.c:      st->xmag[1] = 99.990;
ucacread.c:      st->xmag[1] = ((double) us3.rmag) / 1000.0;
ucacread.c:      st->xmag[2] = 99.990;
ucacread.c:      st->xmag[2] = ((double) us3.imag) / 1000.0;
ucacread.c:      st->xmag[3] = 99.990;
ucacread.c:      st->xmag[3] = ((double) us3.jmag) / 1000.0;
ucacread.c:      st->xmag[4] = 99.990;
ucacread.c:      st->xmag[4] = ((double) us3.hmag) / 1000.0;
ucacread.c:      st->xmag[5] = 99.990;
ucacread.c:      st->xmag[5] = ((double) us3.kmag) / 1000.0;
ucacread.c:      st->xmag[6] = 99.990;
ucacread.c:      st->xmag[6] = ((double) us3.mmag) / 1000.0;
ucacread.c:      st->xmag[7] = 99.990;
ucacread.c:      st->xmag[7] = ((double) us3.amag) / 1000.0;
ucacread.c:    st->ra  = (double) us4.ra  / 3600000.0;	/* mas */
ucacread.c:    st->dec = (double) us4.spd / 3600000.0;	/* mas */
ucacread.c:    st->dec = st->dec - 90.0;
ucacread.c:    st->errra  = (double) us4.ra_sigma / 3600000.0;	/* mas */
ucacread.c:    st->errra  = st->errra / cosdeg (st->dec);	/* to RA deg */ 
ucacread.c:    st->errdec = (double) us4.dec_sigma / 3600000.0;	/* mas */
ucacread.c:          exit(-1);
ucacread.c:            exit(-1);
ucacread.c:          if (inBuffer[lineLen-1] == 10) {
ucacread.c:            inBuffer[lineLen-1] = 0;
ucacread.c:            lineLen--;
ucacread.c:          if (inBuffer[lineLen-1] == 13) {
ucacread.c:            inBuffer[lineLen-1] = 0;
ucacread.c:            lineLen--;
ucacread.c:                         &pU4hpm->rnm,
ucacread.c:                         &pU4hpm->zn,
ucacread.c:                         &pU4hpm->rnz,
ucacread.c:                         &pU4hpm->pmrc,
ucacread.c:                         &pU4hpm->pmd,
ucacread.c:                         &pU4hpm->ra,
ucacread.c:                         &pU4hpm->dec,
ucacread.c:                         &pU4hpm->maga);
ucacread.c:        if ((zone == pU4hpm->zn) &&
ucacread.c:            (us4.id_number == pU4hpm->rnm) &&
ucacread.c:            (us4.ra == pU4hpm->ra) &&
ucacread.c:            (us4.spd == pU4hpm->dec) &&
ucacread.c:            (us4.mag2 == pU4hpm->maga)) {
ucacread.c:          st->rapm = (1.0 * pU4hpm->pmrc) / 36000000.0; /* 0.1 mas/yr */
ucacread.c:          st->rapm  = st->rapm / cosdeg (st->dec);	/* to RA deg */
ucacread.c:          st->decpm = (1.0 * pU4hpm->pmd) / 36000000.0; /* 0.1 mas/yr */
ucacread.c:      st->rapm  = (double) us4.pm_ra  / 36000000.0;	/* 0.1mas/yr */
ucacread.c:      st->rapm  = st->rapm / cosdeg (st->dec);	/* to RA deg */
ucacread.c:      st->decpm = (double) us4.pm_dec / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->errpmr  = (double) (us4.pm_ra_sigma+128) / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->errpmr  = st->errpmr / cosdeg (st->dec);	/* to RA deg */
ucacread.c:    st->errpmd = (double) (us4.pm_dec_sigma+128) / 36000000.0;	/* 0.1mas/yr */
ucacread.c:    st->nimage = (int) us4.n_ucac_used;
ucacread.c:    st->ncat = (int) us4.n_cats_used;
ucacread.c:      st->xmag[0] = 99.990;
ucacread.c:      st->xmag[0] = ((double) us4.apass_mag[0]) / 1000.0;
ucacread.c:      st->xmag[1] = 99.990;
ucacread.c:      st->xmag[1] = ((double) us4.apass_mag[3]) / 1000.0;
ucacread.c:      st->xmag[2] = 99.990;
ucacread.c:      st->xmag[2] = ((double) us4.apass_mag[4]) / 1000.0;
ucacread.c:      st->xmag[3] = 99.990;
ucacread.c:      st->xmag[3] = ((double) us4.mag_j) / 1000.0;
ucacread.c:      st->xmag[4] = 99.990;
ucacread.c:      st->xmag[4] = ((double) us4.mag_h) / 1000.0;
ucacread.c:      st->xmag[5] = 99.990;
ucacread.c:      st->xmag[5] = ((double) us4.mag_k) / 1000.0;
ucacread.c:      st->xmag[6] = 99.990;
ucacread.c:      st->xmag[6] = ((double) us4.mag1) / 1000.0;
ucacread.c:      st->xmag[7] = 99.990;
ucacread.c:      st->xmag[7] = ((double) us4.mag2) / 1000.0;
ucacread.c:    if (st->xmag[7] < 90.0) {
ucacread.c:      st->xmag[6] = st->xmag[7];
ucacread.c:    if (st->xmag[0] < 90.0) {
ucacread.c:      st->xmag[6] = st->xmag[0];
ucacread.c:    exit(-1);
ucacread.c:    fprintf(stderr,"istar %6d, ra %.3f  dec %.3f\n",istar,st->ra,st->dec);
ucacread.c:/* UCACSWAP2 -- Swap bytes in Integer*2 number in place */
ucacread.c:/* UCACSWAP4 -- Reverse bytes of Integer*4 or Real*4 number in place */
ucacread.c: * Nov 10 2003	Fix byte-swapping test in ucacopen() found by Ed Beshore
ucacread.c: * Dec  1 2003	Add missing tab to n=-1 header
ucacread.c: * Jul 11 2007	Add magnitude byte-swap check
ucacread.c: * Nov  2 2009	Print UCAC3 errors if n = -1
ucacread.c: * Jan 29 2013  Add UCAC4 support see "DASCH" tag for DASCH-specific changes
Binary file ucacread.c20130208 matches
ujcread.c: *** Harvard-Smithsonian Center for Astrophysics
ujcread.c: *** Copyright (C) 1996-2007
ujcread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
ujcread.c:#define ABS(a) ((a) < 0 ? (-(a)) : (a))
ujcread.c:/* UJCREAD -- Read USNO J Catalog stars from CDROM or plate catalog from file */
ujcread.c:double	ddec;		/* Search half-width in declination in degrees */
ujcread.c:/* UJCRNUM -- Read USNO J Catalog stars from CDROM or plate catalog from file */
ujcread.c:		istar = (int) (((unum[jnum] - znum) * 100000000.0) + 0.5);
ujcread.c:/* UJCBIN -- Fill a FITS WCS image with USNO J Catalog stars */
ujcread.c:    double ddec;	/* Search half-width in declination in degrees */
ujcread.c:    sysout = wcs->syswcs;
ujcread.c:    eqout = wcs->equinox;
ujcread.c:    epout = wcs->epoch;
ujcread.c:				    flux = magscale * exp (logt * (-mag / 2.5));
ujcread.c:/* UJCZONES -- figure out which UJ zones will need to be searched */
ujcread.c:	fprintf (stderr,"UJCREG:  %d zones: %d - %d\n",nrgn,zones[0],zones[i-1]);
ujcread.c:	fprintf(stderr,"UJCREG: RA: %.5f - %.5f, Dec: %.5f - %.5f\n",ra1,ra2,dec1,dec2);
ujcread.c:/* UJCRA -- returns right ascension in degrees from the UJ star structure */
ujcread.c:/* UJCDEC -- returns the declination in degrees from the UJ star structure */
ujcread.c:    return ((double) (decsec - 32400000) / 360000.0);
ujcread.c:/* UJCMAG -- returns the magnitude from the UJ star structure */
ujcread.c:	return ((double) (-magetc % 10000) * 0.01);
ujcread.c:/* UJCPLATE -- returns the plate number from the UJ star structure */
ujcread.c:	return ( (-magetc % 10000000) / 10000);
ujcread.c:/* UJCZONE -- find the UJ zone number where a declination can be found */
ujcread.c:/* UJCSRA -- Find UJ star closest to specified right ascension */
ujcread.c:	    rdiff = ra1 - ra;
ujcread.c:	    rdiff1 = ra1 - rax;
ujcread.c:	    rdiff2 = ra - rax;
ujcread.c:	    sdiff = (double)(istar - istar1) * rdiff1 / rdiff;
ujcread.c:/* UJCOPEN -- Open UJ Catalog zone catalog, returning number of entries */
ujcread.c:/* Check to see if byte-swapping is necessary */
ujcread.c:/* UJCPATH -- Get UJ Catalog region file pathname */
ujcread.c:	fprintf (stderr, "UJCPATH: zone %d out of range 0-1725\n",zn);
ujcread.c:	return (-1);
ujcread.c:/* UJCSTAR -- Get UJ catalog entry for one star; return 0 if successful */
ujcread.c:	return (-1);
ujcread.c:    nbskip = 12 * (istar - 1);
ujcread.c:	return (-1);
ujcread.c:	return (-2);
ujcread.c:/* UJCSWAP -- Reverse bytes of UJ Catalog entry */
ujcread.c:char *string;	/* Start of vector of 4-byte ints */
ujcread.c: * Jun 24 1998	Initialize byte-swapping flag in UJCOPEN()
Update.sao:cp -p \
wcs.c: *** Harvard-Smithsonian Center for Astrophysics
wcs.c: *** Copyright (C) 1994-2012
wcs.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcs.c: *		sets a WCS structure from keyword-based arguments
wcs.c: * Subroutine:	pix2wcst (wcs,xpix,ypix,wcstring,lstr) pixels -> sky coordinate string
wcs.c: * Subroutine:	pix2wcs (wcs,xpix,ypix,xpos,ypos) pixel coordinates -> sky coordinates
wcs.c: * Subroutine:	wcsc2pix (wcs,xpos,ypos,coorsys,xpix,ypix,offscl) sky coordinates -> pixel coordinates
wcs.c: * Subroutine:	wcs2pix (wcs,xpos,ypos,xpix,ypix,offscl) sky coordinates -> pixel coordinates
wcs.c:    if (wcs->wcs) {
wcs.c:	wcsfree (wcs->wcs);
wcs.c:	wcs->wcs = NULL;
wcs.c:    if (wcs->wcsname != NULL)
wcs.c:	free (wcs->wcsname);
wcs.c:    if (wcs->lin.imgpix != NULL)
wcs.c:	free (wcs->lin.imgpix);
wcs.c:    if (wcs->lin.piximg != NULL)
wcs.c:	free (wcs->lin.piximg);
wcs.c:    if (wcs->inv_x != NULL)
wcs.c:	poly_end (wcs->inv_x);
wcs.c:    if (wcs->inv_y != NULL)
wcs.c:	poly_end (wcs->inv_y);
wcs.c:int	nxpix;	/* Number of pixels along x-axis */
wcs.c:int	nypix;	/* Number of pixels along y-axis */
wcs.c:    wcs->cel.flag = 0;
wcs.c:    wcs->lin.flag = 0;
wcs.c:    wcs->wcsl.flag = 0;
wcs.c:    wcs->naxis = 2;
wcs.c:    wcs->naxes = 2;
wcs.c:    wcs->lin.naxis = 2;
wcs.c:		wcs->lin.naxis_sqr = (wcs->lin.naxis)*(wcs->lin.naxis);
wcs.c:    wcs->nxpix = nxpix;
wcs.c:    wcs->nypix = nypix;
wcs.c:    wcs->wcsproj = wcsproj0;
wcs.c:    wcs->crpix[0] = xrpix;
wcs.c:    wcs->crpix[1] = yrpix;
wcs.c:    wcs->xrefpix = wcs->crpix[0];
wcs.c:    wcs->yrefpix = wcs->crpix[1];
wcs.c:    wcs->lin.crpix = wcs->crpix;
wcs.c:    wcs->crval[0] = cra;
wcs.c:    wcs->crval[1] = cdec;
wcs.c:    wcs->xref = wcs->crval[0];
wcs.c:    wcs->yref = wcs->crval[1];
wcs.c:    wcs->cel.ref[0] = wcs->crval[0];
wcs.c:    wcs->cel.ref[1] = wcs->crval[1];
wcs.c:    wcs->cel.ref[2] = 999.0;
wcs.c:    strcpy (wcs->c1type,"RA");
wcs.c:    strcpy (wcs->c2type,"DEC");
wcs.c:/* Allan Brighton: 28.4.98: for backward compat., remove leading "--" */
wcs.c:    while (proj && *proj == '-')
wcs.c:    strcpy (wcs->ptype,proj);
wcs.c:    strcpy (wcs->ctype[0],"RA---");
wcs.c:    strcpy (wcs->ctype[1],"DEC--");
wcs.c:    strcat (wcs->ctype[0],proj);
wcs.c:    strcat (wcs->ctype[1],proj);
wcs.c:    if (wcstype (wcs, wcs->ctype[0], wcs->ctype[1])) {
wcs.c:    cdelt1 = -secpix / 3600.0;
wcs.c:    wcs->lin.cdelt = wcs->cdelt;
wcs.c:    wcs->lin.pc = wcs->pc;
wcs.c:    wcs->equinox =  (double) equinox;
wcs.c:	strcpy (wcs->radecsys,"FK5");
wcs.c:	strcpy (wcs->radecsys,"FK4");
wcs.c:	wcs->epoch = epoch;
wcs.c:	wcs->epoch = 0.0;
wcs.c:    wcs->wcson = 1;
wcs.c:    wcs->syswcs = wcscsys (wcs->radecsys);
wcs.c:    wcsoutinit (wcs, wcs->radecsys);
wcs.c:    wcsininit (wcs, wcs->radecsys);
wcs.c:    wcs->eqout = 0.0;
wcs.c:    wcs->printsys = 1;
wcs.c:    wcs->tabsys = 0;
wcs.c:int	naxis1;		/* Number of pixels along x-axis */
wcs.c:int	naxis2;		/* Number of pixels along y-axis */
wcs.c:    wcs->cel.flag = 0;
wcs.c:    wcs->lin.flag = 0;
wcs.c:    wcs->wcsl.flag = 0;
wcs.c:    wcs->naxis = 2;
wcs.c:    wcs->naxes = 2;
wcs.c:    wcs->lin.naxis = 2;
wcs.c:		wcs->lin.naxis_sqr= (wcs->lin.naxis)*(wcs->lin.naxis);
wcs.c:    wcs->nxpix = naxis1;
wcs.c:    wcs->nypix = naxis2;
wcs.c:    wcs->wcsproj = wcsproj0;
wcs.c:    wcs->crpix[0] = crpix1;
wcs.c:    wcs->crpix[1] = crpix2;
wcs.c:    wcs->xrefpix = wcs->crpix[0];
wcs.c:    wcs->yrefpix = wcs->crpix[1];
wcs.c:    wcs->lin.crpix = wcs->crpix;
wcs.c:    if (wcs->latbase == 90)
wcs.c:	crval2 = 90.0 - crval2;
wcs.c:    else if (wcs->latbase == -90)
wcs.c:	crval2 = crval2 - 90.0;
wcs.c:    wcs->crval[0] = crval1;
wcs.c:    wcs->crval[1] = crval2;
wcs.c:    wcs->xref = wcs->crval[0];
wcs.c:    wcs->yref = wcs->crval[1];
wcs.c:    wcs->cel.ref[0] = wcs->crval[0];
wcs.c:    wcs->cel.ref[1] = wcs->crval[1];
wcs.c:    wcs->cel.ref[2] = 999.0;
wcs.c:    wcs->lin.cdelt = wcs->cdelt;
wcs.c:    wcs->lin.pc = wcs->pc;
wcs.c:    wcs->equinox =  (double) equinox;
wcs.c:	strcpy (wcs->radecsys,"FK5");
wcs.c:	strcpy (wcs->radecsys,"FK4");
wcs.c:	wcs->epoch = epoch;
wcs.c:	wcs->epoch = 0.0;
wcs.c:    wcs->wcson = 1;
wcs.c:    strcpy (wcs->radecout, wcs->radecsys);
wcs.c:    wcs->syswcs = wcscsys (wcs->radecsys);
wcs.c:    wcsoutinit (wcs, wcs->radecsys);
wcs.c:    wcsininit (wcs, wcs->radecsys);
wcs.c:    wcs->eqout = 0.0;
wcs.c:    wcs->printsys = 1;
wcs.c:    wcs->tabsys = 0;
wcs.c:    strcpy (wcs->ctype[0], ctype1);
wcs.c:    strcpy (wcs->c1type, ctype1);
wcs.c:    strcpy (wcs->ptype, ctype1);
wcs.c:	wcs->prjcode = WCS_LIN;
wcs.c:	wcs->prjcode = WCS_PIX;
wcs.c:	wcs->prjcode = WCS_PIX;
wcs.c:	wcs->c1type[0] = ctype1[0];
wcs.c:	wcs->c1type[1] = ctype1[1];
wcs.c:	if (ctype1[2] == '-') {
wcs.c:	    wcs->c1type[2] = 0;
wcs.c:	    wcs->c1type[2] = ctype1[2];
wcs.c:	    if (ctype1[3] == '-') {
wcs.c:		wcs->c1type[3] = 0;
wcs.c:		wcs->c1type[3] = ctype1[3];
wcs.c:		wcs->c1type[4] = 0;
wcs.c:	if (ctype1[iproj] == '-') iproj = iproj + 1;
wcs.c:	if (ctype1[iproj] == '-') iproj = iproj + 1;
wcs.c:	if (ctype1[iproj] == '-') iproj = iproj + 1;
wcs.c:	if (ctype1[iproj] == '-') iproj = iproj + 1;
wcs.c:	wcs->ptype[0] = ctype1[iproj];
wcs.c:	wcs->ptype[1] = ctype1[iproj+1];
wcs.c:	wcs->ptype[2] = ctype1[iproj+2];
wcs.c:	wcs->ptype[3] = 0;
wcs.c:	sprintf (wcs->ctype[0],"%-4s%4s",wcs->c1type,wcs->ptype);
wcs.c:	    if (wcs->ctype[0][i] == ' ') wcs->ctype[0][i] = '-';
wcs.c:	wcs->prjcode = 0;  /* default type is linear */
wcs.c:	    if (!strncmp(wcs->ptype, ctypes[i], 3))
wcs.c:		wcs->prjcode = i;
wcs.c:	if (wcs->prjcode == WCS_NCP) {
wcs.c:	    if (wcs->wcsproj == WCS_BEST)
wcs.c:		wcs->wcsproj = WCS_OLD;
wcs.c:	    else if (wcs->wcsproj == WCS_ALT)
wcs.c:		wcs->wcsproj = WCS_NEW;
wcs.c:	else if (wcs->prjcode == WCS_CAR) {
wcs.c:	    if (wcs->wcsproj == WCS_BEST)
wcs.c:		wcs->wcsproj = WCS_OLD;
wcs.c:	    else if (wcs->wcsproj == WCS_ALT)
wcs.c:		wcs->wcsproj = WCS_NEW;
wcs.c:	else if (wcs->prjcode == WCS_COE) {
wcs.c:	    if (wcs->wcsproj == WCS_BEST)
wcs.c:		wcs->wcsproj = WCS_OLD;
wcs.c:	    else if (wcs->wcsproj == WCS_ALT)
wcs.c:		wcs->wcsproj = WCS_NEW;
wcs.c:	else if (wcs->wcsproj == WCS_BEST) */
wcs.c:	if (wcs->wcsproj == WCS_BEST)
wcs.c:	    wcs->wcsproj = WCS_NEW;
wcs.c:	else if (wcs->wcsproj == WCS_ALT)
wcs.c:	    wcs->wcsproj = WCS_OLD;
wcs.c:	/* if (wcs->wcsproj == WCS_OLD && (
wcs.c:	    wcs->prjcode != WCS_STG && wcs->prjcode != WCS_AIT &&
wcs.c:	    wcs->prjcode != WCS_MER && wcs->prjcode != WCS_GLS &&
wcs.c:	    wcs->prjcode != WCS_ARC && wcs->prjcode != WCS_TAN &&
wcs.c:	    wcs->prjcode != WCS_TNX && wcs->prjcode != WCS_SIN &&
wcs.c:	    wcs->prjcode != WCS_PIX && wcs->prjcode != WCS_LIN &&
wcs.c:	    wcs->prjcode != WCS_CAR && wcs->prjcode != WCS_COE &&
wcs.c:	    wcs->prjcode != WCS_NCP && wcs->prjcode != WCS_ZPX))
wcs.c:	    wcs->wcsproj = WCS_NEW; */
wcs.c:	if (wcs->wcsproj == WCS_OLD && wcs->prjcode == WCS_TNX) {
wcs.c:	    wcs->ctype[0][6] = 'A';
wcs.c:	    wcs->ctype[0][7] = 'N';
wcs.c:	    wcs->prjcode = WCS_TAN;
wcs.c:	if (wcs->wcsproj == WCS_OLD && wcs->prjcode == WCS_ZPX) {
wcs.c:	    wcs->ctype[0][6] = 'P';
wcs.c:	    wcs->ctype[0][7] = 'N';
wcs.c:	    wcs->prjcode = WCS_ZPN;
wcs.c:	wcs->prjcode = WCS_LIN;
wcs.c:	wcs->latbase = 90;
wcs.c:	strcpy (wcs->radecsys,"NPOLE");
wcs.c:	wcs->syswcs = WCS_NPOLE;
wcs.c:    else if (!strncmp (ctype2, "SPA-",4)) {
wcs.c:	wcs->latbase = -90;
wcs.c:	strcpy (wcs->radecsys,"SPA");
wcs.c:	wcs->syswcs = WCS_SPA;
wcs.c:	wcs->latbase = 0;
wcs.c:    strcpy (wcs->ctype[1], ctype2);
wcs.c:    strcpy (wcs->c2type, ctype2);
wcs.c:	wcs->prjcode = WCS_LIN;
wcs.c:	wcs->prjcode = WCS_PIX;
wcs.c:	wcs->c2type[0] = ctype2[0];
wcs.c:	wcs->c2type[1] = ctype2[1];
wcs.c:	if (ctype2[2] == '-') {
wcs.c:	    wcs->c2type[2] = 0;
wcs.c:	    wcs->c2type[2] = ctype2[2];
wcs.c:	    if (ctype2[3] == '-') {
wcs.c:		wcs->c2type[3] = 0;
wcs.c:		wcs->c2type[3] = ctype2[3];
wcs.c:		wcs->c2type[4] = 0;
wcs.c:	if (ctype2[iproj] == '-') iproj = iproj + 1;
wcs.c:	if (ctype2[iproj] == '-') iproj = iproj + 1;
wcs.c:	if (ctype2[iproj] == '-') iproj = iproj + 1;
wcs.c:	if (ctype2[iproj] == '-') iproj = iproj + 1;
wcs.c:	wcs->ptype[0] = ctype2[iproj];
wcs.c:	wcs->ptype[1] = ctype2[iproj+1];
wcs.c:	wcs->ptype[2] = ctype2[iproj+2];
wcs.c:	wcs->ptype[3] = 0;
wcs.c:	    wcs->coorflip = 1;
wcs.c:	    wcs->coorflip = 0;
wcs.c:	    wcs->degout = 1;
wcs.c:	    wcs->ndec = 5;
wcs.c:	    wcs->degout = 0;
wcs.c:	    wcs->ndec = 3;
wcs.c:	sprintf (wcs->ctype[1],"%-4s%4s",wcs->c2type,wcs->ptype);
wcs.c:	    if (wcs->ctype[1][i] == ' ') wcs->ctype[1][i] = '-';
wcs.c:	wcs->prjcode = WCS_LIN;
wcs.c:	return (-1);
wcs.c:    wcs->cel.flag = 0;
wcs.c:    wcs->lin.flag = 0;
wcs.c:    wcs->wcsl.flag = 0;
wcs.c:    wcs->crpix[0] = crpix1;
wcs.c:    wcs->crpix[1] = crpix2;
wcs.c:    wcs->xrefpix = wcs->crpix[0];
wcs.c:    wcs->yrefpix = wcs->crpix[1];
wcs.c:    wcs->lin.crpix = wcs->crpix;
wcs.c:    wcs->crval[0] = crval1;
wcs.c:    wcs->crval[1] = crval2;
wcs.c:    wcs->xref = wcs->crval[0];
wcs.c:    wcs->yref = wcs->crval[1];
wcs.c:    if (wcs->coorflip) {
wcs.c:	wcs->cel.ref[1] = wcs->crval[0];
wcs.c:	wcs->cel.ref[0] = wcs->crval[1];
wcs.c:	wcs->cel.ref[0] = wcs->crval[0];
wcs.c:	wcs->cel.ref[1] = wcs->crval[1];
wcs.c:    wcs->ncoeff1 = 0;
wcs.c:    wcs->ncoeff2 = 0;
wcs.c:	wcs->xinc = 1.0;
wcs.c:	wcs->yinc = 1.0;
wcs.c:    if (!strncmp (wcs->ptype,"LINEAR",6) ||
wcs.c:	!strncmp (wcs->ptype,"PIXEL",5))
wcs.c:	wcs->degout = -1;
wcs.c:    wcs->wcson = 1;
wcs.c:    if (wcs->equinox == equinox)
wcs.c:    if (equinox == 2000.0 && wcs->equinox == 1950.0) {
wcs.c:	if (wcs->coorflip) { 
wcs.c:	    fk425e (&wcs->crval[1], &wcs->crval[0], wcs->epoch);
wcs.c:	    wcs->cel.ref[1] = wcs->crval[0];
wcs.c:	    wcs->cel.ref[0] = wcs->crval[1];
wcs.c:	    fk425e (&wcs->crval[0], &wcs->crval[1], wcs->epoch);
wcs.c:	    wcs->cel.ref[0] = wcs->crval[0];
wcs.c:	    wcs->cel.ref[1] = wcs->crval[1];
wcs.c:	wcs->xref = wcs->crval[0];
wcs.c:	wcs->yref = wcs->crval[1];
wcs.c:	wcs->equinox = 2000.0;
wcs.c:	strcpy (wcs->radecsys, "FK5");
wcs.c:	wcs->syswcs = WCS_J2000;
wcs.c:	wcs->cel.flag = 0;
wcs.c:	wcs->wcsl.flag = 0;
wcs.c:    else if (equinox == 1950.0 && wcs->equinox == 2000.0) {
wcs.c:	if (wcs->coorflip) { 
wcs.c:	    fk524e (&wcs->crval[1], &wcs->crval[0], wcs->epoch);
wcs.c:	    wcs->cel.ref[1] = wcs->crval[0];
wcs.c:	    wcs->cel.ref[0] = wcs->crval[1];
wcs.c:	    fk524e (&wcs->crval[0], &wcs->crval[1], wcs->epoch);
wcs.c:	    wcs->cel.ref[0] = wcs->crval[0];
wcs.c:	    wcs->cel.ref[1] = wcs->crval[1];
wcs.c:	wcs->xref = wcs->crval[0];
wcs.c:	wcs->yref = wcs->crval[1];
wcs.c:	wcs->equinox = 1950.0;
wcs.c:	strcpy (wcs->radecsys, "FK4");
wcs.c:	wcs->syswcs = WCS_B1950;
wcs.c:	wcs->cel.flag = 0;
wcs.c:	wcs->wcsl.flag = 0;
wcs.c:    wcsoutinit (wcs, wcs->radecsys);
wcs.c:    wcsininit (wcs, wcs->radecsys);
wcs.c:    wcs->rotmat = 1;
wcs.c:    wcs->cd[0] = cd[0];
wcs.c:    wcs->cd[1] = cd[1];
wcs.c:    wcs->cd[2] = cd[2];
wcs.c:    wcs->cd[3] = cd[3];
wcs.c:    (void) matinv (2, wcs->cd, wcs->dc);
wcs.c:    wcs->xinc = sqrt (cd[0]*cd[0] + cd[2]*cd[2]);
wcs.c:    wcs->yinc = sqrt (cd[1]*cd[1] + cd[3]*cd[3]);
wcs.c:    if (wcs->coorflip) {
wcs.c:	cd[1] = -cd[2];
wcs.c:	cd[2] = -tcd;
wcs.c:    wcs->wcson = 1;
wcs.c:    wcs->cdelt[0] = wcs->xinc;
wcs.c:    wcs->cdelt[1] = wcs->yinc;
wcs.c:    naxes = wcs->naxis;
wcs.c:    wcs->cdelt[0] = cdelt1;
wcs.c:	wcs->cdelt[1] = cdelt2;
wcs.c:	wcs->cdelt[1] = cdelt1;
wcs.c:    wcs->xinc = wcs->cdelt[0];
wcs.c:    wcs->yinc = wcs->cdelt[1];
wcs.c:    pci = wcs->pc;
wcs.c:    wcs->rotmat = 0;
wcs.c:    wcs->rot = crota;
wcs.c:    if (wcs->rot < 0.0)
wcs.c:	wcs->rot = wcs->rot + 360.0;
wcs.c:    if (wcs->rot >= 360.0)
wcs.c:	wcs->rot = wcs->rot - 360.0;
wcs.c:    crot = cos (degrad(wcs->rot));
wcs.c:	srot = sin (-degrad(wcs->rot));
wcs.c:	srot = sin (degrad(wcs->rot));
wcs.c:    wcs->cd[0] = wcs->cdelt[0] * crot;
wcs.c:    if (wcs->cdelt[0] < 0)
wcs.c:	wcs->cd[1] = -fabs (wcs->cdelt[1]) * srot;
wcs.c:	wcs->cd[1] = fabs (wcs->cdelt[1]) * srot;
wcs.c:    if (wcs->cdelt[1] < 0)
wcs.c:	wcs->cd[2] = fabs (wcs->cdelt[0]) * srot;
wcs.c:	wcs->cd[2] = -fabs (wcs->cdelt[0]) * srot;
wcs.c:    wcs->cd[3] = wcs->cdelt[1] * crot;
wcs.c:    (void) matinv (2, wcs->cd, wcs->dc);
wcs.c:    if (wcs->coorflip) {
wcs.c:	if (wcs->cdelt[0] < 0 && wcs->cdelt[1] > 0) {
wcs.c:	    wcs->imflip = 1;
wcs.c:	    wcs->imrot = wcs->rot - 90.0;
wcs.c:	    if (wcs->imrot < -180.0) wcs->imrot = wcs->imrot + 360.0;
wcs.c:	    wcs->pa_north = wcs->rot;
wcs.c:	    wcs->pa_east = wcs->rot - 90.0;
wcs.c:	    if (wcs->pa_east < -180.0) wcs->pa_east = wcs->pa_east + 360.0;
wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] < 0) {
wcs.c:	    wcs->imflip = 1;
wcs.c:	    wcs->imrot = wcs->rot + 90.0;
wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
wcs.c:	    wcs->pa_north = wcs->rot;
wcs.c:	    wcs->pa_east = wcs->rot - 90.0;
wcs.c:	    if (wcs->pa_east < -180.0) wcs->pa_east = wcs->pa_east + 360.0;
wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] > 0) {
wcs.c:	    wcs->imflip = 0;
wcs.c:	    wcs->imrot = wcs->rot + 90.0;
wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
wcs.c:	    wcs->pa_north = wcs->imrot;
wcs.c:	    wcs->pa_east = wcs->rot + 90.0;
wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
wcs.c:	else if (wcs->cdelt[0] < 0 && wcs->cdelt[1] < 0) {
wcs.c:	    wcs->imflip = 0;
wcs.c:	    wcs->imrot = wcs->rot - 90.0;
wcs.c:	    if (wcs->imrot < -180.0) wcs->imrot = wcs->imrot + 360.0;
wcs.c:	    wcs->pa_north = wcs->imrot;
wcs.c:	    wcs->pa_east = wcs->rot + 90.0;
wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
wcs.c:	if (wcs->cdelt[0] < 0 && wcs->cdelt[1] > 0) {
wcs.c:	    wcs->imflip = 0;
wcs.c:	    wcs->imrot = wcs->rot;
wcs.c:	    wcs->pa_north = wcs->rot + 90.0;
wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
wcs.c:	    wcs->pa_east = wcs->rot + 180.0;
wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] < 0) {
wcs.c:	    wcs->imflip = 0;
wcs.c:	    wcs->imrot = wcs->rot + 180.0;
wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
wcs.c:	    wcs->pa_north = wcs->imrot + 90.0;
wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
wcs.c:	    wcs->pa_east = wcs->imrot + 180.0;
wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
wcs.c:	else if (wcs->cdelt[0] > 0 && wcs->cdelt[1] > 0) {
wcs.c:	    wcs->imflip = 1;
wcs.c:	    wcs->imrot = -wcs->rot;
wcs.c:	    wcs->pa_north = wcs->imrot + 90.0;
wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
wcs.c:	    wcs->pa_east = wcs->rot;
wcs.c:	else if (wcs->cdelt[0] < 0 && wcs->cdelt[1] < 0) {
wcs.c:	    wcs->imflip = 1;
wcs.c:	    wcs->imrot = wcs->rot + 180.0;
wcs.c:	    if (wcs->imrot > 180.0) wcs->imrot = wcs->imrot - 360.0;
wcs.c:	    wcs->pa_north = wcs->imrot + 90.0;
wcs.c:	    if (wcs->pa_north > 180.0) wcs->pa_north = wcs->pa_north - 360.0;
wcs.c:	    wcs->pa_east = wcs->rot + 90.0;
wcs.c:	    if (wcs->pa_east > 180.0) wcs->pa_east = wcs->pa_east - 360.0;
wcs.c:    naxes = wcs->naxis;
wcs.c:	naxes = wcs->naxes;
wcs.c:	wcs->naxis = naxes;
wcs.c:    wcs->cdelt[0] = cdelt1;
wcs.c:	wcs->cdelt[1] = cdelt2;
wcs.c:	wcs->cdelt[1] = cdelt1;
wcs.c:    wcs->xinc = wcs->cdelt[0];
wcs.c:    wcs->yinc = wcs->cdelt[1];
wcs.c:    pci = wcs->pc;
wcs.c:	wcs->cd[0] = pc[0] * wcs->cdelt[0];
wcs.c:	wcs->cd[1] = pc[1] * wcs->cdelt[0];
wcs.c:	wcs->cd[2] = pc[naxes] * wcs->cdelt[1];
wcs.c:	wcs->cd[3] = pc[naxes+1] * wcs->cdelt[1];
wcs.c:	wcs->cd[0] = pc[0] * wcs->cdelt[0];
wcs.c:	wcs->cd[1] = 0.0;
wcs.c:	wcs->cd[2] = 0.0;
wcs.c:	wcs->cd[3] = 1.0;
wcs.c:    (void) matinv (2, wcs->cd, wcs->dc);
wcs.c:    wcs->rotmat = 1;
wcs.c:    (void)linset (&wcs->lin);
wcs.c:    wcs->wcson = 1;
wcs.c:    naxes = wcs->naxis;
wcs.c:	naxes = wcs->naxes;
wcs.c:	wcs->naxis = naxes;
wcs.c:    if (wcs->lin.piximg == NULL)
wcs.c:	wcs->lin.piximg = (double*)malloc(mem);
wcs.c:    if (wcs->lin.piximg != NULL) {
wcs.c:	if (wcs->lin.imgpix == NULL)
wcs.c:	    wcs->lin.imgpix = (double*)malloc(mem);
wcs.c:	if (wcs->lin.imgpix != NULL) {
wcs.c:	    wcs->lin.flag = LINSET;
wcs.c:		    wcs->lin.piximg[i] = wcs->cd[i];
wcs.c:		    wcs->lin.piximg[i] = 0.0;
wcs.c:		wcs->lin.piximg[0] = wcs->cd[0];
wcs.c:		wcs->lin.piximg[1] = wcs->cd[1];
wcs.c:		wcs->lin.piximg[3] = wcs->cd[2];
wcs.c:		wcs->lin.piximg[4] = wcs->cd[3];
wcs.c:		wcs->lin.piximg[8] = 1.0;
wcs.c:		    wcs->lin.piximg[i] = 0.0;
wcs.c:		wcs->lin.piximg[0] = wcs->cd[0];
wcs.c:		wcs->lin.piximg[1] = wcs->cd[1];
wcs.c:		wcs->lin.piximg[4] = wcs->cd[2];
wcs.c:		wcs->lin.piximg[5] = wcs->cd[3];
wcs.c:		wcs->lin.piximg[10] = 1.0;
wcs.c:		wcs->lin.piximg[15] = 1.0;
wcs.c:	    (void) matinv (naxes, wcs->lin.piximg, wcs->lin.imgpix);
wcs.c:	    wcs->lin.crpix = wcs->crpix;
wcs.c:	    wcs->lin.cdelt = wcs->cdelt;
wcs.c:	    wcs->lin.pc = wcs->pc;
wcs.c:	    wcs->lin.flag = LINSET;
wcs.c:    /* If image is one-dimensional, leave rotation angle alone */
wcs.c:    if (wcs->nxpix < 1.5 || wcs->nypix < 1.5) {
wcs.c:	wcs->imrot = wcs->rot;
wcs.c:	wcs->pa_north = wcs->rot + 90.0;
wcs.c:	wcs->pa_east = wcs->rot + 180.0;
wcs.c:    if (wcs->syswcs == WCS_LINEAR)
wcs.c:    wcs->xinc = fabs (wcs->xinc);
wcs.c:    wcs->yinc = fabs (wcs->yinc);
wcs.c:    xc = wcs->xrefpix;
wcs.c:    yc = wcs->yrefpix;
wcs.c:    if (wcs->coorflip) {
wcs.c:	wcs2pix (wcs, cra+wcs->yinc, cdec, &xe, &ye, &off);
wcs.c:	wcs2pix (wcs, cra, cdec+wcs->xinc, &xn, &yn, &off);
wcs.c:	wcs2pix (wcs, cra+wcs->xinc, cdec, &xe, &ye, &off);
wcs.c:	wcs2pix (wcs, cra, cdec+wcs->yinc, &xn, &yn, &off);
wcs.c:    wcs->pa_north = raddeg (atan2 (yn-yc, xn-xc));
wcs.c:    if (wcs->pa_north < -90.0)
wcs.c:	wcs->pa_north = wcs->pa_north + 360.0;
wcs.c:    wcs->pa_east = raddeg (atan2 (ye-yc, xe-xc));
wcs.c:    if (wcs->pa_east < -90.0)
wcs.c:	wcs->pa_east = wcs->pa_east + 360.0;
wcs.c:    if (wcs->pa_north < -90.0)
wcs.c:	wcs->imrot = 270.0 + wcs->pa_north;
wcs.c:	wcs->imrot = wcs->pa_north - 90.0;
wcs.c:    if (wcs->coorflip) {
wcs.c:	wcs->rot = wcs->imrot + 90.0;
wcs.c:	if (wcs->rot < 0.0)
wcs.c:	    wcs->rot = wcs->rot + 360.0;
wcs.c:	wcs->rot = wcs->imrot;
wcs.c:    if (wcs->rot < 0.0)
wcs.c:	wcs->rot = wcs->rot + 360.0;
wcs.c:    if (wcs->rot >= 360.0)
wcs.c:	wcs->rot = wcs->rot - 360.0;
wcs.c:    wcs->imflip = 0;
wcs.c:    if (wcs->pa_east - wcs->pa_north < -80.0 &&
wcs.c:	wcs->pa_east - wcs->pa_north > -100.0)
wcs.c:	wcs->imflip = 1;
wcs.c:    if (wcs->pa_east - wcs->pa_north < 280.0 &&
wcs.c:	wcs->pa_east - wcs->pa_north > 260.0)
wcs.c:	wcs->imflip = 1;
wcs.c:    if (wcs->pa_north - wcs->pa_east > 80.0 &&
wcs.c:	wcs->pa_north - wcs->pa_east < 100.0)
wcs.c:	wcs->imflip = 1;
wcs.c:    if (wcs->coorflip) {
wcs.c:	if (wcs->imflip)
wcs.c:	    wcs->yinc = -wcs->yinc;
wcs.c:	if (!wcs->imflip)
wcs.c:	    wcs->xinc = -wcs->xinc;
wcs.c:	return (wcs->wcson);
wcs.c:	return (!wcs->wcson);
wcs.c:    wcs->crval[0] = rra;
wcs.c:    wcs->crval[1] = rdec;
wcs.c:    wcs->xref = wcs->crval[0];
wcs.c:    wcs->yref = wcs->crval[1];
wcs.c:    strcpy (wcs->radecsys,coorsys);
wcs.c:    wcs->syswcs = wcscsys (coorsys);
wcs.c:    if (wcs->syswcs == WCS_B1950)
wcs.c:	wcs->equinox = 1950.0;
wcs.c:	wcs->equinox = 2000.0;
wcs.c:	if (wcs->prjcode == WCS_DSS)
wcs.c:	    (void)fprintf (stderr,"WCS plate center  %s\n", wcs->center);
wcs.c:	xpix = 0.5 * wcs->nxpix;
wcs.c:	ypix = 0.5 * wcs->nypix;
wcs.c:		     wcs->ctype[0],wcs->ctype[1],wcstring,wcs->ptype,xpix,ypix);
wcs.c:	(void) pix2wcs (wcs,wcs->nxpix,ypix,&xpos2,&ypos2);
wcs.c:	if (wcs->syswcs == WCS_LINEAR) {
wcs.c:	    width = xpos2 - xpos1;
wcs.c:	    (void)fprintf (stderr, "WCS width = %.5f %s ",width, wcs->units[0]);
wcs.c:	    (void)fprintf (stderr, "WCS width = %.3f %s ",width, wcs->units[0]);
wcs.c:	secpixw = width / (wcs->nxpix - 1.0);
wcs.c:	(void) pix2wcs (wcs,xpix,wcs->nypix,&xpos2,&ypos2);
wcs.c:	if (wcs->syswcs == WCS_LINEAR) {
wcs.c:	    height = ypos2 - ypos1;
wcs.c:	    (void)fprintf (stderr, " height = %.5f %s ",height, wcs->units[1]);
wcs.c:	    (void)fprintf (stderr, " height = %.3f %s ",height, wcs->units[1]);
wcs.c:	secpixh = height / (wcs->nypix - 1.0);
wcs.c:	if (wcs->syswcs == WCS_LINEAR) {
wcs.c:			    wcs->xinc,wcs->units[0],wcs->yinc,wcs->units[1]);
wcs.c:	    if (wcs->xinc != 0.0 && wcs->yinc != 0.0)
wcs.c:		secpix = (fabs(wcs->xinc) + fabs(wcs->yinc)) * 0.5 * 3600.0;
wcs.c:	    else if (wcs->xinc != 0.0 || wcs->yinc != 0.0)
wcs.c:		secpix = (fabs(wcs->xinc) + fabs(wcs->yinc)) * 3600.0;
wcs.c:double	*dra;		/* Half-width in right ascension (deg) (returned) */
wcs.c:double	*ddec;		/* Half-width in declination (deg) (returned) */
wcs.c:	xcpix = (0.5 * wcs->nxpix) + 0.5;
wcs.c:	ycpix = (0.5 * wcs->nypix) + 0.5;
wcs.c:	xpix = wcs->nxpix + 0.499999;
wcs.c:	if (strncmp (wcs->ptype,"LINEAR",6) &&
wcs.c:	    strncmp (wcs->ptype,"PIXEL",5)) {
wcs.c:	    *width = sqrt (((ypos2-ypos1) * (ypos2-ypos1)) +
wcs.c:		     ((xpos2-xpos1) * (xpos2-xpos1)));
wcs.c:	ypix = wcs->nypix + 0.5;
wcs.c:	if (strncmp (wcs->ptype,"LINEAR",6) &&
wcs.c:	    strncmp (wcs->ptype,"PIXEL",5))
wcs.c:	    *height = sqrt (((ypos2-ypos1) * (ypos2-ypos1)) +
wcs.c:		      ((xpos2-xpos1) * (xpos2-xpos1)));
wcs.c:	(void) pix2wcs (wcs,1.0,wcs->nypix,&xpos2,&ypos2);
wcs.c:	(void) pix2wcs (wcs,wcs->nxpix,1.0,&xpos3,&ypos3);
wcs.c:	(void) pix2wcs (wcs,wcs->nxpix,wcs->nypix,&xpos4,&ypos4);
wcs.c:	if (wcs->syswcs != WCS_LINEAR && wcs->syswcs != WCS_XY) {
wcs.c:	    if (*ra2 - *ra1 > 180.0) {
wcs.c:	    diffi = pos1[i] - pos2[i];
wcs.c:	diff = 2.0 * atan2 (sqrt (w), sqrt (1.0 - w));
wcs.c:    xdiff = x2 - x1;
wcs.c:	xdiff = xdiff - 360.0;
wcs.c:    if (xdiff < -180.0)
wcs.c:    ydiff = (y2 - y1);
wcs.c:/* Initialize catalog search command set by -wcscom */
wcs.c:int	i;			/* Number of command (0-9) to initialize */
wcs.c:	    if (wcs->command_format[i] != NULL)
wcs.c:		free (wcs->command_format[i]);
wcs.c:	    wcs->command_format[i] = (char *) calloc (lcom+2, 1);
wcs.c:	    if (wcs->command_format[i] == NULL)
wcs.c:		    wcs->command_format[i][icom] = ' ';
wcs.c:		    wcs->command_format[i][icom] = command[icom];
wcs.c:	    wcs->command_format[i][lcom] = 0;
wcs.c:int	i;			/* Number of command (0-9) to execute */
wcs.c:    if (wcs->command_format[i] != NULL)
wcs.c:	strcpy (comform, wcs->command_format[i]);
wcs.c:	strcpy (comform, "sgsc -ah %s");
wcs.c:	sysout = wcs->syswcs;
wcs.c:	strcpy (wcs->radecout, wcs->radecsys);
wcs.c:	wcs->eqout = wcs->equinox;
wcs.c:	    if (wcs->eqout != 1950.0) {
wcs.c:		wcs->radecout[0] = 'B';
wcs.c:		sprintf (wcs->radecout+1,"%.4f", wcs->equinox);
wcs.c:		i = strlen(wcs->radecout) - 1;
wcs.c:		if (wcs->radecout[i] == '0')
wcs.c:		    wcs->radecout[i] = (char)0;
wcs.c:		i = strlen(wcs->radecout) - 1;
wcs.c:		if (wcs->radecout[i] == '0')
wcs.c:		    wcs->radecout[i] = (char)0;
wcs.c:		i = strlen(wcs->radecout) - 1;
wcs.c:		if (wcs->radecout[i] == '0')
wcs.c:		    wcs->radecout[i] = (char)0;
wcs.c:		strcpy (wcs->radecout, "B1950");
wcs.c:	    if (wcs->eqout != 2000.0) {
wcs.c:		wcs->radecout[0] = 'J';
wcs.c:		sprintf (wcs->radecout+1,"%.4f", wcs->equinox);
wcs.c:		i = strlen(wcs->radecout) - 1;
wcs.c:		if (wcs->radecout[i] == '0')
wcs.c:		    wcs->radecout[i] = (char)0;
wcs.c:		i = strlen(wcs->radecout) - 1;
wcs.c:		if (wcs->radecout[i] == '0')
wcs.c:		    wcs->radecout[i] = (char)0;
wcs.c:		i = strlen(wcs->radecout) - 1;
wcs.c:		if (wcs->radecout[i] == '0')
wcs.c:		    wcs->radecout[i] = (char)0;
wcs.c:		strcpy (wcs->radecout, "J2000");
wcs.c:	/* Do not try to convert linear or alt-az coordinates */
wcs.c:	if (sysout != wcs->syswcs &&
wcs.c:	    (wcs->syswcs == WCS_LINEAR || wcs->syswcs == WCS_ALTAZ))
wcs.c:	strcpy (wcs->radecout, coorsys);
wcs.c:	wcs->eqout = wcsceq (coorsys);
wcs.c:    wcs->sysout = sysout;
wcs.c:    if (wcs->wcson) {
wcs.c:	if (wcs->sysout == WCS_GALACTIC || wcs->sysout == WCS_ECLIPTIC ||
wcs.c:	    wcs->sysout == WCS_PLANET) {
wcs.c:	    wcs->degout = 1;
wcs.c:	    wcs->ndec = 5;
wcs.c:	else if (wcs->sysout == WCS_ALTAZ) {
wcs.c:	    wcs->degout = 1;
wcs.c:	    wcs->ndec = 5;
wcs.c:	else if (wcs->sysout == WCS_NPOLE || wcs->sysout == WCS_SPA) {
wcs.c:	    wcs->degout = 1;
wcs.c:	    wcs->ndec = 5;
wcs.c:	    wcs->degout = 0;
wcs.c:	    wcs->ndec = 3;
wcs.c:/* Return current value of WCS output coordinate system set by -wcsout */
wcs.c:	return(wcs->radecout);
wcs.c:	wcs->sysin = wcs->syswcs;
wcs.c:	strcpy (wcs->radecin, wcs->radecsys);
wcs.c:	wcs->eqin = wcs->equinox;
wcs.c:	if (wcs->sysin == WCS_B1950) {
wcs.c:	    if (wcs->eqin != 1950.0) {
wcs.c:		wcs->radecin[0] = 'B';
wcs.c:		sprintf (wcs->radecin+1,"%.4f", wcs->equinox);
wcs.c:		i = strlen(wcs->radecin) - 1;
wcs.c:		if (wcs->radecin[i] == '0')
wcs.c:		    wcs->radecin[i] = (char)0;
wcs.c:		i = strlen(wcs->radecin) - 1;
wcs.c:		if (wcs->radecin[i] == '0')
wcs.c:		    wcs->radecin[i] = (char)0;
wcs.c:		i = strlen(wcs->radecin) - 1;
wcs.c:		if (wcs->radecin[i] == '0')
wcs.c:		    wcs->radecin[i] = (char)0;
wcs.c:		strcpy (wcs->radecin, "B1950");
wcs.c:	else if (wcs->sysin == WCS_J2000) {
wcs.c:	    if (wcs->eqin != 2000.0) {
wcs.c:		wcs->radecin[0] = 'J';
wcs.c:		sprintf (wcs->radecin+1,"%.4f", wcs->equinox);
wcs.c:		i = strlen(wcs->radecin) - 1;
wcs.c:		if (wcs->radecin[i] == '0')
wcs.c:		    wcs->radecin[i] = (char)0;
wcs.c:		i = strlen(wcs->radecin) - 1;
wcs.c:		if (wcs->radecin[i] == '0')
wcs.c:		    wcs->radecin[i] = (char)0;
wcs.c:		i = strlen(wcs->radecin) - 1;
wcs.c:		if (wcs->radecin[i] == '0')
wcs.c:		    wcs->radecin[i] = (char)0;
wcs.c:		strcpy (wcs->radecin, "J2000");
wcs.c:    wcs->sysin = sysin;
wcs.c:    wcs->eqin = wcsceq (coorsys);
wcs.c:    strcpy (wcs->radecin, coorsys);
wcs.c:	return (wcs->radecin);
wcs.c:    old = wcs->degout;
wcs.c:    wcs->degout = new;
wcs.c:    if (new == 1 && old == 0 && wcs->ndec == 3)
wcs.c:	wcs->ndec = 6;
wcs.c:    if (new == 0 && old == 1 && wcs->ndec == 5)
wcs.c:	wcs->ndec = 3;
wcs.c:	wcs->ndec = ndec;
wcs.c:    return (wcs->ndec);
wcs.c:	return (wcs->radecsys);
wcs.c:	wcs->linmode = mode;
wcs.c:	if (wcs->offscl) {
wcs.c:	else if (wcs->degout == 1) {
wcs.c:	    minlength = 9 + (2 * wcs->ndec);
wcs.c:		deg2str (rastr, 32, xpos, wcs->ndec);
wcs.c:		deg2str (decstr, 32, ypos, wcs->ndec);
wcs.c:		if (wcs->tabsys)
wcs.c:		lstr = lstr - minlength;
wcs.c:		if (wcs->tabsys)
wcs.c:	else if (wcs->degout == 0) {
wcs.c:	    minlength = 18 + (2 * wcs->ndec);
wcs.c:		if (wcs->sysout == WCS_J2000 || wcs->sysout == WCS_B1950) {
wcs.c:		    ra2str (rastr, 32, xpos, wcs->ndec);
wcs.c:		    dec2str (decstr, 32, ypos, wcs->ndec-1);
wcs.c:		    dec2str (rastr, 32, xpos, wcs->ndec);
wcs.c:		    dec2str (decstr, 32, ypos, wcs->ndec);
wcs.c:		if (wcs->tabsys) {
wcs.c:	        lstr = lstr - minlength;
wcs.c:		if (wcs->tabsys) {
wcs.c:	if (wcs->sysout == WCS_GALACTIC) {
wcs.c:	    if (lstr > 9 && wcs->printsys) {
wcs.c:		if (wcs->tabsys)
wcs.c:	else if (wcs->sysout == WCS_ECLIPTIC) {
wcs.c:	    if (lstr > 9 && wcs->printsys) {
wcs.c:		if (wcs->tabsys)
wcs.c:	else if (wcs->sysout == WCS_PLANET) {
wcs.c:	    if (lstr > 9 && wcs->printsys) {
wcs.c:		if (wcs->tabsys)
wcs.c:	/* Label alt-az coordinates */
wcs.c:	else if (wcs->sysout == WCS_ALTAZ) {
wcs.c:	    if (lstr > 7 && wcs->printsys) {
wcs.c:		if (wcs->tabsys)
wcs.c:		    strcat (wcstring,"	alt-az");
wcs.c:		    strcat (wcstring," alt-az");
wcs.c:	else if (wcs->sysout == WCS_NPOLE) {
wcs.c:	    if (lstr > 7 && wcs->printsys) {
wcs.c:		if (wcs->tabsys)
wcs.c:		    strcat (wcstring,"	long-npa");
wcs.c:		    strcat (wcstring," long-npa");
wcs.c:	else if (wcs->sysout == WCS_SPA) {
wcs.c:	    if (lstr > 7 && wcs->printsys) {
wcs.c:		if (wcs->tabsys)
wcs.c:		    strcat (wcstring,"	long-spa");
wcs.c:		    strcat (wcstring," long-spa");
wcs.c:	else if (wcs->sysout==WCS_B1950 || wcs->sysout==WCS_J2000) {
wcs.c:	    if (lstr > (int) strlen(wcs->radecout)+1 && wcs->printsys) {
wcs.c:		if (wcs->tabsys)
wcs.c:		strcat (wcstring, wcs->radecout);
wcs.c:	    num2str (rastr, xpos, 0, wcs->ndec);
wcs.c:	    num2str (decstr, ypos, 0, wcs->ndec);
wcs.c:	    lunits = strlen (wcs->units[0]) + strlen (wcs->units[1]) + 2;
wcs.c:	    if (wcs->syswcs == WCS_LINEAR && wcs->linmode == 1) {
wcs.c:		    if (strlen (wcs->units[0]) > 0) {
wcs.c:			strcat (rastr, wcs->units[0]);
wcs.c:		    if (strlen (wcs->units[1]) > 0) {
wcs.c:			strcat (decstr, wcs->units[1]);
wcs.c:		if (wcs->tabsys)
wcs.c:		if (wcs->tabsys)
wcs.c:	    if (wcs->syswcs == WCS_LINEAR && wcs->linmode != 1 &&
wcs.c:	    if (wcs->syswcs == WCS_LINEAR && wcs->linmode == 2 &&
wcs.c:		if (strlen (wcs->units[0]) > 0) {
wcs.c:		    strcat (wcstring, wcs->units[0]);
wcs.c:		if (strlen (wcs->units[1]) > 0) {
wcs.c:		    strcat (wcstring, wcs->units[1]);
wcs.c:    wcs->xpix = xpix;
wcs.c:    wcs->ypix = ypix;
wcs.c:    wcs->zpix = zpix;
wcs.c:    wcs->offscl = 0;
wcs.c:    if (wcs->wcs != NULL) {
wcs.c:	pix2wcs (wcs->wcs, xpix, ypix, &xpi, &ypi);
wcs.c:    if (wcs->prjcode == WCS_DSS) {
wcs.c:	    wcs->offscl = 1;
wcs.c:    else if (wcs->prjcode == WCS_PLT) {
wcs.c:	    wcs->offscl = 1;
wcs.c:    else if (wcs->prjcode == WCS_TNX) {
wcs.c:	    wcs->offscl = 1;
wcs.c:    else if (wcs->prjcode == WCS_ZPX) {
wcs.c:	    wcs->offscl = 1;
wcs.c:    else if (wcs->wcsproj == WCS_OLD || wcs->prjcode <= 0) {
wcs.c:	    wcs->offscl = 1;
wcs.c:	wcs->offscl = 1;
wcs.c:    if (wcs->offscl) {
wcs.c:        if (wcs->prjcode > 0) {
wcs.c:	    eqin = wcs->equinox;
wcs.c:	    eqout = wcs->eqout;
wcs.c:	    wcscon (wcs->syswcs,wcs->sysout,eqin,eqout,&xp,&yp,wcs->epoch);
wcs.c:	if (wcs->latbase == 90)
wcs.c:	    yp = 90.0 - yp;
wcs.c:	else if (wcs->latbase == -90)
wcs.c:	    yp = yp - 90.0;
wcs.c:	wcs->xpos = xp;
wcs.c:	wcs->ypos = yp;
wcs.c:    if (wcs->sysout > 0 && wcs->sysout != 6 && wcs->sysout != 10) {
wcs.c:	    *xpos = *xpos - 360.0;
wcs.c:    wcsc2pix (wcs, xpos, ypos, wcs->radecin, xpix, ypix, offscl);
wcs.c:    if (wcs->latbase == 90)
wcs.c:	yp = 90.0 - yp;
wcs.c:    else if (wcs->latbase == -90)
wcs.c:	yp = yp - 90.0;
wcs.c:	sysin = wcs->syswcs;
wcs.c:	eqin = wcs->equinox;
wcs.c:    wcs->zpix = 1.0;
wcs.c:	eqout = wcs->equinox;
wcs.c:	wcscon (sysin, wcs->syswcs, eqin, eqout, &xp, &yp, wcs->epoch);
wcs.c:    if (wcs->prjcode == WCS_DSS) {
wcs.c:    else if (wcs->prjcode == WCS_PLT) {
wcs.c:    else if (wcs->prjcode == WCS_TNX) {
wcs.c:    else if (wcs->prjcode == WCS_ZPX) {
wcs.c:    else if (wcs->wcsproj == WCS_OLD || wcs->prjcode <= 0) {
wcs.c:    if (wcs->wcs != NULL) {
wcs.c:	wcsc2pix (wcs->wcs, xpi, ypi, NULL, xpix, ypix, offscl);
wcs.c:	/* Set off-scale flag to 2 if off image but within bounds of projection */
wcs.c:	    else if (*xpix > wcs->nxpix + 0.5 || *ypix > wcs->nypix + 0.5)
wcs.c:    wcs->offscl = *offscl;
wcs.c:    wcs->xpos = xpos;
wcs.c:    wcs->ypos = ypos;
wcs.c:    wcs->xpix = *xpix;
wcs.c:    wcs->ypix = *ypix;
wcs.c:    if (wcs->prjcode == WCS_CSC || wcs->prjcode == WCS_QSC ||
wcs.c:	wcs->prjcode == WCS_TSC)
wcs.c:    offscl = wcsrev ((void *)&wcs->ctype, &wcs->wcsl, pixcrd, &wcs->lin, imgcrd,
wcs.c:		    &wcs->prj, &phi, &theta, wcs->crval, &wcs->cel, wcscrd);
wcs.c:	*xpos = wcscrd[wcs->wcsl.lng];
wcs.c:	*ypos = wcscrd[wcs->wcsl.lat];
wcs.c:    if (wcs->wcsl.flag != WCSSET) {
wcs.c:	if (wcsset (wcs->lin.naxis, (void *)&wcs->ctype, &wcs->wcsl) )
wcs.c:    wcscrd[wcs->wcsl.lng] = xpos;
wcs.c:    wcscrd[wcs->wcsl.lat] = ypos;
wcs.c:    offscl = wcsfwd ((void *)&wcs->ctype, &wcs->wcsl, wcscrd, wcs->crval, &wcs->cel,
wcs.c:		     &phi, &theta, &wcs->prj, imgcrd, &wcs->lin, pixcrd);
wcs.c:	if (wcs->prjcode == WCS_CSC || wcs->prjcode == WCS_QSC ||
wcs.c:	    wcs->prjcode == WCS_TSC)
wcs.c:	    wcs->zpix = pixcrd[2] - 1.0;
wcs.c:	    wcs->zpix = pixcrd[2];
wcs.c:    if (izpix0 > -1) {
wcs.c:    return ((int) wcs->zpix);
wcs.c:	    wcscominit (wcs, i, "sua2 -ah %s");	/* F1= Search USNO-A2.0 Catalog */
wcs.c:	    wcscominit (wcs, i, "sgsc -ah %s");	/* F2= Search HST GSC */
wcs.c:	    wcscominit (wcs, i, "sty2 -ah %s"); /* F3= Search Tycho-2 Catalog */
wcs.c:	    wcscominit (wcs, i, "sppm -ah %s");	/* F4= Search PPM Catalog */
wcs.c:	    wcscominit (wcs, i, "ssao -ah %s");	/* F5= Search SAO Catalog */
wcs.c:	    wcs->command_format[i] = NULL;
wcs.c:	    if (wcs->command_format[i] != NULL) {
wcs.c:		free (wcs->command_format[i]);
wcs.c:    lhead = (ksearch (*header, "END") - *header)  + 80;
wcs.c:    nleft = (lbuff - lhead) / 80;
wcs.c: * Jan 12 1996	Use plane-tangent, not linear, projection if SECPIX is set
wcs.c: * Oct 31 1996	Use inline degree <-> radian conversion functions
wcs.c: * Nov  5 1996	Set wcs->crot to 1 if rotation matrix is used
wcs.c: * May 22 1997	Add PIXEL prjcode = -1;
wcs.c: * Oct 24 1997	Keep longitudes between 0 and 360, not -180 and +180
wcs.c: * Jan  7 1998	Fix tab-separated output
wcs.c: * Mar  6 1998	Write 8-character values to RADECSYS
wcs.c: * Apr 30 1998	Allow leading "-"s in projecting in wcsxinit()
wcs.c: * May 20 1998	Fix bad bug so setlinmode() is no-op if wcs not set
wcs.c: * Jun 11 1998	Split off header-dependent subroutines to wcsinit.c
wcs.c: * Jul 30 1998	Set wcs->naxes and lin.naxis in wcsxinit() and wcskinit()
wcs.c: * Dec  2 1998	Fix non-arcsecond scale factors in wcscent()
wcs.c: * Feb 22 1999	Fix bug so that quad cube faces are 0-5, not 1-6
wcs.c: * Jan 24 2000	Default to AIPS for NCP, CAR, and COE proj.; if -z use WCSLIB
wcs.c: * Feb 24 2000	If coorsys is null in wcsc2pix, wcs->radecin is assumed
wcs.c: * Jun 22 2000	In wcsrotset(), leave rotation angle alone in 1-d image
wcs.c: * Apr 25 2002	Use Tycho-2 catalog instead of ACT in setwcscom()
wcs.c: * Sep 29 2003	Fix bug to deal with all-sky images orrectly in wcsfull()
wcs.c: * Oct  1 2003	Rename wcs->naxes to wcs->naxis to match WCSLIB 3.2
wcs.c: * Dec  3 2003	Add back wcs->naxes for compatibility
wcs.c: * Nov  1 2004	Keep wcs->rot between 0 and 360
wcs.c: * Jun 30 2006	Set only 2-dimensional PC matrix; that is all lin* can deal with
wcscat1.h: *** Copyright (C) 1998-2007
wcscat1.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcscat1.h:    char isp[24];	/* Spectral type or other 2-char identifier */
wcscat1.h:    double size;	/* Semi-major axis in arcseconds */
wcscat1.h:			  <0: -stnum-character name at end instead of number
wcscat1.h:    int	rasorted;	/* 1 if RA-sorted, else 0 */
wcscat1.h:    int  byteswapped;	/* 1 if catalog is byte-reversed from CPU */
wcscat1.h:    int entdate;	/* Entry number for FITS-format date of observation */
wcscat1.h:#define UA1		9	/* USNO A-1.0 Star Catalog */
wcscat1.h:#define UA2		10	/* USNO A-2.0 Star Catalog */
wcscat1.h:#define USA1		11	/* USNO SA-1.0 Star Catalog */
wcscat1.h:#define USA2		12	/* USNO SA-2.0 Star Catalog */
wcscat1.h:#define TYCHO2		16	/* Tycho-2 Star Catalog */
wcscat1.h:#define USNO		17	/* USNO-format plate catalog */
wcscat1.h:#define TMPSC		18	/* 2MASS All-Sky Point Source Catalog */
wcscat1.h:#define GSCACT		19	/* GSC-ACT revised Guide Star Catalog */
wcscat1.h:#define UB1		21	/* USNO B-1.0 Star Catalog */
wcscat1.h:#define TYCHO2E		29	/* Tycho-2 Star Catalog with magnitude errors */
wcscat1.h:#define TABCAT		-1	/* StarBase tab table catalog */
wcscat1.h:#define BINCAT		-2	/* TDC binary catalog */
wcscat1.h:#define TXTCAT		-3	/* TDC ASCII catalog */
wcscat1.h:#define WEBCAT		-4	/* Tab catalog via the web */
wcscat1.h:#define EP_FD   4	/* Output epoch in FITS format (yyyy-mm-dd) */
wcscat1.h:#define EP_ISO  5	/* Output epoch in ISO format (yyyy-mm-ddThh:mm:ss) */
wcscat1.h:#define SORT_UNSET	-1	/* Catalog sort flag not set yet */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **tmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat1.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:    char *sdssc2t(	/* Convert SDSS buffer from comma- to tab-separated */
wcscat1.h:	char *csvbuff);	/* Input comma-separated table */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:/* Subroutines to read a local copy of the Tycho-2 catalog */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:/* Subroutines to read SAO-TDC binary format catalogs */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **tmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **tmag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat1.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat1.h:    int tabgeti4(	/* Return 4-byte integer from tab table line */
wcscat1.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat1.h:/* Subroutines to read DAOPHOT-style catalogs of sources found in an image */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int *sc,	/* Other 4-byte information */
wcscat1.h:	int tabout,	/* 1 if output is tab-delimited */
wcscat1.h:	int classd,	/* GSC object class to accept (-1=all) */
wcscat1.h:	int tabout);	/* 1 for tab-preceded output string, else space-preceded */
wcscat1.h:	double dra,	/* Horizontal half-width in degrees */
wcscat1.h:	double ddec,	/* Vertical half-width in degrees */
wcscat1.h:	double dra,	/* Horizontal half-width in degrees */
wcscat1.h:	double ddec,	/* Vertical half-width in degrees */
wcscat1.h:	char *string,	/* String containing numbers separated by , and - */
wcscat1.h:			 * if <0, get whole string after token -itok
wcscat1.h:char *sdssc2t();	/* Convert SDSS buffer from comma- to tab-separated */
wcscat1.h:/* Subroutines to read a local copy of the Tycho-2 catalog (ty2read.c) */
wcscat1.h:/* Subroutines to read SAO-TDC binary format catalogs (binread.c) */
wcscat1.h:int tabgeti4();		/* Return 4-byte integer from tab table line */
wcscat1.h:/* Subroutines to read DAOPHOT-style catalogs of sources found in an image */
wcscat1.h:void bv2sp();		/* Approximate main sequence spectral type from B - V */
wcscat1.h: * Nov 20 1998	Add support for USNO A-2.0 and SA-2.0 catalogs
wcscat1.h: * Nov 30 2000	Add spectral type to catalog header; make star->isp 4 char.
wcscat1.h: * Jan 16 2003	Add USNO-B1.0 catalog
wcscat1.h: * Aug  5 2005	Add Tycho-2 and 2MASS PSC with magnitude errors
wcscat.h: *** Copyright (C) 1998-2013
wcscat.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcscat.h:    char isp[24];	/* Spectral type or other 2-char identifier */
wcscat.h:    double size;	/* Semi-major axis in arcseconds */
wcscat.h:			  <0: -stnum-character name at end instead of number
wcscat.h:    int	rasorted;	/* 1 if RA-sorted, else 0 */
wcscat.h:    int  byteswapped;	/* 1 if catalog is byte-reversed from CPU */
wcscat.h:    int entdate;	/* Entry number for FITS-format date of observation */
wcscat.h:#define UA1		9	/* USNO A-1.0 Star Catalog */
wcscat.h:#define UA2		10	/* USNO A-2.0 Star Catalog */
wcscat.h:#define USA1		11	/* USNO SA-1.0 Star Catalog */
wcscat.h:#define USA2		12	/* USNO SA-2.0 Star Catalog */
wcscat.h:#define TYCHO2		16	/* Tycho-2 Star Catalog */
wcscat.h:#define USNO		17	/* USNO-format plate catalog */
wcscat.h:#define TMPSC		18	/* 2MASS All-Sky Point Source Catalog */
wcscat.h:#define GSCACT		19	/* GSC-ACT revised Guide Star Catalog */
wcscat.h:#define UB1		21	/* USNO B-1.0 Star Catalog */
wcscat.h:#define TYCHO2E		29	/* Tycho-2 Star Catalog with magnitude errors */
wcscat.h:#define TABCAT		-1	/* StarBase tab table catalog */
wcscat.h:#define BINCAT		-2	/* TDC binary catalog */
wcscat.h:#define TXTCAT		-3	/* TDC ASCII catalog */
wcscat.h:#define WEBCAT		-4	/* Tab catalog via the web */
wcscat.h:#define EP_FD   4	/* Output epoch in FITS format (yyyy-mm-dd) */
wcscat.h:#define EP_ISO  5	/* Output epoch in ISO format (yyyy-mm-ddThh:mm:ss) */
wcscat.h:#define SORT_UNSET	-1	/* Catalog sort flag not set yet */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **tmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:    char *gsc2c2t(	/* Convert GSC2 buffer from comma- to tab-separated */
wcscat.h:	char *csvbuff);	/* Input comma-separated table */
wcscat.h:    char *gsc2t2t(	/* Clean up GSC2 tab-separated buffer */
wcscat.h:	char *tsvbuff);	/* Input tab-separated table */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:    char *sdssc2t(	/* Convert SDSS buffer from comma- to tab-separated */
wcscat.h:	char *csvbuff);	/* Input comma-separated table */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:/* Subroutines to read a local copy of the Tycho-2 catalog */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **gmag,	/* 2-D array of magnitudes and other info (returned) */
wcscat.h:    char *skybot2tab(	/* Convert SkyBot buffer from space- to tab-separated */
wcscat.h:	char *csvbuff);	/* Input comma-separated table */
wcscat.h:/* Subroutines to read SAO-TDC binary format catalogs */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **tmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **tmag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat.h:	double **tmag,	/* 2-D Array of magnitudes (returned) */
wcscat.h:    int tabgeti4(	/* Return 4-byte integer from tab table line */
wcscat.h:    int tabcol(		/* Find column for name (case-sensitive) */
wcscat.h:    int tabccol(	/* Find column for name  (case-insensitive) */
wcscat.h:	double ddec,	/* Search half-width in declination in degrees */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:	double **umag,	/* 2-D array of magnitudes (returned) */
wcscat.h:/* Subroutines to read DAOPHOT-style catalogs of sources found in an image */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int *sc,	/* Other 4-byte information */
wcscat.h:	int tabout,	/* 1 if output is tab-delimited */
wcscat.h:	int classd,	/* GSC object class to accept (-1=all) */
wcscat.h:	int tabout);	/* 1 for tab-preceded output string, else space-preceded */
wcscat.h:	double dra,	/* Horizontal half-width in degrees */
wcscat.h:	double ddec,	/* Vertical half-width in degrees */
wcscat.h:	double dra,	/* Horizontal half-width in degrees */
wcscat.h:	double ddec,	/* Vertical half-width in degrees */
wcscat.h:	char *string,	/* String containing numbers separated by , and - */
wcscat.h:			   if non-zero, replace blanks with underscores */
wcscat.h:char *gsc2c2t();	/* Convert GSC2 buffer from comma- to tab-separated */
wcscat.h:char *gsc2t2t();	/* Clean up GSC2 tab-separated buffer */
wcscat.h:char *sdssc2t();	/* Convert SDSS buffer from comma- to tab-separated */
wcscat.h:/* Subroutines to read a local copy of the Tycho-2 catalog (ty2read.c) */
wcscat.h:/* Subroutines to read SAO-TDC binary format catalogs (binread.c) */
wcscat.h:int tabcol();		/* Find column for name (case-sensitive) */
wcscat.h:int tabccol();		/* Find column for name (case-insensitive) */
wcscat.h:int tabgeti4();		/* Return 4-byte integer from tab table line */
wcscat.h:/* Subroutines to read DAOPHOT-style catalogs of sources found in an image */
wcscat.h:void bv2sp();		/* Approximate main sequence spectral type from B - V */
wcscat.h: * Nov 20 1998	Add support for USNO A-2.0 and SA-2.0 catalogs
wcscat.h: * Nov 30 2000	Add spectral type to catalog header; make star->isp 4 char.
wcscat.h: * Jan 16 2003	Add USNO-B1.0 catalog
wcscat.h: * Aug  5 2005	Add Tycho-2 and 2MASS PSC with magnitude errors
wcscat.h: * Oct 24 2008	Add gsct2t() to clean up tab-separated table from STScI CASB
wcscon1.c: *** Doug Mink, Harvard-Smithsonian Center for Astrophysics
wcscon1.c: *** Copyright (C) 1995-2006
wcscon1.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcscon1.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon1.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon1.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon1.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon1.c:		    *dtheta = *dtheta + ((ep2 - 1950.0) * *ptheta);
wcscon1.c:		    *dphi = *dphi + ((ep2 - 1950.0) * *pphi);
wcscon1.c:		    *dtheta = *dtheta + ((ep2 - 2000.0) * *ptheta);
wcscon1.c:		    *dphi = *dphi + ((ep2 - 2000.0) * *pphi);
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:    /* Keep latitude/declination between +90 and -90 degrees */
wcscon1.c:	*dphi = 180.0 - *dphi;
wcscon1.c:    else if (*dphi < -90.0) {
wcscon1.c:	*dphi = -180.0 - *dphi;
wcscon1.c:	*dtheta = *dtheta - 360.0;
wcscon1.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon1.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon1.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon1.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon1.c:		    *dtheta = *dtheta + ((ep2 - 1950.0) * *ptheta);
wcscon1.c:		    *dphi = *dphi + ((ep2 - 1950.0) * *pphi);
wcscon1.c:		    *dtheta = *dtheta + ((ep2 - 2000.0) * *ptheta);
wcscon1.c:		    *dphi = *dphi + ((ep2 - 2000.0) * *pphi);
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon1.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon1.c:    /* Keep latitude/declination between +90 and -90 degrees */
wcscon1.c:	*dphi = 180.0 - *dphi;
wcscon1.c:    else if (*dphi < -90.0) {
wcscon1.c:	*dphi = -180.0 - *dphi;
wcscon1.c:	*dtheta = *dtheta - 360.0;
wcscon1.c:    /* Keep latitude/declination between +90 and -90 degrees */
wcscon1.c:	*dphi = 180.0 - *dphi;
wcscon1.c:    else if (*dphi < -90.0) {
wcscon1.c:	*dphi = -180.0 - *dphi;
wcscon1.c:	*dtheta = *dtheta - 360.0;
wcscon1.c:	    return -1;
wcscon1.c:	return -1;
wcscon1.c:static double a[3] = {-1.62557e-6, -0.31919e-6, -0.13843e-6};
wcscon1.c:static double ad[3] = {1.245e-3,  -1.580e-3,  -0.659e-3};
wcscon1.c:static double tiny = 1.e-30; /* small number to avoid arithmetic problems */
wcscon1.c:	-0.00000242389840,	/* emi[0][3] */
wcscon1.c:	-0.00000002710544,	/* emi[0][4] */
wcscon1.c:	-0.00000001177742 },	/* emi[0][5] */
wcscon1.c:    {	-0.0111814828,		/* emi[1][0] */
wcscon1.c:	-0.0000271771,		/* emi[1][2] */
wcscon1.c:	-0.00000242392702,	/* emi[1][4] */
wcscon1.c:    {	-0.0048590040,		/* emi[2][0] */
wcscon1.c:	-0.0000271557,		/* emi[2][1] */
wcscon1.c:	-0.00000242404995 },	/* emi[2][5] */
wcscon1.c:    {	-0.000551,		/* emi[3][0] */
wcscon1.c:	-0.435614,		/* emi[3][2] */
wcscon1.c:    {	-0.238560,		/* emi[4][0] */
wcscon1.c:	-0.002667,		/* emi[4][1] */
wcscon1.c:	-0.01118145,		/* emi[4][3] */
wcscon1.c:	-0.00002717 },		/* emi[4][5] */
wcscon1.c:	-0.008541,		/* emi[5][1] */
wcscon1.c:	-0.00485852,		/* emi[5][3] */
wcscon1.c:	-0.00002716,		/* emi[5][4] */
wcscon1.c:    *ra = *ra + (rapm * (epoch - 1950.0));
wcscon1.c:    *dec = *dec + (decpm * (epoch - 1950.0));
wcscon1.c:    system, to the old Bessel-Newcomb FK4 system, using Yallop's
wcscon1.c:    motion, and e-terms routines before and/or after fk524 is called.
wcscon1.c:    of the poles do not embody the differential e-term effect and should,
wcscon1.c:    the polar and non-polar regions, the likelihood that the differential
wcscon1.c:    e-terms effect was not taken into account when allowing for proper motion
wcscon1.c:    effect of differential e-terms on the proper motions for all stars,
wcscon1.c: 	  Astronomical Journal vol. 97, Jan. 1989, p. 265-273.
wcscon1.c: 	  FK5 J2000.0 using matrices in 6-space."  Yallop, B.D.;
wcscon1.c:	  p. 274-279.
wcscon1.c:         the Astronomical Almanac", ISBN 0-935702-68-7.
wcscon1.c:	  Astrophysics, vol. 115, no. 1, Nov. 1982, p. 20-22.
wcscon1.c:	v1[3] = -(ur*y) - (cr*sd*ud);
wcscon1.c:	v1[4] =  (ur*x) - (sr*sd*ud);
wcscon1.c:    /* Apply e-terms to position */
wcscon1.c:    x = x + (a[0] * rxyz) - (w * x);
wcscon1.c:    y = y + (a[1] * rxyz) - (w * z);
wcscon1.c:    z = z + (a[2] * rxyz) - (w * z);
wcscon1.c:    /* Apply e-terms to position and velocity */
wcscon1.c:    x = x + (a[0] * rxyz) - (w * x);
wcscon1.c:    y = y + (a[1] * rxyz) - (w * y);
wcscon1.c:    z = z + (a[2] * rxyz) - (w * z);
wcscon1.c:    xd = v2[3] + (ad[0] * rxyz) - (wd * x);
wcscon1.c:    yd = v2[4] + (ad[1] * rxyz) - (wd * y);
wcscon1.c:    zd = v2[5] + (ad[2] * rxyz) - (wd * z);
wcscon1.c:	ur = (x*yd - y*xd) / rxysq;
wcscon1.c:	ud = (zd*rxysq - z * (x*xd + y*yd)) / ((rxysq + z*z) * rxy);
wcscon1.c:	dra = 240.0 * raddeg (r1950 - r2000);
wcscon1.c:	ddec = 3600.0 * raddeg (d1950 - d2000);
wcscon1.c:	fprintf(stderr,"B1950-J2000: dra= %11.5f sec  ddec= %f11.5f arcsec\n",
wcscon1.c:	-0.0111820611,		/* em[0][1] */
wcscon1.c:	-0.0048579477,		/* em[0][2] */
wcscon1.c:	-0.00000002710663,	/* em[0][4] */
wcscon1.c:	-0.00000001177656 },	/* em[0][5] */
wcscon1.c:	-0.0000271765,		/* em[1][2] */
wcscon1.c:	-0.00000000006587 },	/* em[1][5] */
wcscon1.c:	-0.0000271474,		/* em[2][1] */
wcscon1.c:	-0.00000000006582,	/* em[2][4] */
wcscon1.c:    {	-0.000551,		/* em[3][0] */
wcscon1.c:	-0.238565,		/* em[3][1] */
wcscon1.c:	-0.01118251,		/* em[3][4] */
wcscon1.c:	-0.00485767 },		/* em[3][5] */
wcscon1.c:	-0.002667,		/* em[4][1] */
wcscon1.c:	-0.008541,		/* em[4][2] */
wcscon1.c:	-0.00002718 },		/* em[4][5] */
wcscon1.c:    {	-0.435623,		/* em[5][0] */
wcscon1.c:	-0.00002714,		/* em[5][4] */
wcscon1.c:    *ra = *ra + (rapm * (epoch - 2000.0));
wcscon1.c:    *dec = *dec + (decpm * (epoch - 2000.0));
wcscon1.c:/*  This routine converts stars from the old Bessel-Newcomb FK4 system
wcscon1.c:    motion, and e-terms routines before and/or after fk425 is called.
wcscon1.c:    of the poles do not embody the differential e-term effect and should,
wcscon1.c:    the polar and non-polar regions, the likelihood that the differential
wcscon1.c:    e-terms effect was not taken into account when allowing for proper motion
wcscon1.c:    effect of differential e-terms on the proper motions for all stars,
wcscon1.c: 	  Astronomical Journal vol. 97, Jan. 1989, p. 265-273.
wcscon1.c: 	  FK5 J2000.0 using matrices in 6-space."  Yallop, B.D.;
wcscon1.c:	  p. 274-279.
wcscon1.c:	  Astrophysics, vol. 115, no. 1, Nov. 1982, p. 20-22.
wcscon1.c:	rd0[0] = (-sr * cd * ur) - (cr * sd * ud) + (w * r0[0]);
wcscon1.c:	rd0[1] =  (cr * cd * ur) - (sr * sd * ud) + (w * r0[1]);
wcscon1.c:    /* Remove e-terms from position and express as position+velocity 6-vector */
wcscon1.c:	v1[i] = r0[i] - a[i] + (w * r0[i]);
wcscon1.c:    /* Remove e-terms from proper motion and express as 6-vector */
wcscon1.c:	v1[i+3] = rd0[i] - ad[i] + (wd * r0[i]);
wcscon1.c:    /* Alternately: Put proper motion in 6-vector without adding e-terms
wcscon1.c:	ur = ((x * yd) - (y * xd)) / rxysq;
wcscon1.c:	ud = ((zd * rxysq) - (z * spxy)) / (rxyzsq * rxy);
wcscon1.c:	dra = 240.0 * raddeg (r2000 - r1950);
wcscon1.c:	ddec = 3600.0 * raddeg (d2000 - d1950);
wcscon1.c:	fprintf(stderr,"J2000-B1950: dra= %11.5f sec  ddec= %f11.5f arcsec\n",
wcscon1.c:    (The Eulerian angles are p, q, 90-r)
wcscon1.c:	+cp.cq.sr-sp.cr	+sp.cq.sr+cp.cr	-sq.sr
wcscon1.c:	-cp.cq.cr-sp.sr	-sp.cq.cr+cp.sr	+sq.cr
wcscon1.c:	{{-0.066988739415,-0.872755765852,-0.483538914632},
wcscon1.c:	{0.492728466075,-0.450346958020, 0.744584633283},
wcscon1.c:	{-0.867600811151,-0.188374601723, 0.460199784784}};
wcscon1.c:/*---  Transform B1950.0 FK4 equatorial coordinates to
wcscon1.c:    /*  remove e-terms */
wcscon1.c:    /*	call jpabe (rra,rdec,-1,idg) */
wcscon1.c:/*--- Transform IAU 1958 galactic coordinates to B1950.0 'FK4'
wcscon1.c:/*  introduce e-terms */
wcscon1.c:/*	jpabe (rra,rdec,-1,idg); */
wcscon1.c:    The eulerian angles are p, q, 90-r
wcscon1.c:	+cp.cq.sr-sp.cr     +sp.cq.sr+cp.cr     -sq.sr
wcscon1.c:	-cp.cq.cr-sp.sr     -sp.cq.cr+cp.sr     +sq.cr
wcscon1.c:	{{-0.054875539726,-0.873437108010,-0.483834985808},
wcscon1.c:	{0.494109453312,-0.444829589425, 0.746982251810},
wcscon1.c:	{-0.867666135858,-0.198076386122, 0.455983795705}};
wcscon1.c:/*--- Transform IAU 1958 galactic coordinates to J2000 equatorial coordinates */
wcscon1.c:    xp = (double) 60.0 * (xpos - (double) rah);
wcscon1.c:    ras = (double) 60.0 * (xp - (double) irm);
wcscon1.c:	ypos = -ddec;
wcscon1.c:	decp = '-';
wcscon1.c:    yp = (double) 60.0 * (ypos - (double) decd);
wcscon1.c:    decs = (double) 60.0 * (yp - (double) decm);
wcscon1.c:    t = (epoch - 2000.0) * 0.01;
wcscon1.c:    eps0 = secrad ((84381.448 + (-46.8150 + (-0.00059 + 0.001813*t) * t) * t));
wcscon1.c:    t = (epoch - 2000.0) * 0.01;
wcscon1.c:    eps0 = secrad ((84381.448 + (-46.8150 + (-0.00059 + 0.001813*t) * t) * t));
wcscon1.c:**  Precession - FK4 (Bessel-Newcomb, pre-IAU1976)
wcscon1.c:**  Precession -  FK5 (Fricke, post-IAU2000)
wcscon1.c:**  using the old, pre-IAU1976, Bessel-Newcomb model, using
wcscon1.c:    bigt  = ( bep0 - 1850.0 ) / 100.0;
wcscon1.c:    t = ( bep1 - bep0 ) / 100.0;
wcscon1.c:    zeta = (w + ( 0.30242 - 0.000269 * bigt + 0.017996 * t ) * t ) * tas2r;
wcscon1.c:    theta = ( 2005.1125 + ( - 0.85294 - 0.000365* bigt ) * bigt +
wcscon1.c:	    ( - 0.42647 - 0.000365 * bigt - 0.041802 * t ) * t ) * tas2r;
wcscon1.c:    rotmat (323, -zeta, theta, -z, rmatp);
wcscon1.c:    t0 = ( ep0 - 2000.0 ) / 100.0;
wcscon1.c:    t =  ( ep1 - ep0 ) / 100.0;
wcscon1.c:    w = 2306.2181 + ( ( 1.39656 - ( 0.000139 * t0 ) ) * t0 );
wcscon1.c:    zeta = (w + ( ( 0.30188 - 0.000344 * t0 ) + 0.017998 * t ) * t ) * tas2r;
wcscon1.c:    theta = ( ( 2004.3109 + ( - 0.85330 - 0.000217 * t0 ) * t0 )
wcscon1.c:	  + ( ( -0.42665 - 0.000217 * t0 ) - 0.041833 * t ) * t ) * tas2r;
wcscon1.c:    rotmat (323, -zeta, theta, -z, rmatp);
wcscon1.c:**  Precession -  FK5 (Fricke, post-IAU2000)
wcscon1.c:**  Precession -  FK5 (Fricke, post-IAU2000)
wcscon1.c:    t = ( ep - 2000.0 ) / 100.0;
wcscon1.c:	  - (0.000005971 * t3) - (0.0000003173 * t4)) * tas2r;
wcscon1.c:    z = -2.650545 + (2306.077181 + (1.0927348 * t) + (0.01801828 * t2)
wcscon1.c:	   - (0.000005971 * t3) - (0.0000003173 * t4)) * tas2r;
wcscon1.c:    theta = (2004.191903 - (0.4294934 * t) - (0.04182264 * t2)
wcscon1.c:	    - (0.000007089 * t3) - (0.0000001274 * t4)) * tas2r;
wcscon1.c:    rotmat (323, -z, theta, -zeta, rmatp);
wcscon1.c:/* Make 3-D rotation matrix from up to three rotations */
wcscon1.c:	iaxes = iaxes - (100 * axis[0]);
wcscon1.c:	iaxes = iaxes - (10 * axis[naxis]);
wcscon1.c:	    matn[7] = -srot;
wcscon1.c:	    matn[2] = -srot;
wcscon1.c:	    matn[3] = -srot;
wcscon1.c:	*rra = *rra - (2.0 * PI);
wcscon1.c: * Apr 26 1996	Add FK4 <-> FK5 subroutines for use when epoch is known
wcscon1.c: * Apr 28 1998	Return -1 from wcscsys if not a legal coordinate system
wcscon1.c: * Sep 14 2000	Return -1 from wcscsys if equinox is less than 1900.0
wcscon.c: *** Doug Mink, Harvard-Smithsonian Center for Astrophysics
wcscon.c: *** Copyright (C) 1995-2010
wcscon.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcscon.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon.c:		    *dtheta = *dtheta + ((ep2 - 1950.0) * *ptheta);
wcscon.c:		    *dphi = *dphi + ((ep2 - 1950.0) * *pphi);
wcscon.c:		    *dtheta = *dtheta + ((ep2 - 2000.0) * *ptheta);
wcscon.c:		    *dphi = *dphi + ((ep2 - 2000.0) * *pphi);
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:    /* Keep latitude/declination between +90 and -90 degrees */
wcscon.c:	*dphi = 180.0 - *dphi;
wcscon.c:    else if (*dphi < -90.0) {
wcscon.c:	*dphi = -180.0 - *dphi;
wcscon.c:	*dtheta = *dtheta - 360.0;
wcscon.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon.c:		*dtheta = *dtheta + ((ep2 - ep1) * *ptheta);
wcscon.c:		*dphi = *dphi + ((ep2 - ep1) * *pphi);
wcscon.c:		    *dtheta = *dtheta + ((ep2 - 1950.0) * *ptheta);
wcscon.c:		    *dphi = *dphi + ((ep2 - 1950.0) * *pphi);
wcscon.c:		    *dtheta = *dtheta + ((ep2 - 2000.0) * *ptheta);
wcscon.c:		    *dphi = *dphi + ((ep2 - 2000.0) * *pphi);
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:		*dtheta = *dtheta + (*ptheta * (ep2 - ep1));
wcscon.c:		*dphi = *dphi + (*pphi * (ep2 - ep1));
wcscon.c:    /* Keep latitude/declination between +90 and -90 degrees */
wcscon.c:	*dphi = 180.0 - *dphi;
wcscon.c:    else if (*dphi < -90.0) {
wcscon.c:	*dphi = -180.0 - *dphi;
wcscon.c:	*dtheta = *dtheta - 360.0;
wcscon.c:    /* Keep latitude/declination between +90 and -90 degrees */
wcscon.c:	*dphi = 180.0 - *dphi;
wcscon.c:    else if (*dphi < -90.0) {
wcscon.c:	*dphi = -180.0 - *dphi;
wcscon.c:	*dtheta = *dtheta - 360.0;
wcscon.c:	    return -1;
wcscon.c:	return -1;
wcscon.c:static double a[3] = {-1.62557e-6, -0.31919e-6, -0.13843e-6};
wcscon.c:static double ad[3] = {1.245e-3,  -1.580e-3,  -0.659e-3};
wcscon.c:static double tiny = 1.e-30; /* small number to avoid arithmetic problems */
wcscon.c:	-0.00000242389840,	/* emi[0][3] */
wcscon.c:	-0.00000002710544,	/* emi[0][4] */
wcscon.c:	-0.00000001177742 },	/* emi[0][5] */
wcscon.c:    {	-0.0111814828,		/* emi[1][0] */
wcscon.c:	-0.0000271771,		/* emi[1][2] */
wcscon.c:	-0.00000242392702,	/* emi[1][4] */
wcscon.c:    {	-0.0048590040,		/* emi[2][0] */
wcscon.c:	-0.0000271557,		/* emi[2][1] */
wcscon.c:	-0.00000242404995 },	/* emi[2][5] */
wcscon.c:    {	-0.000551,		/* emi[3][0] */
wcscon.c:	-0.435614,		/* emi[3][2] */
wcscon.c:    {	-0.238560,		/* emi[4][0] */
wcscon.c:	-0.002667,		/* emi[4][1] */
wcscon.c:	-0.01118145,		/* emi[4][3] */
wcscon.c:	-0.00002717 },		/* emi[4][5] */
wcscon.c:	-0.008541,		/* emi[5][1] */
wcscon.c:	-0.00485852,		/* emi[5][3] */
wcscon.c:	-0.00002716,		/* emi[5][4] */
wcscon.c:    *ra = *ra + (rapm * (epoch - 1950.0));
wcscon.c:    *dec = *dec + (decpm * (epoch - 1950.0));
wcscon.c:    system, to the old Bessel-Newcomb FK4 system, using Yallop's
wcscon.c:    motion, and e-terms routines before and/or after fk524 is called.
wcscon.c:    of the poles do not embody the differential e-term effect and should,
wcscon.c:    the polar and non-polar regions, the likelihood that the differential
wcscon.c:    e-terms effect was not taken into account when allowing for proper motion
wcscon.c:    effect of differential e-terms on the proper motions for all stars,
wcscon.c: 	  Astronomical Journal vol. 97, Jan. 1989, p. 265-273.
wcscon.c: 	  FK5 J2000.0 using matrices in 6-space."  Yallop, B.D.;
wcscon.c:	  p. 274-279.
wcscon.c:         the Astronomical Almanac", ISBN 0-935702-68-7.
wcscon.c:	  Astrophysics, vol. 115, no. 1, Nov. 1982, p. 20-22.
wcscon.c:	v1[3] = -(ur*y) - (cr*sd*ud);
wcscon.c:	v1[4] =  (ur*x) - (sr*sd*ud);
wcscon.c:    /* Apply e-terms to position */
wcscon.c:    x = x + (a[0] * rxyz) - (w * x);
wcscon.c:    y = y + (a[1] * rxyz) - (w * y);
wcscon.c:    z = z + (a[2] * rxyz) - (w * z);
wcscon.c:    /* Apply e-terms to position and velocity */
wcscon.c:    x = x + (a[0] * rxyz) - (w * x);
wcscon.c:    y = y + (a[1] * rxyz) - (w * y);
wcscon.c:    z = z + (a[2] * rxyz) - (w * z);
wcscon.c:    xd = v2[3] + (ad[0] * rxyz) - (wd * x);
wcscon.c:    yd = v2[4] + (ad[1] * rxyz) - (wd * y);
wcscon.c:    zd = v2[5] + (ad[2] * rxyz) - (wd * z);
wcscon.c:	ur = (x*yd - y*xd) / rxysq;
wcscon.c:	ud = (zd*rxysq - z * (x*xd + y*yd)) / ((rxysq + z*z) * rxy);
wcscon.c:	dra = 240.0 * raddeg (r1950 - r2000);
wcscon.c:	ddec = 3600.0 * raddeg (d1950 - d2000);
wcscon.c:	fprintf(stderr,"B1950-J2000: dra= %11.5f sec  ddec= %f11.5f arcsec\n",
wcscon.c:	-0.0111820611,		/* em[0][1] */
wcscon.c:	-0.0048579477,		/* em[0][2] */
wcscon.c:	-0.00000002710663,	/* em[0][4] */
wcscon.c:	-0.00000001177656 },	/* em[0][5] */
wcscon.c:	-0.0000271765,		/* em[1][2] */
wcscon.c:	-0.00000000006587 },	/* em[1][5] */
wcscon.c:	-0.0000271474,		/* em[2][1] */
wcscon.c:	-0.00000000006582,	/* em[2][4] */
wcscon.c:    {	-0.000551,		/* em[3][0] */
wcscon.c:	-0.238565,		/* em[3][1] */
wcscon.c:	-0.01118251,		/* em[3][4] */
wcscon.c:	-0.00485767 },		/* em[3][5] */
wcscon.c:	-0.002667,		/* em[4][1] */
wcscon.c:	-0.008541,		/* em[4][2] */
wcscon.c:	-0.00002718 },		/* em[4][5] */
wcscon.c:    {	-0.435623,		/* em[5][0] */
wcscon.c:	-0.00002714,		/* em[5][4] */
wcscon.c:    *ra = *ra + (rapm * (epoch - 2000.0));
wcscon.c:    *dec = *dec + (decpm * (epoch - 2000.0));
wcscon.c:/*  This routine converts stars from the old Bessel-Newcomb FK4 system
wcscon.c:    motion, and e-terms routines before and/or after fk425 is called.
wcscon.c:    of the poles do not embody the differential e-term effect and should,
wcscon.c:    the polar and non-polar regions, the likelihood that the differential
wcscon.c:    e-terms effect was not taken into account when allowing for proper motion
wcscon.c:    effect of differential e-terms on the proper motions for all stars,
wcscon.c: 	  Astronomical Journal vol. 97, Jan. 1989, p. 265-273.
wcscon.c: 	  FK5 J2000.0 using matrices in 6-space."  Yallop, B.D.;
wcscon.c:	  p. 274-279.
wcscon.c:	  Astrophysics, vol. 115, no. 1, Nov. 1982, p. 20-22.
wcscon.c:	rd0[0] = (-sr * cd * ur) - (cr * sd * ud) + (w * r0[0]);
wcscon.c:	rd0[1] =  (cr * cd * ur) - (sr * sd * ud) + (w * r0[1]);
wcscon.c:    /* Remove e-terms from position and express as position+velocity 6-vector */
wcscon.c:	v1[i] = r0[i] - a[i] + (w * r0[i]);
wcscon.c:    /* Remove e-terms from proper motion and express as 6-vector */
wcscon.c:	v1[i+3] = rd0[i] - ad[i] + (wd * r0[i]);
wcscon.c:    /* Alternately: Put proper motion in 6-vector without adding e-terms
wcscon.c:	ur = ((x * yd) - (y * xd)) / rxysq;
wcscon.c:	ud = ((zd * rxysq) - (z * spxy)) / (rxyzsq * rxy);
wcscon.c:	dra = 240.0 * raddeg (r2000 - r1950);
wcscon.c:	ddec = 3600.0 * raddeg (d2000 - d1950);
wcscon.c:	fprintf(stderr,"J2000-B1950: dra= %11.5f sec  ddec= %f11.5f arcsec\n",
wcscon.c:    (The Eulerian angles are p, q, 90-r)
wcscon.c:	+cp.cq.sr-sp.cr	+sp.cq.sr+cp.cr	-sq.sr
wcscon.c:	-cp.cq.cr-sp.sr	-sp.cq.cr+cp.sr	+sq.cr
wcscon.c:	{{-0.066988739415,-0.872755765852,-0.483538914632},
wcscon.c:	{0.492728466075,-0.450346958020, 0.744584633283},
wcscon.c:	{-0.867600811151,-0.188374601723, 0.460199784784}};
wcscon.c:/*---  Transform B1950.0 FK4 equatorial coordinates to
wcscon.c:    /*  remove e-terms */
wcscon.c:    /*	call jpabe (rra,rdec,-1,idg) */
wcscon.c:/*--- Transform IAU 1958 galactic coordinates to B1950.0 'FK4'
wcscon.c:/*  introduce e-terms */
wcscon.c:/*	jpabe (rra,rdec,-1,idg); */
wcscon.c:    The eulerian angles are p, q, 90-r
wcscon.c:	+cp.cq.sr-sp.cr     +sp.cq.sr+cp.cr     -sq.sr
wcscon.c:	-cp.cq.cr-sp.sr     -sp.cq.cr+cp.sr     +sq.cr
wcscon.c:	{{-0.054875539726,-0.873437108010,-0.483834985808},
wcscon.c:	{0.494109453312,-0.444829589425, 0.746982251810},
wcscon.c:	{-0.867666135858,-0.198076386122, 0.455983795705}};
wcscon.c:/*--- Transform IAU 1958 galactic coordinates to J2000 equatorial coordinates */
wcscon.c:    xp = (double) 60.0 * (xpos - (double) rah);
wcscon.c:    ras = (double) 60.0 * (xp - (double) irm);
wcscon.c:	ypos = -ddec;
wcscon.c:	decp = '-';
wcscon.c:    yp = (double) 60.0 * (ypos - (double) decd);
wcscon.c:    decs = (double) 60.0 * (yp - (double) decm);
wcscon.c:    t = (epoch - 2000.0) * 0.01;
wcscon.c:    eps0 = secrad ((84381.448 + (-46.8150 + (-0.00059 + 0.001813*t) * t) * t));
wcscon.c:    t = (epoch - 2000.0) * 0.01;
wcscon.c:    eps0 = secrad ((84381.448 + (-46.8150 + (-0.00059 + 0.001813*t) * t) * t));
wcscon.c:**  Precession - FK4 (Bessel-Newcomb, pre-IAU1976)
wcscon.c:**  Precession -  FK5 (Fricke, post-IAU1976)
wcscon.c:**  using the old, pre-IAU1976, Bessel-Newcomb model, using
wcscon.c:    bigt  = ( bep0 - 1850.0 ) / 100.0;
wcscon.c:    t = ( bep1 - bep0 ) / 100.0;
wcscon.c:    zeta = (w + ( 0.30242 - 0.000269 * bigt + 0.017996 * t ) * t ) * tas2r;
wcscon.c:    theta = ( 2005.1125 + ( - 0.85294 - 0.000365* bigt ) * bigt +
wcscon.c:	    ( - 0.42647 - 0.000365 * bigt - 0.041802 * t ) * t ) * tas2r;
wcscon.c:    rotmat (323, -zeta, theta, -z, rmatp);
wcscon.c:    t0 = ( ep0 - 2000.0 ) / 100.0;
wcscon.c:    t =  ( ep1 - ep0 ) / 100.0;
wcscon.c:    w = 2306.2181 + ( ( 1.39656 - ( 0.000139 * t0 ) ) * t0 );
wcscon.c:    zeta = (w + ( ( 0.30188 - 0.000344 * t0 ) + 0.017998 * t ) * t ) * tas2r;
wcscon.c:    theta = ( ( 2004.3109 + ( - 0.85330 - 0.000217 * t0 ) * t0 )
wcscon.c:	  + ( ( -0.42665 - 0.000217 * t0 ) - 0.041833 * t ) * t ) * tas2r;
wcscon.c:    rotmat (323, -zeta, theta, -z, rmatp);
wcscon.c:/* Make 3-D rotation matrix from up to three rotations */
wcscon.c:	iaxes = iaxes - (100 * axis[0]);
wcscon.c:	iaxes = iaxes - (10 * axis[naxis]);
wcscon.c:	    matn[7] = -srot;
wcscon.c:	    matn[2] = -srot;
wcscon.c:	    matn[3] = -srot;
wcscon.c:	//*rra = *rra - (2.0 * PI);
wcscon.c:	*rra = *rra - (2.0 * WCS_PI);
wcscon.c: * Apr 26 1996	Add FK4 <-> FK5 subroutines for use when epoch is known
wcscon.c: * Apr 28 1998	Return -1 from wcscsys if not a legal coordinate system
wcscon.c: * Sep 14 2000	Return -1 from wcscsys if equinox is less than 1900.0
wcscon.c: * Mar 29 2010	Fix bug in computing the magnitude of the e-terms in fk524()
wcs.h: *** Harvard-Smithsonian Center for Astrophysics
wcs.h: *** Copyright (C) 1994-2013
wcs.h:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcs.h:  double	nxpix;		/* Number of pixels in X-dimension of image */
wcs.h:  double	nypix;		/* Number of pixels in Y-dimension of image */
wcs.h:  int		pvfail;		/* If non-zero, significant inaccuracy likely to occur in projection */
wcs.h:  int		prjcode;	/* projection code (-1-32) */
wcs.h:  int		latbase;	/* Latitude base 90 (NPA), 0 (LAT), -90 (SPA) */
wcs.h:  int		ncoeff1;	/* Number of x-axis plate fit coefficients */
wcs.h:  int		ncoeff2;	/* Number of y-axis plate fit coefficients */
wcs.h:  int		zpnp;		 /* ZP polynomial order (0-9) */
wcs.h:  int		changesys;	/* 1 for FK4->FK5, 2 for FK5->FK4 */
wcs.h:  				/* 3 for FK4->galactic, 4 for FK5->galactic */
wcs.h:					RA--, GLON, ELON */
wcs.h:					DEC-, GLAT, ELAT */
wcs.h:  char		radecsys[32];	/* Reference frame: FK4, FK4-NO-E, FK5, GAPPT*/
wcs.h:  char		wcschar;	/* WCS character (A-Z, null, space) */
wcs.h:  int		logwcs;		/* 1 if DC-FLAG is set for log wavelength */
wcs.h:/* Projections (1-26 are WCSLIB) (values for wcs->prjcode) */
wcs.h:#define WCS_PIX -1	/* Pixel WCS */
wcs.h:#define WCS_SFL 20	/* Sanson-Flamsteed (GLobal Sinusoidal) */
wcs.h:#define WCS_AIT 22	/* Hammer-Aitoff */
wcs.h:#define NWCSTYPE 34	/* Number of WCS types (-1 really means no WCS) */
wcs.h:#define WCS_XY		10	/* X-Y Cartesian coordinates */
wcs.h:/* Distortion codes (values for wcs->distcode) */
wcs.h:#define AS2R		4.8481368110953e-6
wcs.h:  double xrange;	/* 2. / (xmax - xmin), polynomials */
wcs.h:  double xmaxmin;	/* - (xmax + xmin) / 2., polynomials */
wcs.h:  double yrange;	/* 2. / (ymax - ymin), polynomials */
wcs.h:  double ymaxmin;	/* - (ymax + ymin) / 2., polynomials */
wcs.h:/* TNX/ZPX cross-terms flags */
wcs.h:#define	TNX_XNONE	0	/* no x-terms (old no) */
wcs.h:#define	TNX_XFULL	1	/* full x-terms (new yes) */
wcs.h:#define	TNX_XHALF	2	/* half x-terms (new) */
wcs.h:	char *wcschar);		/* WCS character (A-Z) */
wcs.h:	char *wcschar);		/* WCS character (A-Z) */
wcs.h:        int nxpix,	/* Number of pixels along x-axis */
wcs.h:        int nypix,	/* Number of pixels along y-axis */
wcs.h:	int naxis1,	/* Number of pixels along x-axis */
wcs.h:	int naxis2,	/* Number of pixels along y-axis */
wcs.h:        double *dra,	/* Half-width in right ascension (deg) (returned) */
wcs.h:        double *ddec);	/* Half-width in declination (deg) (returned) */
wcs.h:    void wcscominit(	/* Initialize catalog search command set by -wcscom */
wcs.h:	int i,		/* Number of command (0-9) to initialize */
wcs.h:    void wcscom(	/* Execute catalog search command set by -wcscom */
wcs.h:	int i,		/* Number of command (0-9) to execute */
wcs.h:    int DelDistort (	/* Delete all distortion-related fields */
wcs.h:void wcscominit();	/* Initialize catalog search command set by -wcscom */
wcs.h:void wcscom();		/* Execute catalog search command set by -wcscom */
wcs.h:int DelDistort();	/* Delete all distortion-related fields */
wcs.h:void pix2foc();		/*  pixel coordinates -> focal plane coordinates */
wcs.h:void foc2pix();		/*  focal plane coordinates -> pixel coordinates */
wcs.h: * Aug  5 1996	Add WCSNINIT to initialize WCS for non-terminated header
wcs.h: * May 22 1997	Change range of pcode from 1-8 to -1-8 for linear transform
wcs.h: * Sep 14 1998	Add latbase for AXAF North Polar angle (NPOL not LAT-)
wcs.h: * Feb 20 2001	Add wcs->wcs to main data structure
wcs.h: * Apr  9 2002	Add wcs->wcsdep for pointer to WCS depending on this WCS
wcs.h: * Apr 26 2002	Add wcs->wcsname and wcs->wcschar to identify WCS structure
wcs.h: * May  9 2002	Add wcs->radvel and wcs->zvel for radial velocity in km/sec
wcs.h: * Apr  1 2003	Add wcs->distort Distort structure for distortion correction
wcs.h: * Oct  1 2003	Rename wcs->naxes to wcs->naxis to match WCSLIB 3.2
wcs.h: * Dec  3 2003	Add back wcs->naxes for backward compatibility
wcs.h: * Jul 25 2007	Add v2s3(), s2v3(), d2v3(), v2d3() for coordinate-vector conversion
wcsinit.c: *** Harvard-Smithsonian Center for Astrophysics
wcsinit.c: *** Copyright (C) 1998-2013
wcsinit.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcsinit.c: * Subroutine:	wcsninit (hstring,lh) sets a WCS structure from fixed-length header
wcsinit.c:/* WCSCHAR -- Find the letter for a specific WCS conversion */
wcsinit.c:			   (case-independent) */
wcsinit.c:	    upstring[i] = string[i] - 32;
wcsinit.c:    wcs->wcschar = mchar;
wcsinit.c:	wcs->wcsname = (char *) calloc (strlen (wcsname)+2, 1);
wcsinit.c:	strcpy (wcs->wcsname, wcsname);
wcsinit.c:    wcs->cel.flag = 0;
wcsinit.c:    wcs->lin.flag = 0;
wcsinit.c:    wcs->wcsl.flag = 0;
wcsinit.c:    wcs->wcsl.cubeface = -1;
wcsinit.c:    wcs->ncoeff1 = 0;
wcsinit.c:    wcs->ncoeff2 = 0;
wcsinit.c:    wcs->rotmat = 0;
wcsinit.c:    wcs->rot = 0.0;
wcsinit.c:    wcs->naxis = naxes;
wcsinit.c:    wcs->naxes = naxes;
wcsinit.c:    wcs->lin.naxis = naxes;
wcsinit.c:    wcs->nxpix = 0;
wcsinit.c:    hgetr8 (hstring, "NAXIS1", &wcs->nxpix);
wcsinit.c:    if (wcs->nxpix < 1)
wcsinit.c:	hgetr8 (hstring, "IMAGEW", &wcs->nxpix);
wcsinit.c:    if (wcs->nxpix < 1) {
wcsinit.c:    wcs->nypix = 0;
wcsinit.c:    hgetr8 (hstring, "NAXIS2", &wcs->nypix);
wcsinit.c:    if (wcs->nypix < 1)
wcsinit.c:	hgetr8 (hstring, "IMAGEH", &wcs->nypix);
wcsinit.c:    if (naxes > 1 && wcs->nypix < 1) {
wcsinit.c:	    if (i == 0 && wcs->nxpix > 1) {
wcsinit.c:			 keyword, wcs->nxpix); */
wcsinit.c:		j = wcs->nxpix;
wcsinit.c:	    else if (i == 1 && wcs->nypix > 1) {
wcsinit.c:			 keyword, wcs->nypix); */
wcsinit.c:		j = wcs->nypix;
wcsinit.c:	    if (strsrch (temp, "-TAB"))
wcsinit.c:    wcs->naxes = nax;
wcsinit.c:    wcs->naxis = nax;
wcsinit.c:    hgets (hstring, "INSTRUME", 16, wcs->instrument);
wcsinit.c:    hgeti4 (hstring, "DETECTOR", &wcs->detector);
wcsinit.c:    wcs->wcsproj = getdefwcs();
wcsinit.c:    wcs->logwcs = 0;
wcsinit.c:    hgeti4 (hstring, "DC-FLAG", &wcs->logwcs);
wcsinit.c:    for (i = 0; i < 81; i++) wcs->pc[i] = 0.0;
wcsinit.c:    for (i = 0; i < naxes; i++) wcs->pc[(i*naxes)+i] = 1.0;
wcsinit.c:    for (i = 0; i < 9; i++) wcs->cdelt[i] = 0.0;
wcsinit.c:    for (i = 0; i < naxes; i++) wcs->cdelt[i] = 1.0;
wcsinit.c:	if ((wcs->wcs = wcsinitn (hstring, wcsname)) == NULL) {
wcsinit.c:	depwcs = wcs->wcs;
wcsinit.c:	depwcs->wcsdep = wcs;
wcsinit.c:	wcs->wcs = NULL;
wcsinit.c:    wcs->radvel = 0.0;
wcsinit.c:    wcs->zvel = 0.0;
wcsinit.c:    if (hgetr8c (hstring, "VSOURCE", &mchar, &wcs->radvel))
wcsinit.c:	wcs->zvel = wcs->radvel / cvel;
wcsinit.c:    else if (hgetr8c (hstring, "ZSOURCE", &mchar, &wcs->zvel))
wcsinit.c:	wcs->radvel = wcs->zvel * cvel;
wcsinit.c:    else if (hgetr8 (hstring, "VELOCITY", &wcs->radvel))
wcsinit.c:	wcs->zvel = wcs->radvel / cvel;
wcsinit.c:	wcs->prj.p[i] = 0.0;
wcsinit.c:	strcpy (wcs->ctype[0], ctype1);
wcsinit.c:	strcpy (wcs->ctype[1], ctype2);
wcsinit.c:	strcpy (wcs->ctype[2], "");
wcsinit.c:	hgetsc (hstring, "CTYPE3", &mchar, 9, wcs->ctype[2]);
wcsinit.c:	strcpy (wcs->ctype[3], "");
wcsinit.c:	hgetsc (hstring, "CTYPE4", &mchar, 9, wcs->ctype[3]);
wcsinit.c:	if (wcs->prjcode == WCS_LIN) {
wcsinit.c:	    if (!hgetsc (hstring, "CUNIT1", &mchar, 16, wcs->units[0])) {
wcsinit.c:		if (!mgetstr (hstring, "WAT1", "units", 16, wcs->units[0])) {
wcsinit.c:		    wcs->units[0][0] = 0;
wcsinit.c:	    if (!strcmp (wcs->units[0], "pixel"))
wcsinit.c:		wcs->prjcode = WCS_PIX;
wcsinit.c:		if (!hgetsc (hstring, "CUNIT2", &mchar, 16, wcs->units[1])) {
wcsinit.c:		    if (!mgetstr (hstring, "WAT2", "units", 16, wcs->units[1])) {
wcsinit.c:			wcs->units[1][0] = 0;
wcsinit.c:		if (!strcmp (wcs->units[0], "pixel"))
wcsinit.c:		    wcs->prjcode = WCS_PIX;
wcsinit.c:	wcs->crpix[0] = 1.0;
wcsinit.c:	hgetr8c (hstring, "CRPIX1", &mchar, &wcs->crpix[0]);
wcsinit.c:	wcs->crpix[1] = 1.0;
wcsinit.c:	hgetr8c (hstring, "CRPIX2", &mchar, &wcs->crpix[1]);
wcsinit.c:	wcs->xrefpix = wcs->crpix[0];
wcsinit.c:	wcs->yrefpix = wcs->crpix[1];
wcsinit.c:	wcs->crval[0] = 0.0;
wcsinit.c:	hgetr8c (hstring, "CRVAL1", &mchar, &wcs->crval[0]);
wcsinit.c:	wcs->crval[1] = 0.0;
wcsinit.c:	hgetr8c (hstring, "CRVAL2", &mchar, &wcs->crval[1]);
wcsinit.c:	if (wcs->syswcs == WCS_NPOLE)
wcsinit.c:	    wcs->crval[1] = 90.0 - wcs->crval[1];
wcsinit.c:	if (wcs->syswcs == WCS_SPA)
wcsinit.c:	    wcs->crval[1] = wcs->crval[1] - 90.0;
wcsinit.c:	wcs->xref = wcs->crval[0];
wcsinit.c:	wcs->yref = wcs->crval[1];
wcsinit.c:	if (wcs->coorflip) {
wcsinit.c:	    wcs->cel.ref[0] = wcs->crval[1];
wcsinit.c:	    wcs->cel.ref[1] = wcs->crval[0];
wcsinit.c:	    wcs->cel.ref[0] = wcs->crval[0];
wcsinit.c:	    wcs->cel.ref[1] = wcs->crval[1];
wcsinit.c:	wcs->longpole = 999.0;
wcsinit.c:	hgetr8c (hstring, "LONPOLE", &mchar, &wcs->longpole);
wcsinit.c:	wcs->cel.ref[2] = wcs->longpole;
wcsinit.c:	wcs->latpole = 999.0;
wcsinit.c:	hgetr8c (hstring, "LATPOLE", &mchar, &wcs->latpole);
wcsinit.c:	wcs->cel.ref[3] = wcs->latpole;
wcsinit.c:	wcs->lin.crpix = wcs->crpix;
wcsinit.c:	wcs->lin.cdelt = wcs->cdelt;
wcsinit.c:	wcs->lin.pc = wcs->pc;
wcsinit.c:	/* Projection constants (this should be projection-dependent */
wcsinit.c:	wcs->prj.r0 = 0.0;
wcsinit.c:	hgetr8c (hstring, "PROJR0", &mchar, &wcs->prj.r0);
wcsinit.c:	    hgetr8c (hstring, keyword, &mchar, &wcs->prj.p[i]);
wcsinit.c:	/* FITS WCS standard projection constants (projection-dependent) */
wcsinit.c:	if (wcs->prjcode == WCS_AZP || wcs->prjcode == WCS_SIN ||
wcsinit.c:	    wcs->prjcode == WCS_COP || wcs->prjcode == WCS_COE ||
wcsinit.c:	    wcs->prjcode == WCS_COD || wcs->prjcode == WCS_COO) {
wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
wcsinit.c:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
wcsinit.c:	else if (wcs->prjcode == WCS_SZP) {
wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
wcsinit.c:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
wcsinit.c:	    if (wcs->prj.p[3] == 0.0)
wcsinit.c:		wcs->prj.p[3] = 90.0;
wcsinit.c:	    hgetr8c (hstring, pvkey3, &mchar, &wcs->prj.p[3]);
wcsinit.c:	else if (wcs->prjcode == WCS_CEA) {
wcsinit.c:	    if (wcs->prj.p[1] == 0.0)
wcsinit.c:		wcs->prj.p[1] = 1.0;
wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
wcsinit.c:	else if (wcs->prjcode == WCS_CYP) {
wcsinit.c:	    if (wcs->prj.p[1] == 0.0)
wcsinit.c:		wcs->prj.p[1] = 1.0;
wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
wcsinit.c:	    if (wcs->prj.p[2] == 0.0)
wcsinit.c:		wcs->prj.p[2] = 1.0;
wcsinit.c:	    hgetr8c (hstring, pvkey2, &mchar, &wcs->prj.p[2]);
wcsinit.c:	else if (wcs->prjcode == WCS_AIR) {
wcsinit.c:	    if (wcs->prj.p[1] == 0.0)
wcsinit.c:		wcs->prj.p[1] = 90.0;
wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
wcsinit.c:	else if (wcs->prjcode == WCS_BON) {
wcsinit.c:	    hgetr8c (hstring, pvkey1, &mchar, &wcs->prj.p[1]);
wcsinit.c:	else if (wcs->prjcode == WCS_ZPN) {
wcsinit.c:		hgetr8c (hstring, keyword, &mchar, &wcs->prj.p[i]);
wcsinit.c:	if (wcs->prjcode == WCS_TNX) {
wcsinit.c:		wcs->ctype[0][6] = 'A';
wcsinit.c:		wcs->ctype[0][7] = 'N';
wcsinit.c:		wcs->ctype[1][6] = 'A';
wcsinit.c:		wcs->ctype[1][7] = 'N';
wcsinit.c:		wcs->prjcode = WCS_TAN;
wcsinit.c:	if (wcs->prjcode == WCS_ZPX) {
wcsinit.c:		wcs->ctype[0][7] = 'N';
wcsinit.c:		wcs->ctype[1][7] = 'N';
wcsinit.c:		wcs->prjcode = WCS_ZPN;
wcsinit.c:	if (wcs->prjcode == WCS_TPV) {
wcsinit.c:	    wcs->ctype[0][6] = 'A';
wcsinit.c:	    wcs->ctype[0][7] = 'N';
wcsinit.c:	    wcs->ctype[1][6] = 'A';
wcsinit.c:	    wcs->ctype[1][7] = 'N';
wcsinit.c:	    wcs->prjcode = WCS_TAN;
wcsinit.c:	if (wcs->wcsproj > 0)
wcsinit.c:	wcs->ncoeff1 = 0;
wcsinit.c:	wcs->ncoeff2 = 0;
wcsinit.c:	if (wcs->wcsproj != WCS_OLD &&
wcsinit.c:	    wcs->prjcode = WCS_PLT;
wcsinit.c:	    (void)strcpy (wcs->ptype, "PLATE");
wcsinit.c:		wcs->x_coeff[i] = 0.0;
wcsinit.c:		if (hgetr8 (hcoeff, keyword, &wcs->x_coeff[i]))
wcsinit.c:		    wcs->ncoeff1 = i + 1;
wcsinit.c:		wcs->y_coeff[i] = 0.0;
wcsinit.c:		if (hgetr8 (hcoeff, keyword, &wcs->y_coeff[i]))
wcsinit.c:		    wcs->ncoeff2 = i + 1;
wcsinit.c:	    platepos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
wcsinit.c:	    platepos (wcs->crpix[0], wcs->crpix[1]+1.0, wcs, &ra1, &dec1);
wcsinit.c:	    wcs->yinc = dec1 - dec0;
wcsinit.c:	    wcs->xinc = -wcs->yinc;
wcsinit.c:	    wcs->wcson = 1;
wcsinit.c:	    rot = degrad (wcs->rot);
wcsinit.c:	    platepos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
wcsinit.c:	    platepos (wcs->crpix[0]+cos(rot),
wcsinit.c:		      wcs->crpix[1]+sin(rot), wcs, &ra1, &dec1);
wcsinit.c:	    wcs->cdelt[0] = -wcsdist (ra0, dec0, ra1, dec1);
wcsinit.c:	    wcs->xinc = wcs->cdelt[0];
wcsinit.c:	    platepos (wcs->crpix[0]+sin(rot),
wcsinit.c:		      wcs->crpix[1]+cos(rot), wcs, &ra1, &dec1);
wcsinit.c:	    wcs->cdelt[1] = wcsdist (ra0, dec0, ra1, dec1);
wcsinit.c:	    wcs->yinc = wcs->cdelt[1];
wcsinit.c:	    wcs->cd[0] = cd[0];
wcsinit.c:	    wcs->cd[1] = cd[1];
wcsinit.c:	    wcs->cd[2] = cd[2];
wcsinit.c:	    wcs->cd[3] = cd[3];
wcsinit.c:	    (void) matinv (2, wcs->cd, wcs->dc);
wcsinit.c:	    wcs->rotmat = 1;
wcsinit.c:	    if (cdelt1 == 0.0 || (wcs->nypix > 1 && cdelt2 == 0.0)) {
wcsinit.c:				cdelt1 = -secpix / 3600.0;
wcsinit.c:				    cdelt1 = -secpix / 3600.0;
wcsinit.c:				    cdelt1 = -secpix / 3600.0;
wcsinit.c:			    cdelt1 = -secpix / 3600.0;
wcsinit.c:	    if (cdelt2 == 0.0 && wcs->nypix > 1)
wcsinit.c:		cdelt2 = -cdelt1;
wcsinit.c:	    wcs->cdelt[2] = 1.0;
wcsinit.c:	    wcs->cdelt[3] = 1.0;
wcsinit.c:		wcs->pc[i] = 0.0;
wcsinit.c:	    wcs->xinc = 1.0;
wcsinit.c:	    wcs->yinc = 1.0;
wcsinit.c:	    wcs->cdelt[0] = 1.0;
wcsinit.c:	    wcs->cdelt[1] = 1.0;
wcsinit.c:	    wcs->rot = 0.0;
wcsinit.c:	    wcs->rotmat = 0;
wcsinit.c:	if (wcs->prjcode == WCS_TAN && wcs->naxis == 2) { 
wcsinit.c:	    if (wcs->inv_x) {
wcsinit.c:		poly_end(wcs->inv_x);
wcsinit.c:		wcs->inv_x = NULL;
wcsinit.c:	    if (wcs->inv_y) {
wcsinit.c:		poly_end(wcs->inv_y);
wcsinit.c:		wcs->inv_y = NULL;
wcsinit.c:	    wcs->pvfail = 0;
wcsinit.c:		wcs->projppv[i] = 0.0;
wcsinit.c:		wcs->prj.ppv[i] = 0.0;
wcsinit.c:		    if (hgetr8c(hstring, keyword,&mchar, &wcs->projppv[j+k*MAXPV]) == 0) {
wcsinit.c:			wcs->projppv[j+k*MAXPV] = 0.0;
wcsinit.c:	    if (n > 0 && wcs->distcode != DISTORT_SIRTF) {
wcsinit.c:		for (k = MAXPV; k >= 0; k--) {
wcsinit.c:		    wcs->prj.ppv[k] = wcs->projppv[k+wcs->wcsl.lat*MAXPV];
wcsinit.c:		    wcs->prj.ppv[k+MAXPV] = wcs->projppv[k+wcs->wcsl.lng*MAXPV];
wcsinit.c:		    if (!n && (wcs->prj.ppv[k] || wcs->prj.ppv[k+MAXPV]))  {
wcsinit.c:		wcs->cel.flag = 0;
wcsinit.c:	if (!strncmp (wcs->ptype,"LINEAR",6) ||
wcsinit.c:	    !strncmp (wcs->ptype,"PIXEL",5)) {
wcsinit.c:	    wcs->degout = -1;
wcsinit.c:	    wcs->ndec = 5;
wcsinit.c:	if (hgetr8 (hstring, "MJD-OBS", &mjd))
wcsinit.c:	    wcs->epoch = 1900.0 + (mjd - 15019.81352) / 365.242198781;
wcsinit.c:	else if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
wcsinit.c:	    if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
wcsinit.c:		if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
wcsinit.c:		    wcs->epoch = wcs->equinox;
wcsinit.c:	/* Add time of day if not part of DATE-OBS string */
wcsinit.c:	    hgets (hstring,"DATE-OBS",32,tstring);
wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
wcsinit.c:	wcs->wcson = 1;
wcsinit.c:	wcs->prjcode = WCS_DSS;
wcsinit.c:	wcs->plate_ra = hrrad (ra_hours);
wcsinit.c:	if (decsign == '-')
wcsinit.c:	    dsign = -1.;
wcsinit.c:	wcs->plate_dec = degrad (dec_deg);
wcsinit.c:	hgetr8 (hstring,"EQUINOX",&wcs->equinox);
wcsinit.c:	    strcpy (wcs->radecsys,"FK4");
wcsinit.c:	    strcpy (wcs->radecsys,"FK5");
wcsinit.c:	wcs->epoch = wcs->equinox;
wcsinit.c:	hgetr8 (hstring,"EPOCH",&wcs->epoch);
wcsinit.c:	(void)sprintf (wcs->center,"%2.0f:%2.0f:%5.3f %c%2.0f:%2.0f:%5.3f %s",
wcsinit.c:		       rah,ram,ras,decsign,decd,decm,decs,wcs->radecsys);
wcsinit.c:	hgetr8 (hstring,"PLTSCALE",&wcs->plate_scale);
wcsinit.c:	hgetr8 (hstring,"XPIXELSZ",&wcs->x_pixel_size);
wcsinit.c:	hgetr8 (hstring,"YPIXELSZ",&wcs->y_pixel_size);
wcsinit.c:	hgetr8 (hstring,"CNPIX1",&wcs->x_pixel_offset);
wcsinit.c:	hgetr8 (hstring,"CNPIX2",&wcs->y_pixel_offset);
wcsinit.c:	    wcs->ppo_coeff[i] = 0.0;
wcsinit.c:	    hgetr8 (hcoeff,keyword,&wcs->ppo_coeff[i]);
wcsinit.c:	    wcs->x_coeff[i] = 0.0;
wcsinit.c:	    hgetr8 (hcoeff, keyword, &wcs->x_coeff[i]);
wcsinit.c:	    wcs->y_coeff[i] = 0.0;
wcsinit.c:	    hgetr8 (hcoeff, keyword, &wcs->y_coeff[i]);
wcsinit.c:	wcs->wcson = 1;
wcsinit.c:	(void)strcpy (wcs->c1type, "RA");
wcsinit.c:	(void)strcpy (wcs->c2type, "DEC");
wcsinit.c:	(void)strcpy (wcs->ptype, "DSS");
wcsinit.c:	wcs->degout = 0;
wcsinit.c:	wcs->ndec = 3;
wcsinit.c:	strcpy (wcs->ctype[0], "RA---DSS");
wcsinit.c:	strcpy (wcs->ctype[1], "DEC--DSS");
wcsinit.c:	wcs->crpix[0] = 0.5 * wcs->nxpix;
wcsinit.c:	wcs->crpix[1] = 0.5 * wcs->nypix;
wcsinit.c:	wcs->xrefpix = wcs->crpix[0];
wcsinit.c:	wcs->yrefpix = wcs->crpix[1];
wcsinit.c:	dsspos (wcs->crpix[0], wcs->crpix[1], wcs, &ra0, &dec0);
wcsinit.c:	wcs->crval[0] = ra0;
wcsinit.c:	wcs->crval[1] = dec0;
wcsinit.c:	wcs->xref = wcs->crval[0];
wcsinit.c:	wcs->yref = wcs->crval[1];
wcsinit.c:	dsspos (wcs->crpix[0], wcs->crpix[1]+1.0, wcs, &ra1, &dec1);
wcsinit.c:	wcs->yinc = dec1 - dec0;
wcsinit.c:	wcs->xinc = -wcs->yinc;
wcsinit.c:	wcs->wcson = 1;
wcsinit.c:	rot = degrad (wcs->rot);
wcsinit.c:	dsspos (wcs->crpix[0]+cos(rot),
wcsinit.c:		wcs->crpix[1]+sin(rot), wcs, &ra1, &dec1);
wcsinit.c:	wcs->cdelt[0] = -wcsdist (ra0, dec0, ra1, dec1);
wcsinit.c:	dsspos (wcs->crpix[0]+sin(rot),
wcsinit.c:		wcs->crpix[1]+cos(rot), wcs, &ra1, &dec1);
wcsinit.c:	wcs->cdelt[1] = wcsdist (ra0, dec0, ra1, dec1);
wcsinit.c:	wcsdeltset (wcs, wcs->cdelt[0], wcs->cdelt[1], wcs->rot);
wcsinit.c:		cdelt1 = -secpix / 3600.0;
wcsinit.c:		    cdelt1 = -secpix / 3600.0;
wcsinit.c:		    cdelt1 = -secpix / 3600.0;
wcsinit.c:	    cdelt1 = -cdelt2;
wcsinit.c:	if (wcs->rot == 0.)
wcsinit.c:	wcs->crpix[0] = 0.5 + (wcs->nxpix * 0.5);
wcsinit.c:	wcs->crpix[1] = 0.5 + (wcs->nypix * 0.5);
wcsinit.c:	    hgetr8 (hstring,"CRPIX1",&wcs->crpix[0]);
wcsinit.c:	    hgetr8 (hstring,"CRPIX2",&wcs->crpix[1]);
wcsinit.c:	    dxrefpix = 0.5 * (double) (idx1 + idx2 - 1);
wcsinit.c:	    dyrefpix = 0.5 * (double) (idy1 + idy2 - 1);
wcsinit.c:	    wcs->crpix[0] = dxrefpix - (double) (ix1 - 1);
wcsinit.c:	    wcs->crpix[1] = dyrefpix - (double) (iy1 - 1);
wcsinit.c:	wcs->xrefpix = wcs->crpix[0];
wcsinit.c:	wcs->yrefpix = wcs->crpix[1];
wcsinit.c:	wcs->crval[0] = -999.0;
wcsinit.c:	if (!hgetra (hstring,"RA",&wcs->crval[0])) {
wcsinit.c:	wcs->crval[1] = -999.0;
wcsinit.c:	if (!hgetdec (hstring,"DEC",&wcs->crval[1])) {
wcsinit.c:	wcs->xref = wcs->crval[0];
wcsinit.c:	wcs->yref = wcs->crval[1];
wcsinit.c:	wcs->coorflip = 0;
wcsinit.c:	wcs->cel.ref[0] = wcs->crval[0];
wcsinit.c:	wcs->cel.ref[1] = wcs->crval[1];
wcsinit.c:	wcs->cel.ref[2] = 999.0;
wcsinit.c:	if (!hgetr8 (hstring,"LONPOLE",&wcs->cel.ref[2]))
wcsinit.c:	    hgetr8 (hstring,"LONGPOLE",&wcs->cel.ref[2]);
wcsinit.c:	wcs->cel.ref[3] = 999.0;
wcsinit.c:	hgetr8 (hstring,"LATPOLE",&wcs->cel.ref[3]);
wcsinit.c:	if (hgetr8 (hstring, "MJD-OBS", &mjd))
wcsinit.c:	    wcs->epoch = 1900.0 + (mjd - 15019.81352) / 365.242198781;
wcsinit.c:	else if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
wcsinit.c:	    if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
wcsinit.c:		if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
wcsinit.c:		    wcs->epoch = wcs->equinox;
wcsinit.c:	/* Add time of day if not part of DATE-OBS string */
wcsinit.c:	    hgets (hstring,"DATE-OBS",32,tstring);
wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
wcsinit.c:		    wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
wcsinit.c:	(void) wcstype (wcs, "RA---TAN", "DEC--TAN");
wcsinit.c:	wcs->coorflip = 0;
wcsinit.c:	wcs->degout = 0;
wcsinit.c:	wcs->ndec = 3;
wcsinit.c:	wcs->wcson = 1;
wcsinit.c:    wcs->lin.crpix = wcs->crpix;
wcsinit.c:    wcs->lin.cdelt = wcs->cdelt;
wcsinit.c:    wcs->lin.pc = wcs->pc;
wcsinit.c:    wcs->printsys = 1;
wcsinit.c:    wcs->tabsys = 0;
wcsinit.c:    wcs->linmode = 0;
wcsinit.c:OUTPUT	-.
wcsinit.c:    lng = wcs->wcsl.lng;
wcsinit.c:    lat = wcs->wcsl.lat;
wcsinit.c:    if (wcs->naxis != NAXISPV) {
wcsinit.c:    if (strcmp(wcs->wcsl.pcode, "TAN") != 0) {
wcsinit.c:    if ((wcs->projppv[1+lng*MAXPV] == 0) &&
wcsinit.c:	(wcs->projppv[1+lat*MAXPV] == 0)) {
wcsinit.c:    if (wcs->wcs != NULL) {
wcsinit.c:	pix2wcs(wcs->wcs,0,0,&xmin,&ymin);
wcsinit.c:	pix2wcs(wcs->wcs,wcs->nxpix,wcs->nypix,&xmax,&ymax);
wcsinit.c:	xmax = wcs->nxpix;
wcsinit.c:	ymax = wcs->nypix;
wcsinit.c:    /* We assume that PCxx cross-terms with additional dimensions are small */
wcsinit.c:	lngstep = (xmax-xmin)/(WCS_NGRIDPOINTS-1.0);
wcsinit.c:	latstep = (ymax-ymin)/(WCS_NGRIDPOINTS-1.0);
wcsinit.c:	lngstep = (ymax-ymin)/(WCS_NGRIDPOINTS-1.0);
wcsinit.c:	latstep = (xmax-xmin)/(WCS_NGRIDPOINTS-1.0);
wcsinit.c:    for (j=WCS_NGRIDPOINTS; j--; raw[lat]+=latstep) {
wcsinit.c:	for (i=WCS_NGRIDPOINTS; i--; raw[lng]+=lngstep) {
wcsinit.c:	    if (linrev(raw, &wcs->lin, pixin)) {
wcsinit.c:			 wcs->wcsl.pcode);
wcsinit.c:	    raw_to_pv (&wcs->prj,pixin[lng],pixin[lat], outpost, outpost+1);
wcsinit.c:    linrev(rawmin, &wcs->lin, pixin);
wcsinit.c:    linfwd(pixin, &wcs->lin, raw);
wcsinit.c:    rawsize = sqrt((raw[lng]-rawmin[lng])*(raw[lng]-rawmin[lng])
wcsinit.c:                 +(raw[lat]-rawmin[lat])*(raw[lat]-rawmin[lat]))*D2S;
wcsinit.c:		 wcs->wcsl.pcode);
wcsinit.c:    poly = NULL;  /* to avoid gcc -Wall warnings */
wcsinit.c:  	for (i=WCS_NGRIDPOINTS2; i--; outpost+=2) {
wcsinit.c:	    if (fabs(poly_func(poly, outpost)-*(lngpost++))>epsilon) {
wcsinit.c:	wcs->pvfail = 1;
wcsinit.c:    wcs->prj.inv_x = wcs->inv_x = poly;
wcsinit.c:    linrev(rawmin, &wcs->lin, pixin);
wcsinit.c:    linfwd(pixin, &wcs->lin, raw);
wcsinit.c:    rawsize = sqrt((raw[lng]-rawmin[lng])*(raw[lng]-rawmin[lng])
wcsinit.c:                 +(raw[lat]-rawmin[lat])*(raw[lat]-rawmin[lat]))*D2S;
wcsinit.c:		 wcs->wcsl.pcode);
wcsinit.c:	for (i=WCS_NGRIDPOINTS2; i--; outpost+=2) {
wcsinit.c:	    if (fabs(poly_func(poly, outpost)-*(latpost++))>epsilon) {
wcsinit.c:	wcs->pvfail = 1;
wcsinit.c:    wcs->prj.inv_y = wcs->inv_y = poly;
wcsinit.c:    if (strlen (wcs->radecsys) == 0 || wcs->prjcode == WCS_LIN)
wcsinit.c:	strcpy (wcs->radecsys, "LINEAR");
wcsinit.c:    if (wcs->prjcode == WCS_PIX)
wcsinit.c:	strcpy (wcs->radecsys, "PIXEL");
wcsinit.c:    wcs->syswcs = wcscsys (wcs->radecsys);
wcsinit.c:    if (wcs->syswcs == WCS_B1950)
wcsinit.c:	strcpy (wcs->radecout, "FK4");
wcsinit.c:    else if (wcs->syswcs == WCS_J2000)
wcsinit.c:	strcpy (wcs->radecout, "FK5");
wcsinit.c:	strcpy (wcs->radecout, wcs->radecsys);
wcsinit.c:    wcs->sysout = wcscsys (wcs->radecout);
wcsinit.c:    wcs->eqout = wcs->equinox;
wcsinit.c:    strcpy (wcs->radecin, wcs->radecsys);
wcsinit.c:    wcs->sysin = wcscsys (wcs->radecin);
wcsinit.c:    wcs->eqin = wcs->equinox;
wcsinit.c:	wcs->equinox = atof (eqstring+1);
wcsinit.c:	wcs->equinox = atof (eqstring+1);
wcsinit.c:	hgetr8 (hstring, eqkey, &wcs->equinox);
wcsinit.c:	    wcs->equinox = 1950.0;
wcsinit.c:            hgetr8 (hstring,"EPOCH",&wcs->equinox);
wcsinit.c:	    wcs->equinox = 1950.0;
wcsinit.c:	    wcs->equinox = 2000.0;
wcsinit.c:	    wcs->equinox = 2000.0;
wcsinit.c:	    wcs->equinox = 2000.0;
wcsinit.c:	    wcs->equinox = 2000.0;
wcsinit.c:	wcs->equinox = 2000.0;
wcsinit.c:	if (!strncmp (wcs->c1type, "RA",2) || !strncmp (wcs->c1type,"DEC",3))
wcsinit.c:    if (!hgetdate (hstring,"DATE-OBS",&wcs->epoch)) {
wcsinit.c:	if (!hgetdate (hstring,"DATE",&wcs->epoch)) {
wcsinit.c:	    if (!hgetr8 (hstring,"EPOCH",&wcs->epoch))
wcsinit.c:		wcs->epoch = wcs->equinox;
wcsinit.c:	/* Add time of day if not part of DATE-OBS string */
wcsinit.c:	hgets (hstring,"DATE-OBS",32,tstring);
wcsinit.c:		wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
wcsinit.c:		wcs->epoch = wcs->epoch + (ut / (24.0 * 365.242198781));
wcsinit.c:    if (wcs->epoch == 0.0)
wcsinit.c:	wcs->epoch = wcs->equinox;
wcsinit.c:	strcpy (wcs->radecsys,systring);
wcsinit.c:	    if (!strncmp (wcs->radecsys,"FK4",3))
wcsinit.c:		wcs->equinox = 1950.0;
wcsinit.c:	    else if (!strncmp (wcs->radecsys,"FK5",3))
wcsinit.c:		wcs->equinox = 2000.0;
wcsinit.c:	    else if (!strncmp (wcs->radecsys,"ICRS",4))
wcsinit.c:		wcs->equinox = 2000.0;
wcsinit.c:	    else if (!strncmp (wcs->radecsys,"GAL",3) && ieq == 0)
wcsinit.c:		wcs->equinox = 2000.0;
wcsinit.c:    else if (wcs->syswcs != WCS_NPOLE) {
wcsinit.c:	    strcpy (wcs->radecsys,"FK5");
wcsinit.c:	    strcpy (wcs->radecsys,"FK4");
wcsinit.c:    if (wcs->c1type[0] == 'G')
wcsinit.c:	strcpy (wcs->radecsys,"GALACTIC");
wcsinit.c:    else if (wcs->c1type[0] == 'E')
wcsinit.c:	strcpy (wcs->radecsys,"ECLIPTIC");
wcsinit.c:    else if (wcs->c1type[0] == 'S')
wcsinit.c:	strcpy (wcs->radecsys,"SGALACTC");
wcsinit.c:    else if (wcs->c1type[0] == 'H')
wcsinit.c:	strcpy (wcs->radecsys,"HELIOECL");
wcsinit.c:    else if (wcs->c1type[0] == 'A')
wcsinit.c:	strcpy (wcs->radecsys,"ALTAZ");
wcsinit.c:    else if (wcs->c1type[0] == 'L')
wcsinit.c:	strcpy (wcs->radecsys,"LINEAR");
wcsinit.c:    wcs->syswcs = wcscsys (wcs->radecsys);
wcsinit.c:/* Jun 11 1998	Split off header-dependent WCS initialization from other subs
wcsinit.c: * Sep 14 1998	If DATE-OBS not found, check for DATE
wcsinit.c: * Jan 27 2000  Fix MJD to epoch conversion for when MJD-OBS is the only date
wcsinit.c: * Jun 26 2003	Initialize xref and yref to -999.0
wcsinit.c: * Oct  1 2003	Rename wcs->naxes to wcs->naxis to match WCSLIB 3.2
wcsinit.c: * Dec  3 2003	Add back wcs->naxes for backward compatibility
wcsinit.c: * Mar  9 2006	Get Epoch of observation from MJD-OBS or DATE-OBS/UT unless DSS
wcsinit.c: * Oct 30 2006	Initialize cube face to -1, not a cube projection
wcsinit.c: * Feb  1 2007	Read IRAF log wavelength flag DC-FLAG to wcs.logwcs
wcsinit.c: * Feb 15 2007	Check for wcs->wcsproj > 0 instead of CTYPEi != LINEAR or PIXEL
wcslib.c:*   WCSLIB - an implementation of the FITS WCS proposal.
wcslib.c:*   Copyright (C) 1995-2002, Mark Calabretta
wcslib.c:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcslib.c:*   -------------------
wcslib.c:*   array but need not be called explicitly - see the explanation of
wcslib.c:*   --------------------------------
wcslib.c:*   --------------------------------
wcslib.c:*                        World coordinates.  world[wcs->lng] and
wcslib.c:*                        world[wcs->lat] are the celestial longitude and
wcslib.c:*      imgcrd   double[] Image coordinate.  imgcrd[wcs->lng] and
wcslib.c:*                        imgcrd[wcs->lat] are the projected x-, and
wcslib.c:*                        y-coordinates, in "degrees".  For quadcube
wcslib.c:*                        also returned in imgcrd[wcs->cubeface].
wcslib.c:*   --------------------------------
wcslib.c:*      imgcrd   double[] Image coordinate.  imgcrd[wcs->lng] and
wcslib.c:*                        imgcrd[wcs->lat] are the projected x-, and
wcslib.c:*                        y-coordinates, in "degrees".
wcslib.c:*      world    double[] World coordinates.  world[wcs->lng] and
wcslib.c:*                        world[wcs->lat] are the celestial longitude and
wcslib.c:*   -------------------------------
wcslib.c:*                              world[wcs->lng], latitude returned in
wcslib.c:*                              world[wcs->lat].
wcslib.c:*                              world[wcs->lat], longitude returned in
wcslib.c:*                              world[wcs->lng].
wcslib.c:*                        any convenient normalization, for example [-120,+120]
wcslib.c:*                        a sensible, although perhaps non-optimal default will
wcslib.c:*                        range is 5 - 10.
wcslib.c:*      world    double[] World coordinates.  world[wcs->lng] and
wcslib.c:*                        world[wcs->lat] are the celestial longitude and
wcslib.c:*      imgcrd   double[] Image coordinate.  imgcrd[wcs->lng] and
wcslib.c:*                        imgcrd[wcs->lat] are the projected x-, and
wcslib.c:*                        y-coordinates, in "degrees".
wcslib.c:*   -----
wcslib.c:*       blanks on the right and null-terminated.
wcslib.c:*       ignored, the reference coordinate values in cel->ref[0] and
wcslib.c:*       cel->ref[1] are the ones used.
wcslib.c:*             three-dimensional structure using a "CUBEFACE" axis indexed from
wcslib.c:*       the single plane representation understood by the lower-level WCSLIB
wcslib.c:*   -----------------------
wcslib.c:*   ------------------
wcslib.c:*      is made for a "non-crossing" solution as may arise from a point of
wcslib.c:*      Because of its generality wcsmix() is very compute-intensive.  For
wcslib.c:*      compute-limited applications more efficient special-case solvers could
wcslib.c:*      be written for simple projections, for example non-oblique cylindrical
wcslib.c:   strcpy(wcs->pcode, "");
wcslib.c:   wcs->lng = -1;
wcslib.c:   wcs->lat = -1;
wcslib.c:   wcs->cubeface = -1;
wcslib.c:      if (ctype[j][4] != '-') {
wcslib.c:            if (wcs->cubeface == -1) {
wcslib.c:               wcs->cubeface = j;
wcslib.c:      if (strcmp(wcs->pcode, "") == 0) {
wcslib.c:         sprintf(wcs->pcode, "%.3s", &ctype[j][5]);
wcslib.c:         if (strncmp(ctype[j], "RA--", 4) == 0) {
wcslib.c:            wcs->lng = j;
wcslib.c:            strcpy(wcs->lngtyp, "RA");
wcslib.c:            strcpy(wcs->lattyp, "DEC");
wcslib.c:            ndx = &wcs->lat;
wcslib.c:            sprintf(requir, "DEC--%s", wcs->pcode);
wcslib.c:         } else if (strncmp(ctype[j], "DEC-", 4) == 0) {
wcslib.c:            wcs->lat = j;
wcslib.c:            strcpy(wcs->lngtyp, "RA");
wcslib.c:            strcpy(wcs->lattyp, "DEC");
wcslib.c:            ndx = &wcs->lng;
wcslib.c:            sprintf(requir, "RA---%s", wcs->pcode);
wcslib.c:            wcs->lng = j;
wcslib.c:            sprintf(wcs->lngtyp, "%cLON", ctype[j][0]);
wcslib.c:            sprintf(wcs->lattyp, "%cLAT", ctype[j][0]);
wcslib.c:            ndx = &wcs->lat;
wcslib.c:            sprintf(requir, "%s-%s", wcs->lattyp, wcs->pcode);
wcslib.c:            wcs->lat = j;
wcslib.c:            sprintf(wcs->lngtyp, "%cLON", ctype[j][0]);
wcslib.c:            sprintf(wcs->lattyp, "%cLAT", ctype[j][0]);
wcslib.c:            ndx = &wcs->lng;
wcslib.c:            sprintf(requir, "%s-%s", wcs->lngtyp, wcs->pcode);
wcslib.c:            wcs->lng = j;
wcslib.c:            sprintf(wcs->lngtyp, "%c%cLN", ctype[j][0], ctype[j][1]);
wcslib.c:            sprintf(wcs->lattyp, "%c%cLT", ctype[j][0], ctype[j][1]);
wcslib.c:            ndx = &wcs->lat;
wcslib.c:            sprintf(requir, "%s-%s", wcs->lattyp, wcs->pcode);
wcslib.c:            wcs->lat = j;
wcslib.c:            sprintf(wcs->lngtyp, "%c%cLN", ctype[j][0], ctype[j][1]);
wcslib.c:            sprintf(wcs->lattyp, "%c%cLT", ctype[j][0], ctype[j][1]);
wcslib.c:            ndx = &wcs->lng;
wcslib.c:            sprintf(requir, "%s-%s", wcs->lngtyp, wcs->pcode);
wcslib.c:   if (strncmp(wcs->pcode, "GLS", 3) == 0) {
wcslib.c:      strcpy(wcs->pcode, "SFL");
wcslib.c:   if (strcmp(wcs->pcode, "")) {
wcslib.c:      wcs->flag = WCSSET;
wcslib.c:      wcs->flag = 999;
wcslib.c:/*--------------------------------------------------------------------------*/
wcslib.c:   if (wcs->flag != WCSSET) {
wcslib.c:      if (wcsset(lin->naxis, ctype, wcs)) return 1;
wcslib.c:   for (j = 0; j < lin->naxis; j++) {
wcslib.c:      if (j == wcs->lng) continue;
wcslib.c:      if (j == wcs->lat) continue;
wcslib.c:      imgcrd[j] = world[j] - crval[j];
wcslib.c:   if (wcs->flag != 999) {
wcslib.c:      if (strcmp(wcs->pcode, "NCP") == 0) {
wcslib.c:         if (cel->ref[1] == 0.0) {
wcslib.c:         strcpy(wcs->pcode, "SIN");
wcslib.c:         prj->p[1] = 0.0;
wcslib.c:         prj->p[2] = cosdeg (cel->ref[1])/sindeg (cel->ref[1]);
wcslib.c:         prj->flag = (prj->flag < 0) ? -1 : 0;
wcslib.c:      if ((err = celfwd(wcs->pcode, world[wcs->lng], world[wcs->lat], cel,
wcslib.c:                   phi, theta, prj, &imgcrd[wcs->lng], &imgcrd[wcs->lat]))) {
wcslib.c:      if (wcs->cubeface != -1) {
wcslib.c:         if (prj->r0 == 0.0) {
wcslib.c:            //offset = prj->r0*PI/2.0;
wcslib.c:            offset = prj->r0*WCS_PI/2.0;
wcslib.c:         if (imgcrd[wcs->lat] < -0.5*offset) {
wcslib.c:            imgcrd[wcs->lat] += offset;
wcslib.c:            imgcrd[wcs->cubeface] = 5.0;
wcslib.c:         } else if (imgcrd[wcs->lat] > 0.5*offset) {
wcslib.c:            imgcrd[wcs->lat] -= offset;
wcslib.c:            imgcrd[wcs->cubeface] = 0.0;
wcslib.c:         } else if (imgcrd[wcs->lng] > 2.5*offset) {
wcslib.c:            imgcrd[wcs->lng] -= 3.0*offset;
wcslib.c:            imgcrd[wcs->cubeface] = 4.0;
wcslib.c:         } else if (imgcrd[wcs->lng] > 1.5*offset) {
wcslib.c:            imgcrd[wcs->lng] -= 2.0*offset;
wcslib.c:            imgcrd[wcs->cubeface] = 3.0;
wcslib.c:         } else if (imgcrd[wcs->lng] > 0.5*offset) {
wcslib.c:            imgcrd[wcs->lng] -= offset;
wcslib.c:            imgcrd[wcs->cubeface] = 2.0;
wcslib.c:            imgcrd[wcs->cubeface] = 1.0;
wcslib.c:/*--------------------------------------------------------------------------*/
wcslib.c:   if (wcs->flag != WCSSET) {
wcslib.c:      if (wcsset(lin->naxis, ctype, wcs)) return 1;
wcslib.c:   for (j = 0; j < lin->naxis; j++) {
wcslib.c:      if (j == wcs->lng) continue;
wcslib.c:      if (j == wcs->lat) continue;
wcslib.c:   if (wcs->flag != 999) {
wcslib.c:      if (wcs->cubeface != -1) {
wcslib.c:         face = (int)(imgcrd[wcs->cubeface] + 0.5);
wcslib.c:         if (fabs(imgcrd[wcs->cubeface]-face) > 1e-10) {
wcslib.c:         if (prj->r0 == 0.0) {
wcslib.c:            //offset = prj->r0*PI/2.0;
wcslib.c:						offset = prj->r0*WCS_PI/2.0;
wcslib.c:            imgcrd[wcs->lat] += offset;
wcslib.c:            imgcrd[wcs->lng] += offset;
wcslib.c:            imgcrd[wcs->lng] += offset*2;
wcslib.c:            imgcrd[wcs->lng] += offset*3;
wcslib.c:            imgcrd[wcs->lat] -= offset;
wcslib.c:      if (strcmp(wcs->pcode, "NCP") == 0) {
wcslib.c:         if (cel->ref[1] == 0.0) {
wcslib.c:         strcpy(wcs->pcode, "SIN");
wcslib.c:         prj->p[1] = 0.0;
wcslib.c:         prj->p[2] = cosdeg (cel->ref[1])/sindeg (cel->ref[1]);
wcslib.c:         prj->flag = (prj->flag < 0) ? -1 : 0;
wcslib.c:      if ((err = celrev(wcs->pcode, imgcrd[wcs->lng], imgcrd[wcs->lat], prj,
wcslib.c:                   phi, theta, cel, &world[wcs->lng], &world[wcs->lat]))) {
wcslib.c:/*--------------------------------------------------------------------------*/
wcslib.c:   const double tol  = 1.0e-10;
wcslib.c:   if (wcs->flag != WCSSET) {
wcslib.c:      if (wcsset(lin->naxis, ctype, wcs)) return 1;
wcslib.c:      step = (span[1] - span[0])/10.0;
wcslib.c:         world[wcs->lat] = lat0;
wcslib.c:         d0 = pixcrd[mixpix] - pixmix;
wcslib.c:         world[wcs->lat] = lat1;
wcslib.c:         d1 = pixcrd[mixpix] - pixmix;
wcslib.c:               lat0 -= step;
wcslib.c:               world[wcs->lat] = lat0;
wcslib.c:               d0 = pixcrd[mixpix] - pixmix;
wcslib.c:                  lambda = d0/(d0-d1);
wcslib.c:                  dlat = lat1 - lat0;
wcslib.c:                  world[wcs->lat] = lat;
wcslib.c:                  d = pixcrd[mixpix] - pixmix;
wcslib.c:               lat0 = lat - step;
wcslib.c:               world[wcs->lat] = lat0;
wcslib.c:               d0 = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:               world[wcs->lat] = lat1;
wcslib.c:               d1 = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:                  world[wcs->lat] = lat0m;
wcslib.c:                  d0m = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:                  world[wcs->lat] = lat1m;
wcslib.c:                  d1m = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:         world[wcs->lng] = lng0;
wcslib.c:         d0 = pixcrd[mixpix] - pixmix;
wcslib.c:         world[wcs->lng] = lng1;
wcslib.c:         d1 = pixcrd[mixpix] - pixmix;
wcslib.c:               lng0 -= step;
wcslib.c:               world[wcs->lng] = lng0;
wcslib.c:               d0 = pixcrd[mixpix] - pixmix;
wcslib.c:                  lambda = d0/(d0-d1);
wcslib.c:                  dlng = lng1 - lng0;
wcslib.c:                  world[wcs->lng] = lng;
wcslib.c:                  d = pixcrd[mixpix] - pixmix;
wcslib.c:               lng0 = lng - step;
wcslib.c:               world[wcs->lng] = lng0;
wcslib.c:               d0 = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:               world[wcs->lng] = lng1;
wcslib.c:               d1 = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:                  world[wcs->lng] = lng0m;
wcslib.c:                  d0m = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:                  world[wcs->lng] = lng1m;
wcslib.c:                  d1m = fabs(pixcrd[mixpix] - pixmix);
wcslib.c:   cel0.ref[0] = cel->ref[0];
wcslib.c:   cel0.ref[1] = cel->ref[1];
wcslib.c:   cel0.ref[2] = cel->ref[2];
wcslib.c:   cel0.ref[3] = cel->ref[3];
wcslib.c:   cel0.euler[0] = -90.0;
wcslib.c:   *theta = -90.0;
wcslib.c:      *theta = -*theta;
wcslib.c:      err = sphrev(0.0, *theta, cel->euler, &lng, &lat);
wcslib.c:         if (fabs(fmod(world[wcs->lng]-lng,360.0)) > tol) continue;
wcslib.c:         world[wcs->lat] = lat;
wcslib.c:         if (fabs(world[wcs->lat]-lat) > tol) continue;
wcslib.c:         if (lng > span[1]) lng -= 360.0;
wcslib.c:         world[wcs->lng] = lng;
wcslib.c:      lng = world[wcs->lng];
wcslib.c:      lat = world[wcs->lat];
wcslib.c:      world[wcs->lng] = -180.0;
wcslib.c:      world[wcs->lat] = *theta;
wcslib.c:      d0 = pixcrd[mixpix] - pixmix;
wcslib.c:         world[wcs->lng] = lng;
wcslib.c:         world[wcs->lat] = lat;
wcslib.c:      phi0 = -180.0;
wcslib.c:      for (k = -179; k <= 180; k++) {
wcslib.c:         world[wcs->lng] = phi1;
wcslib.c:         d1 = pixcrd[mixpix] - pixmix;
wcslib.c:            world[wcs->lng] = lng;
wcslib.c:            world[wcs->lat] = lat;
wcslib.c:         lambda = d0/(d0-d1);
wcslib.c:         dphi = phi1 - phi0;
wcslib.c:         world[wcs->lng] = phi0 + lambda*dphi;
wcslib.c:         d = pixcrd[mixpix] - pixmix;
wcslib.c:            world[wcs->lng] = lng;
wcslib.c:            world[wcs->lat] = lat;
wcslib.c:            phi0 = world[wcs->lng];
wcslib.c:            phi1 = world[wcs->lng];
wcslib.c:/* Dec 20 1999  Doug Mink - Change signbit() to signb() and always define it
wcslib.c: * Dec 20 1999	Doug Mink - Include wcslib.h, which includes wcs.h, wcstrig.h
wcslib.c: * Mar 20 2001	Doug Mink - Include stdio.h for sprintf()
wcslib.c: * Mar 20 2001	Doug Mink - Add () around err assignments in if statements
wcslib.c: * Sep 19 2001	Doug Mink - Add above changes to WCSLIB-2.7 version
wcslib.c: * Mar 15 2002	Doug Mink - Add above changes to WCSLIB-2.8.2
wcslib.c: * Apr  3 2002	Mark Calabretta - Fix bug in code checking section
wcslib.c: * Jun 20 2006	Doug Mink - Initialized uninitialized variables
wcslib.h:*   WCSLIB - an implementation of the FITS WCS proposal.
wcslib.h:*   Copyright (C) 1995-2002, Mark Calabretta
wcslib.h:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcslib.h:/*--------------------------------- constants -------------------------------*/
wcslib.h:/*---------------------------------- macros ---------------------------------*/
wcslib.h:/*--------------------------- structure definitions -------------------------*/
wcslib.h:/*---------------------------------- protos --------------------------------*/
wcslib.h:#define WCSTRIG_TOL 1e-10
wcslib.h:/* Feb  3 2000	Doug Mink - Make cplusplus ifdefs for braces all-inclusive
wcslib.h: * Feb 15 2001	Doug Mink - Undefine math constants if already defined
wcslib.h: * Sep 19 2001	Doug Mink - Update for WCSLIB 2.7, especially proj.h and cel.h
wcslib.h: * Mar 12 2002	Doug Mink - Update for WCSLIB 2.8.2, especially proj.h
wcslib.h: * Nov 29 2006	Doug Mink - Drop semicolon at end of C++ ifdef
wcslib.h: * Jan  4 2007	Doug Mink - Drop extra declarations of SZP subroutines
wcslib.h: * Mar 30 2011	Doug Mink - Add raw_to_pv() subroutine for SCAMP from Ed Los
wcslib.h~:*   WCSLIB - an implementation of the FITS WCS proposal.
wcslib.h~:*   Copyright (C) 1995-2002, Mark Calabretta
wcslib.h~:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcslib.h~:/*--------------------------------- constants -------------------------------*/
wcslib.h~:/*---------------------------------- macros ---------------------------------*/
wcslib.h~:/*--------------------------- structure definitions -------------------------*/
wcslib.h~:/*---------------------------------- protos --------------------------------*/
wcslib.h~:#define WCSTRIG_TOL 1e-10
wcslib.h~:/* Feb  3 2000	Doug Mink - Make cplusplus ifdefs for braces all-inclusive
wcslib.h~: * Feb 15 2001	Doug Mink - Undefine math constants if already defined
wcslib.h~: * Sep 19 2001	Doug Mink - Update for WCSLIB 2.7, especially proj.h and cel.h
wcslib.h~: * Mar 12 2002	Doug Mink - Update for WCSLIB 2.8.2, especially proj.h
wcslib.h~: * Nov 29 2006	Doug Mink - Drop semicolon at end of C++ ifdef
wcslib.h~: * Jan  4 2007	Doug Mink - Drop extra declarations of SZP subroutines
wcslib.h~: * Mar 30 2011	Doug Mink - Add raw_to_pv() subroutine for SCAMP from Ed Los
wcstrig.c:*   WCSLIB - an implementation of the FITS WCS proposal.
wcstrig.c:*   Copyright (C) 1995-2002, Mark Calabretta
wcstrig.c:*   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
wcstrig.c:*---------------------------------------------------------------------------*/
wcstrig.c:      return -1.0;
wcstrig.c:/*--------------------------------------------------------------------------*/
wcstrig.c:   resid = fmod(angle-90.0,360.0);
wcstrig.c:      return -1.0;
wcstrig.c:/*--------------------------------------------------------------------------*/
wcstrig.c:   } else if (resid == -135.0 || resid == -315.0) {
wcstrig.c:      return -1.0;
wcstrig.c:/*--------------------------------------------------------------------------*/
wcstrig.c:      if (v-1.0 <  WCSTRIG_TOL) return 0.0;
wcstrig.c:   } else if (v <= -1.0) {
wcstrig.c:      if (v+1.0 > -WCSTRIG_TOL) return 180.0;
wcstrig.c:/*--------------------------------------------------------------------------*/
wcstrig.c:   if (v <= -1.0) {
wcstrig.c:      if (v+1.0 > -WCSTRIG_TOL) return -90.0;
wcstrig.c:      if (v-1.0 <  WCSTRIG_TOL) return 90.0;
wcstrig.c:/*--------------------------------------------------------------------------*/
wcstrig.c:   if (v == -1.0) {
wcstrig.c:      return -45.0;
wcstrig.c:/*--------------------------------------------------------------------------*/
wcstrig.c:         return -90.0;
wcstrig.c:/* Dec 20 1999	Doug Mink - Change cosd() and sind() to cosdeg() and sindeg()
wcstrig.c: * Dec 20 1999	Doug Mink - Include wcslib.h, which includes wcstrig.h
wcstrig.c: * Dec 20 1999	Doug Mink - Use PI from wcslib.h, not locally defined
wcstrig.c: * Sep 19 2001	Doug Mink - No change for WCSLIB 2.7
webread0.c: *** Harvard-Smithsonian Center for Astrophysics
webread0.c: *** Copyright (C) 2000-2008
webread0.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
webread0.c:/* WEBREAD -- Read a catalog over the web and return results */
webread0.c:double	ddec;		/* Search half-width in declination in degrees */
webread0.c:int	nlog;		/* Logging interval (-1 to dump returned file) */
webread0.c:	nlog = -1;
webread0.c:    if (!strncmp (caturl+lurl-4,"scat",4)) {
webread0.c:    else if (!strncmp (caturl+lurl-10,"gsc-server",10)) {
webread0.c:    else if (!strncmp (caturl+lurl-12,"usnoa-server",12)) {
webread0.c:    if (tabtable->tabdata == NULL || strlen (tabtable->tabdata) == 0) {
webread0.c:    if (!strncmp (caturl+lurl-4,"scat",4)) {
webread0.c:	(void) fwrite  (tabtable->tabbuff, tabtable->lbuff, 1, stdout);
webread0.c:    if (!strncmp (caturl+lurl-12,"usnoa-server",12)) {
webread0.c:	starcat->coorsys = WCS_J2000;
webread0.c:	starcat->epoch = 2000.0;
webread0.c:	starcat->equinox = 2000.0;
webread0.c:	starcat->nmag = 2;
webread0.c:	starcat->entmag[0] = 5;
webread0.c:	starcat->entmag[1] = 4;
webread0.c:	strcpy (starcat->keymag[0], "magb");
webread0.c:	strcpy (starcat->keymag[1], "magr");
webread0.c:int	nlog;		/* Logging interval (-1 to dump returned file) */
webread0.c:    if (!strncmp (caturl+lurl-4,"scat",4)) {
webread0.c:	    CatNum (refcat, -nfld, 0, unum[i], numstr);
webread0.c:    else if (!strncmp (caturl+lurl-10,"gsc-server",10)) {
webread0.c:	istar = (int) (10000.0 * (unum[0] - (double) ireg) + 0.5);
webread0.c:    else if (!strncmp (caturl+lurl-12,"usnoa-server",12)) {
webread0.c:	istar = (int) (100000000.0 * (unum[0] - (double) ireg) + 0.5);
webread0.c:    if (tabtable->tabdata == NULL || strlen (tabtable->tabdata) == 0) {
webread0.c:	(void) fwrite  (tabtable->tabbuff, tabtable->lbuff, 1, stdout);
webread0.c:    /* Make sure that scat data is tab-separated (3 tabs found) */
webread0.c:    tabtable->tabbuff = tabbuff;
webread0.c:    tabtable->tabheader = tabtable->tabbuff;
webread0.c:    tabtable->lbuff = lbuff;
webread0.c:    if ((tabtable->filename = (char *) calloc (1, lname)) == NULL) {
webread0.c:    strcpy (tabtable->filename, caturl);
webread0.c:    if ((tabtable->tabname = (char *) calloc (1, lname)) == NULL) {
webread0.c:    strcpy (tabtable->tabname, srchpar);
webread0.c:    tabline = tabtable->tabheader;
webread0.c:    while (*tabline != '-' && tabline < tabtable->tabbuff+lbuff) {
webread0.c:    if (*tabline != '-') {
webread0.c:	fprintf (stderr,"WEBOPEN: No - line in tab table %s",srchurl);
webread0.c:    tabtable->tabhead = lastline;
webread0.c:    tabtable->tabdata = strchr (tabline, newline) + 1;
webread0.c:    tabnew = tabtable->tabdata;
webread0.c:    tabtable->nlines = 0;
webread0.c:	tabdiff = tabnew - tabold;
webread0.c:	tabtable->nlines = tabtable->nlines + 1;
webread0.c:    if (tabdiff < 2 && tabtable->nlines > 0)
webread0.c:	tabtable->nlines = tabtable->nlines - 1;
webread0.c:    tabtable->tabline = tabtable->tabdata;
webread0.c:    tabtable->iline = 1;
webread0.c:/* WEBBUFF -- Return character buffer from given URL */
webread0.c:    lserver = urlpath - servurl;
webread0.c:	sokptr = strsrch ((char *) sok->_ptr, "Location:") + 10;
webread0.c:	if (strcsrch (linebuff, "Content-length") != NULL) {
webread0.c:	    if (linebuff[lline-1] < 32)
webread0.c:		linebuff[lline-1] = (char) 0;
webread0.c:	    if (linebuff[lline-2] < 32)
webread0.c:		linebuff[lline-2] = (char) 0;
webread0.c:    /* Read table into buffer in memory a buffer-full at a time */
webread0.c:    struct hostent *hp;         /* -> hostent structure for host */
webread0.c:	if ( port == -1 ) port  = 80;
webread0.c:	    port = service->s_port;
webread0.c:    if ( port == -1 ) return 0;
webread0.c:	if (gethostname(hostname, MAXHOSTNAMELENGTH) == -1)
webread0.c:    adrinet->sin_family = AF_INET;
webread0.c:    adrinet->sin_port = htons(port);
webread0.c:    memcpy(&adrinet->sin_addr, hp->h_addr, hp->h_length);
webread0.c:    cdash = '-';
webread0.c:		    ic--;
webread0.c:		    ic--;
webread0.c: * Sep 21 2001	Debug searches of ESO USNO-A2.0 and GSC catalogs
webread0.c: * Apr  8 2002	Fix bug in ESO USNO-A2.0 server code
webread0.c: * Aug  6 2002	Make starcat->entmag and starcat->keymag into vectors
webread0.c: * Mar 12 2003	Fix bug in USNO-A2 server code
webread0.c: * Jan  5 2004	Convert SDSS table from comma-separated to tab-separated
webread0.c: * Aug 30 2004	Send CR-LF termination to HTTP GET, not just LF
webread.c: *** Harvard-Smithsonian Center for Astrophysics
webread.c: *** Copyright (C) 2000-2015
webread.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
webread.c:/* WEBREAD -- Read a catalog over the web and return results */
webread.c:double	ddec;		/* Search half-width in declination in degrees */
webread.c:int	nlog;		/* Logging interval (-1 to dump returned file) */
webread.c:	nlog = -1;
webread.c:    if (!strncmp (caturl+lurl-4,"scat",4)) {
webread.c:    else if (!strncmp (caturl+lurl-10,"gsc-server",10)) {
webread.c:    else if (!strncmp (caturl+lurl-12,"usnoa-server",12)) {
webread.c:    if (tabtable->tabdata == NULL || strlen (tabtable->tabdata) == 0) {
webread.c:    if (!strncmp (caturl+lurl-4,"scat",4)) {
webread.c:	(void) fwrite  (tabtable->tabbuff, tabtable->lbuff, 1, stdout);
webread.c:    if (!strncmp (caturl+lurl-12,"usnoa-server",12)) {
webread.c:	starcat->coorsys = WCS_J2000;
webread.c:	starcat->epoch = 2000.0;
webread.c:	starcat->equinox = 2000.0;
webread.c:	starcat->nmag = 2;
webread.c:	starcat->entmag[0] = 5;
webread.c:	starcat->entmag[1] = 4;
webread.c:	strcpy (starcat->keymag[0], "magb");
webread.c:	strcpy (starcat->keymag[1], "magr");
webread.c:int	nlog;		/* Logging interval (-1 to dump returned file) */
webread.c:    if (!strncmp (caturl+lurl-4,"scat",4)) {
webread.c:	    CatNum (refcat, -nfld, 0, unum[i], numstr);
webread.c:    else if (!strncmp (caturl+lurl-10,"gsc-server",10)) {
webread.c:	istar = (int) (10000.0 * (unum[0] - (double) ireg) + 0.5);
webread.c:    else if (!strncmp (caturl+lurl-12,"usnoa-server",12)) {
webread.c:	istar = (int) (100000000.0 * (unum[0] - (double) ireg) + 0.5);
webread.c:    if (tabtable->tabdata == NULL || strlen (tabtable->tabdata) == 0) {
webread.c:	(void) fwrite  (tabtable->tabbuff, tabtable->lbuff, 1, stdout);
webread.c:    /* Make sure that scat data is tab-separated (3 tabs found) */
webread.c:    tabtable->tabbuff = tabbuff;
webread.c:    tabtable->tabheader = tabtable->tabbuff;
webread.c:    tabtable->lbuff = lbuff;
webread.c:    if ((tabtable->filename = (char *) calloc (1, lname)) == NULL) {
webread.c:    strcpy (tabtable->filename, caturl);
webread.c:    if ((tabtable->tabname = (char *) calloc (1, lname)) == NULL) {
webread.c:    strcpy (tabtable->tabname, srchpar);
webread.c:    tabline = tabtable->tabheader;
webread.c:    while (*tabline != '-' && tabline < tabtable->tabbuff+lbuff) {
webread.c:    if (*tabline != '-') {
webread.c:	fprintf (stderr,"WEBOPEN: No - line in tab table %s",srchurl);
webread.c:    tabtable->tabhead = lastline;
webread.c:    tabtable->tabdata = strchr (tabline, newline) + 1;
webread.c:    tabnew = tabtable->tabdata;
webread.c:    tabtable->nlines = 0;
webread.c:	tabdiff = tabnew - tabold;
webread.c:	tabtable->nlines = tabtable->nlines + 1;
webread.c:    if (tabdiff < 2 && tabtable->nlines > 0)
webread.c:	tabtable->nlines = tabtable->nlines - 1;
webread.c:    tabtable->tabline = tabtable->tabdata;
webread.c:    tabtable->iline = 1;
webread.c:/* WEBBUFF -- Return character buffer from given URL */
webread.c:	lserver = urlpath - servurl;
webread.c:	lserver = urlpath - servurl;
webread.c:	if (strcsrch (linebuff, "Content-length") != NULL) {
webread.c:	    if (linebuff[lline-1] < 32)
webread.c:		linebuff[lline-1] = (char) 0;
webread.c:	    if (linebuff[lline-2] < 32)
webread.c:		linebuff[lline-2] = (char) 0;
webread.c:    /* Read table into buffer in memory a buffer-full at a time */
webread.c:    struct hostent *hp;         /* -> hostent structure for host */
webread.c:	if ( port == -1 ) port  = 80;
webread.c:	    port = service->s_port;
webread.c:    if ( port == -1 ) return 0;
webread.c:	if (gethostname(hostname, MAXHOSTNAMELENGTH) == -1)
webread.c:    adrinet->sin_family = AF_INET;
webread.c:    adrinet->sin_port = htons(port);
webread.c:    memcpy(&adrinet->sin_addr, hp->h_addr, hp->h_length);
webread.c:    cdash = '-';
webread.c:		    ic--;
webread.c:		    ic--;
webread.c:/* Returns a url-encoded version of str */
webread.c:	if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~' || *pstr == '/' || *pstr == '?') 
webread.c: * Sep 21 2001	Debug searches of ESO USNO-A2.0 and GSC catalogs
webread.c: * Apr  8 2002	Fix bug in ESO USNO-A2.0 server code
webread.c: * Aug  6 2002	Make starcat->entmag and starcat->keymag into vectors
webread.c: * Mar 12 2003	Fix bug in USNO-A2 server code
webread.c: * Jan  5 2004	Convert SDSS table from comma-separated to tab-separated
webread.c: * Aug 30 2004	Send CR-LF termination to HTTP GET, not just LF
worldpos.c:/*  worldpos.c -- WCS Algorithms from Classic AIPS.
worldpos.c: *  Copyright (C) 1994-2011
worldpos.c:    -=-=-=-=-=-=-
worldpos.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
worldpos.c:	                   Charlottesville, VA 22903-2475 USA
worldpos.c:    -=-=-=-=-=-=-
worldpos.c:    geometries ("-SIN", "-TAN", "-ARC", "-NCP", "-GLS" or "-SFL", "-MER",
worldpos.c:     "-AIT", "-STG", "CAR", and "COE"):
worldpos.c:    differences between these algorithms and the 1993-94 WCS draft
worldpos.c:	        -=-=-=-
worldpos.c:    during the period October 11-13, 1994:
worldpos.c:    3) changed float-->double to get more than 7 significant figures
worldpos.c:    6) E.Greisen recommended removal of various redundant if-statements,
worldpos.c:/* does: -SIN, -TAN, -ARC, -NCP, -GLS or -SFL, -MER, -AIT projections */
worldpos.c:  double cond2r=1.745329252e-2;
worldpos.c:  double deps = 1.0e-5;
worldpos.c:  int itype = wcs->prjcode;
worldpos.c:  xref = wcs->xref;
worldpos.c:  yref = wcs->yref;
worldpos.c:  xrefpix = wcs->xrefpix;
worldpos.c:  yrefpix = wcs->yrefpix;
worldpos.c:  xinc = wcs->xinc;
worldpos.c:  yinc = wcs->yinc;
worldpos.c:  rot = degrad (wcs->rot);
worldpos.c:  dx = xpix - xrefpix;
worldpos.c:  dy = ypix - yrefpix;
worldpos.c:  if (wcs->rotmat) {
worldpos.c:    tx = dx * wcs->cd[0] + dy * wcs->cd[1];
worldpos.c:    dy = dx * wcs->cd[2] + dy * wcs->cd[3];
worldpos.c:    /* Check axis increments - bail out if either 0 */
worldpos.c:      tx = dx * cosr - dy * sinr;
worldpos.c:  if (wcs->coorflip) {
worldpos.c:  if (wcs->coorflip) {
worldpos.c:    case WCS_CAR:   /* -CAR Cartesian (was WCS_PIX pixel and WCS_LIN linear) */
worldpos.c:    case WCS_SIN: /* -SIN sin*/ 
worldpos.c:      coss = sqrt (1.0 - sins);
worldpos.c:      if ((dt>1.0) || (dt<-1.0)) return 1;
worldpos.c:      rat = cos0 * coss - sin0 * m;
worldpos.c:    case WCS_TAN:   /* -TAN tan */
worldpos.c:    case WCS_TNX:   /* -TNX tan with polynomial correction */
worldpos.c:    case WCS_TPV:   /* -TPV tan with polynomial correction */
worldpos.c:    case WCS_ZPX:   /* -ZPX zpn with polynomial correction */
worldpos.c:      dect = cos0 - m * sin0;
worldpos.c:      dect = atan (cos(rat-ra0) * (m * cos0 + sin0) / dect);
worldpos.c:    case WCS_ARC:   /* -ARC Arc*/
worldpos.c:      if ((dt>1.0) || (dt<-1.0)) return 1;
worldpos.c:      da = coss - dt * sin0;
worldpos.c:    case WCS_NCP:   /* -NCP North celestial pole*/
worldpos.c:      dect = cos0 - m * sin0;
worldpos.c:      dt = cos (rat-ra0);
worldpos.c:      if ((dect>1.0) || (dect<-1.0)) return 1;
worldpos.c:      if (dec0<0.0) dect = -dect;
worldpos.c:    case WCS_GLS:   /* -GLS global sinusoid */
worldpos.c:    case WCS_SFL:   /* -SFL Samson-Flamsteed */
worldpos.c:    case WCS_MER:   /* -MER mercator*/
worldpos.c:      geo2 = degrad (dt) / (dx - dy);
worldpos.c:      if (fabs(rat - ra0) > twopi) return 1; /* added 10/13/94 DCW/EWG */
worldpos.c:      dect = 2.0 * atan (dt) - twopi / 4.0;
worldpos.c:    case WCS_AIT:   /* -AIT Aitoff*/
worldpos.c:      dx = sin(dy+dt)/sqrt((1.0+cos(dy+dt))/2.0) -
worldpos.c:      dt = xinc*cosr - yinc* sinr;
worldpos.c:      dz = 4.0 - l*l/(4.0*geo1*geo1) - ((m+geo3)/geo2)*((m+geo3)/geo2) ;
worldpos.c:    case WCS_STG:   /* -STG Sterographic*/
worldpos.c:      dz = (4.0 - sins) / (4.0 + sins);
worldpos.c:      mg = 2.0 * (sin(dect) * cos0 - cos(dect) * sin0 * cos(rat)) / mg;
worldpos.c:      if (fabs(mg-m)>deps) rat = twopi/2.0 - rat;
worldpos.c:      mt = y0 - m;
worldpos.c:	a = atan2 (l,-mt);
worldpos.c:      rat = ra0 - (a / sin0);
worldpos.c:      dect = asin (1.0 / (sin0 * 2.0) * (1.0 + sin0*sin0 * (1.0 - r2)));
worldpos.c:  if (raout-ra0>twopi/2.0) raout = raout - twopi;
worldpos.c:  if (raout-ra0<-twopi/2.0) raout = raout + twopi;
worldpos.c:/*-----------------------------------------------------------------------*/
worldpos.c:  double cond2r=1.745329252e-2, deps=1.0e-5, twopi=6.28318530717959;
worldpos.c:  xref = wcs->xref;
worldpos.c:  yref = wcs->yref;
worldpos.c:  xrefpix = wcs->xrefpix;
worldpos.c:  yrefpix = wcs->yrefpix;
worldpos.c:  xinc = wcs->xinc;
worldpos.c:  yinc = wcs->yinc;
worldpos.c:  rot = degrad (wcs->rot);
worldpos.c:  itype = wcs->prjcode;
worldpos.c:    if (wcs->coorflip) {
worldpos.c:      dt = xpos - yref;
worldpos.c:      dt = xpos - xref;
worldpos.c:    /* 0h wrap-around tests added by D.Wells 10/12/1994: */
worldpos.c:    if (xrefpix*xinc > 180.0 || xrefpix*xinc < -180.0) {
worldpos.c:	if (dt > 360.0) xpos -= 360.0;
worldpos.c:	if (dt > 180.0) xpos -= 360.0;
worldpos.c:	if (dt < -180.0) xpos += 360.0;
worldpos.c:    /* NOTE: changing input argument xpos is OK (call-by-value in C!) */
worldpos.c:    l = sin(ra-ra0) * coss;
worldpos.c:    sint = sins * sin(dec0) + coss * cos(dec0) * cos(ra-ra0);
worldpos.c:    case WCS_CAR:   /* -CAR Cartesian */
worldpos.c:      l = ra - ra0;
worldpos.c:      m = dec - dec0;
worldpos.c:    case WCS_SIN:   /* -SIN sin*/ 
worldpos.c:	m = sins * cos(dec0) - coss * sin(dec0) * cos(ra-ra0);
worldpos.c:    case WCS_TNX:   /* -TNX tan with polynomial correction */
worldpos.c:    case WCS_TPV:   /* -TPV tan with polynomial correction */
worldpos.c:    case WCS_ZPX:   /* -ZPX zpn with polynomial correction */
worldpos.c:    case WCS_TAN:   /* -TAN tan */
worldpos.c: 	m = sins * sin(dec0) + coss * cos(dec0) * cos(ra-ra0);
worldpos.c:	m = (sins * cos(dec0) - coss * sin(dec0) * cos(ra-ra0)) / m;
worldpos.c:    case WCS_ARC:   /* -ARC Arc*/
worldpos.c:	m = sins * sin(dec0) + coss * cos(dec0) * cos(ra-ra0);
worldpos.c:	if (m<-1.0) m = -1.0;
worldpos.c:	m = (sins * cos(dec0) - coss * sin(dec0) * cos(ra-ra0)) * m;
worldpos.c:    case WCS_NCP:   /* -NCP North celestial pole*/
worldpos.c:	    m = (cos(dec0) - coss * cos(ra-ra0)) / sin(dec0);
worldpos.c:    case WCS_GLS:   /* -GLS global sinusoid */
worldpos.c:    case WCS_SFL:   /* -SFL Samson-Flamsteed */
worldpos.c:	dt = ra - ra0;
worldpos.c:	m = dec - dec0;
worldpos.c:    case WCS_MER:   /* -MER mercator*/
worldpos.c:	geo2 = degrad (dt) / (dx - dy);
worldpos.c:	dt = ra - ra0;
worldpos.c:	m = geo2 * log (dt) - geo3;
worldpos.c:    case WCS_AIT:   /* -AIT Aitoff*/
worldpos.c:	da = (ra - ra0) / 2.0;
worldpos.c:	dx = sin(dy+dt)/sqrt((1.0+cos(dy+dt))/2.0) -
worldpos.c:	dt = xinc*cosr - yinc* sinr;
worldpos.c:	m = geo2 * sin(dec) / dt - geo3;
worldpos.c:    case WCS_STG:   /* -STG Sterographic*/
worldpos.c:	da = ra - ra0;
worldpos.c:	m = dd * (sins * cos(dec0) - coss * sin(dec0) * cos(da));
worldpos.c:    case WCS_COE:    /* allan: -COE projection added, AW, ESO*/
worldpos.c:	a = -2. * tthea;
worldpos.c:	co2 = -0.125 * a2 + b/2.;
worldpos.c:	co3 = -0.25 * a*b + 0.0625 * a3 + c/2.0;
worldpos.c:	co4 = -0.125 * b*b - 0.25 * a*c + 0.1875 * b*a2 - (5.0/128.0)*a4;
worldpos.c:	phi = ra0 - ra;
worldpos.c:	v = dec - dec0;
worldpos.c:	if (wcs->rotmat)
worldpos.c:	    l = rap * an * (1.0 - ansq/6.0) * (wcs->cd[0] / fabs(wcs->cd[0]));
worldpos.c:	    l = rap * an * (1.0 - ansq/6.0) * (xinc / fabs(xinc));
worldpos.c:	m = rthea - (rap * (1.0 - ansq/2.0));
worldpos.c:    dx = xpos - xref;
worldpos.c:    dy = ypos - yref;
worldpos.c:  if (wcs->coorflip) {
worldpos.c:  if (wcs->rotmat) {
worldpos.c:    tx = dx * wcs->dc[0] + dy * wcs->dc[1];
worldpos.c:    dy = dx * wcs->dc[2] + dy * wcs->dc[3];
worldpos.c:      dy = dy*cosr - dx*sinr;
worldpos.c:    if (*xpix > wcs->nxpix) {
worldpos.c:      x = *xpix - (360.0 / xinc);
worldpos.c:      if (x <= wcs->nxpix) *xpix = x;
Binary file xx.fits matches
zpxpos.c: *** Harvard-Smithsonian Center for Astrophysics
zpxpos.c: *** Copyright (C) 1998-2012
zpxpos.c:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
zpxpos.c:#define	TOL 1e-13
zpxpos.c:/* wfzpx -- wcs function driver for the zenithal / azimuthal polynomial.
zpxpos.c:/* zpxinit -- initialize the zenithal/azimuthal polynomial forward or
zpxpos.c:    if (wcs->longpole > 360.0) {
zpxpos.c:	if (!igetr8 (str1, "longpole", &wcs->longpole)) {
zpxpos.c:	    if (!igetr8 (str2, "longpole", &wcs->longpole))
zpxpos.c:		wcs->longpole = 180.0;
zpxpos.c:    if (!igetr8 (str1, "ro", &wcs->rodeg)) {
zpxpos.c:	if (!igetr8 (str2, "ro", &wcs->rodeg))
zpxpos.c:	    //wcs->rodeg = 180.0 / PI;
zpxpos.c:	    wcs->rodeg = 180.0 / WCS_PI;
zpxpos.c:	if (!igetr8 (str1, key, &wcs->prj.p[i]))
zpxpos.c:	    wcs->prj.p[i] = 0.0;
zpxpos.c:	    wcs->lngcor = NULL;
zpxpos.c:	    wcs->lngcor = wf_gsopen (lngstr);
zpxpos.c:	wcs->lngcor = wf_gsopen (lngstr);
zpxpos.c:	    wcs->latcor = NULL;
zpxpos.c:	    wcs->latcor = wf_gsopen (latstr);
zpxpos.c:	wcs->latcor = wf_gsopen (latstr);
zpxpos.c:    for (i = 9; i >= 0 && wcs->prj.p[i] == 0.; i--);
zpxpos.c:    wcs->zpnp = i;
zpxpos.c:	d1 = wcs->prj.p[1];
zpxpos.c:	    for (j = wcs->zpnp; j >= 1; j--) {
zpxpos.c:		d2 = d2 * zd2 + j * wcs->prj.p[j];
zpxpos.c:		zd = zd1 - d1 * (zd2 - zd1) / (d2 - d1);
zpxpos.c:		for (j = wcs->zpnp; j >= 1; j--) {
zpxpos.c:		    d = d * zd + j * wcs->prj.p[j];
zpxpos.c:	for (j = wcs->zpnp; j >= 0; j--)
zpxpos.c:	    r = r * zd + wcs->prj.p[j];
zpxpos.c:	wcs->zpzd = zd;
zpxpos.c:	wcs->zpr = r;
zpxpos.c:    if (wcs->latcor == NULL && wcs->lngcor == NULL)
zpxpos.c:/* zpxpos -- forward transform (physical to world) gnomonic projection. */
zpxpos.c:    xpix = xpix - wcs->crpix[0];
zpxpos.c:    ypix = ypix - wcs->crpix[1];
zpxpos.c:    if (wcs->rotmat) {
zpxpos.c:	x = xpix * wcs->cd[0] + ypix * wcs->cd[1];
zpxpos.c:	y = xpix * wcs->cd[2] + ypix * wcs->cd[3];
zpxpos.c:	/* Check axis increments - bail out if either 0 */
zpxpos.c:	if (wcs->cdelt[0] == 0.0 || wcs->cdelt[1] == 0.0) {
zpxpos.c:	xs = xpix * wcs->cdelt[0];
zpxpos.c:	ys = ypix * wcs->cdelt[1];
zpxpos.c:	if (wcs->rot != 0.0) {
zpxpos.c:	    double cosr = cos (degrad (wcs->rot));
zpxpos.c:	    double sinr = sin (degrad (wcs->rot));
zpxpos.c:	    x = xs * cosr - ys * sinr;
zpxpos.c:    if (wcs->coorflip) {
zpxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
zpxpos.c:    longp = degrad(wcs->longpole);
zpxpos.c:    k = wcs->zpnp;
zpxpos.c:    if (wcs->lngcor != NULL)
zpxpos.c:	xp = x + wf_gseval (wcs->lngcor, x, y);
zpxpos.c:    if (wcs->latcor != NULL)
zpxpos.c:	yp = y + wf_gseval (wcs->latcor, x, y);
zpxpos.c:    r = sqrt (x * x + y * y) / wcs->rodeg;
zpxpos.c:        zd = (r - wcs->prj.p[0]) / wcs->prj.p[1];
zpxpos.c:        a = wcs->prj.p[2];
zpxpos.c:        b = wcs->prj.p[1];
zpxpos.c:        c = wcs->prj.p[0] - r;
zpxpos.c:	d = b * b - 4. * a * c;
zpxpos.c:	zd1 = (-b + d) / (2. * a);
zpxpos.c:	zd2 = (-b - d) / (2. * a);
zpxpos.c:	if (zd < -TOL) {
zpxpos.c:	    if (zd < -TOL) {
zpxpos.c:	r1 = wcs->prj.p[0];
zpxpos.c:	zd2 = wcs->zpzd;
zpxpos.c:	r2 = wcs->zpr;
zpxpos.c:	    if (r < (r1 - TOL)) {
zpxpos.c:	        lambda = (r2 - r) / (r2 - r1);
zpxpos.c:		zd = zd2 - lambda * (zd2 - zd1);
zpxpos.c:		for (i=k; i>=0; i--)
zpxpos.c:		    rt = (rt * zd) + wcs->prj.p[i];
zpxpos.c:		    if ((r - rt) < TOL)
zpxpos.c:		    if ((rt - r) < TOL)
zpxpos.c:		lambda = zd2 - zd1;
zpxpos.c:		lambda = fabs (zd2 - zd1);
zpxpos.c:		if (fabs (zd2 - zd1) < TOL)
zpxpos.c:	phi = atan2 (x, -y);
zpxpos.c:    //theta = PI / 2 - zd;
zpxpos.c:		theta = WCS_PI / 2 - zd;
zpxpos.c:    dphi = phi - longp;
zpxpos.c:    x = sinthe * sinlatp - costhe * coslatp * cosphi;
zpxpos.c:	x = -cos (theta + colatp) + costhe * coslatp * (1.0 - cosphi);
zpxpos.c:    y = -costhe * sinphi;
zpxpos.c:    ra =  wcs->crval[ira] + raddeg(dlng);
zpxpos.c:    if (wcs->crval[ira] >= 0.0) {
zpxpos.c:	    ra = ra - 360.0;
zpxpos.c:	ra = ra - 360.0;
zpxpos.c:    else if (ra < -360.0)
zpxpos.c:	    dec = 180.0 - dec;
zpxpos.c:	if (dec < -90.0)
zpxpos.c:	    dec = -180.0 - dec;
zpxpos.c:		dec = raddeg(-acos (sqrt(x * x + y * y)));
zpxpos.c:/* zpxpix -- inverse transform (world to physical) for the zenithal
zpxpos.c:    if (wcs->coorflip) {
zpxpos.c:    ra  = degrad (xpos - wcs->crval[ira]);
zpxpos.c:    colatp = degrad (90.0 - wcs->crval[idec]);
zpxpos.c:    if (wcs->longpole == 999.0)
zpxpos.c:	longp = degrad(wcs->longpole);
zpxpos.c:    x = sindec * sinlatp - cosdec * coslatp * cosra;
zpxpos.c:	x = -cos (dec + colatp) + cosdec * coslatp * (1.0 - cosra);
zpxpos.c:    y = -cosdec * sinra;
zpxpos.c:	dphi = ra - dpi;
zpxpos.c:	phi = phi - twopi;
zpxpos.c:    else if (phi < -dpi)
zpxpos.c:	    theta = dpi - theta;
zpxpos.c:	if (theta < -dhalfpi)
zpxpos.c:	    theta = -dpi - theta;
zpxpos.c:		theta = -acos (sqrt(x * x + y * y));
zpxpos.c:    s = dhalfpi - theta;
zpxpos.c:    for (i=9; i>=0; i--)
zpxpos.c:        r = r * s + wcs->prj.p[i];
zpxpos.c:    r = wcs->rodeg * r;
zpxpos.c:    if (wcs->lngcor == NULL && wcs->latcor == NULL) {
zpxpos.c:	if (wcs->coorflip) {
zpxpos.c:	    x = -r * cos (phi);
zpxpos.c:	    y = -r * cos (phi);
zpxpos.c:	ym = -r * cos (phi);
zpxpos.c:	    if (wcs->lngcor != NULL) {
zpxpos.c:		f = x + wf_gseval (wcs->lngcor, x, y) - xm;
zpxpos.c:		fx = wf_gsder (wcs->lngcor, x, y, 1, 0);
zpxpos.c:		fy = wf_gsder (wcs->lngcor, x, y, 0, 1);
zpxpos.c:		f = x - xm;
zpxpos.c:	    if (wcs->latcor != NULL) {
zpxpos.c:		g = y + wf_gseval (wcs->latcor, x, y) - ym;
zpxpos.c:		gx = wf_gsder (wcs->latcor, x, y, 1, 0);
zpxpos.c:		gy = wf_gsder (wcs->latcor, x, y, 0, 1);
zpxpos.c:		g = y - ym;
zpxpos.c:	    denom = fx * gy - fy * gx;
zpxpos.c:	    dx = (-f * gy + g * fy) / denom;
zpxpos.c:	    dy = (-g * fx + f * gx) / denom;
zpxpos.c:	    if (MAX(MAX(fabs(dx),fabs(dy)),MAX(fabs(f),fabs(g))) < 2.80e-8)
zpxpos.c:	if (wcs->coorflip) {
zpxpos.c:    if (wcs->rotmat) {
zpxpos.c:	*xpix = x * wcs->dc[0] + y * wcs->dc[1];
zpxpos.c:	*ypix = x * wcs->dc[2] + y * wcs->dc[3];
zpxpos.c:	if (wcs->rot!=0.0) {
zpxpos.c:	    double cosr = cos (degrad (wcs->rot));
zpxpos.c:	    double sinr = sin (degrad (wcs->rot));
zpxpos.c:	    *ypix = y * cosr - x * sinr;
zpxpos.c:	if (wcs->xinc != 0.)
zpxpos.c:	    *xpix = *xpix / wcs->xinc;
zpxpos.c:	if (wcs->yinc != 0.)
zpxpos.c:	    *ypix = *ypix / wcs->yinc;
zpxpos.c:    *xpix = *xpix + wcs->xrefpix;
zpxpos.c:    *ypix = *ypix + wcs->yrefpix;
zpxpos.c:/* ZPXCLOSE -- free up the distortion surface pointers */
zpxpos.c:    if (wcs->lngcor != NULL)
zpxpos.c:	wf_gsclose (wcs->lngcor);
zpxpos.c:    if (wcs->latcor != NULL)
zpxpos.c:	wf_gsclose (wcs->latcor);
zpxpos.c:/* wf_gsclose -- procedure to free the surface descriptor */
zpxpos.c:	if (sf->xbasis != NULL)
zpxpos.c:	    free (sf->xbasis);
zpxpos.c:	if (sf->ybasis != NULL)
zpxpos.c:	    free (sf->ybasis);
zpxpos.c:	if (sf->coeff != NULL)
zpxpos.c:	    free (sf->coeff);
