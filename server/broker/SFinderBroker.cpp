/*----- PROTECTED REGION ID(SFinderBroker.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        SFinderBroker.cpp
//
// description : C++ source for the SFinderBroker class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SFinderBroker are implemented in this file.
//
// project :     
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SFinderBroker.h>
#include <SFinderBrokerClass.h>

#include <WorkerStateCallBack.h>
#include <WorkerSourceDataCallBack.h>

//Caesar headers
#include <Img.h>
#include <BkgData.h>
#include <Contour.h>
#include <Logger.h>
#include <Serializer.h>
#include <WorkerManager.h>
#include <MathUtils.h>
using namespace Caesar;

//## Standard headers
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <ctime>
#include <stdexcept>
#include <unistd.h>
#include <getopt.h>
#include <math.h>
#include <time.h>

#include <map>
#include <vector>
#include <thread>
#include <memory>
#include <functional>
#include <chrono>
#include <regex>
#include <exception>

using namespace std;

/*----- PROTECTED REGION END -----*/	//	SFinderBroker.cpp

/**
 *  SFinderBroker class description:
 *    
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name           |  Method name
//================================================================
//  State                  |  Inherited (no method)
//  Status                 |  Inherited (no method)
//  RegisterWorker         |  register_worker
//  ListWorkers            |  list_workers
//  ListFreeWorkers        |  list_free_workers
//  ListBusyWorkers        |  list_busy_workers
//  PingWorker             |  ping_worker
//  SubscribeWorkers       |  subscribe_workers
//  SubmitSourceFinderJob  |  submit_source_finder_job
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//================================================================

namespace SFinderBroker_ns
{
/*----- PROTECTED REGION ID(SFinderBroker::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SFinderBroker::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::SFinderBroker()
 *	Description : Constructors for a Tango device
 *                implementing the classSFinderBroker
 */
//--------------------------------------------------------
SFinderBroker::SFinderBroker(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SFinderBroker::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::constructor_1
}
//--------------------------------------------------------
SFinderBroker::SFinderBroker(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(SFinderBroker::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::constructor_2
}
//--------------------------------------------------------
SFinderBroker::SFinderBroker(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(SFinderBroker::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SFinderBroker::delete_device()
{
	DEBUG_STREAM << "SFinderBroker::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	//## Delete mutex
	if(m_mutex) {
  	DEBUG_LOG("Deleting mutex...");
    delete m_mutex;
    m_mutex= 0;
  }

	if(m_workerManager){
		DEBUG_LOG("Deleting worker manager...");
		delete m_workerManager;
		m_workerManager= 0;
	}

	if(m_workerStateCallBack){
		DEBUG_LOG("Deleting worker state callback...");
		delete m_workerStateCallBack;
		m_workerStateCallBack= 0;
	}
	if(m_workerSourceDataCallBack){
		DEBUG_LOG("Deleting worker sourceData callback...");
		delete m_workerSourceDataCallBack;
		m_workerSourceDataCallBack= 0;
	}

	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SFinderBroker::init_device()
{
	DEBUG_STREAM << "SFinderBroker::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(SFinderBroker::init_device) ENABLED START -----*/
	
	//	Initialize device

	//## Init mutex
  DEBUG_LOG("Init mutex...");
  m_mutex= 0;
  m_mutex = new omni_mutex();

	//## Init worker state callback
	DEBUG_LOG("Init worker state callback ...");
	m_workerStateCallBack= 0;
	m_workerStateCallBack= new WorkerStateCallBack(this);

	DEBUG_LOG("Init worker sourceData callback ...");
	m_workerSourceDataCallBack= 0;
	m_workerSourceDataCallBack= new WorkerSourceDataCallBack(this);

	DEBUG_LOG("Init worker manager ...");
	m_workerManager= 0;
	m_workerManager= new WorkerManager();


	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::init_device
}

//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void SFinderBroker::get_device_property()
{
	/*----- PROTECTED REGION ID(SFinderBroker::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("federatedBrokers"));
	dev_prop.push_back(Tango::DbDatum("maxNTasksPerWorker_default"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SFinderBrokerClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SFinderBrokerClass	*ds_class =
			(static_cast<SFinderBrokerClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize federatedBrokers from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  federatedBrokers;
		else {
			//	Try to initialize federatedBrokers from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  federatedBrokers;
		}
		//	And try to extract federatedBrokers value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  federatedBrokers;

		//	Try to initialize maxNTasksPerWorker_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  maxNTasksPerWorker_default;
		else {
			//	Try to initialize maxNTasksPerWorker_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  maxNTasksPerWorker_default;
		}
		//	And try to extract maxNTasksPerWorker_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  maxNTasksPerWorker_default;

	}

	/*----- PROTECTED REGION ID(SFinderBroker::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SFinderBroker::always_executed_hook()
{
	DEBUG_STREAM << "SFinderBroker::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SFinderBroker::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SFinderBroker::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::read_attr_hardware
}


//--------------------------------------------------------
/**
 *	Read attribute dynStringAttr related method
 *	Description: 
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinderBroker::read_dynStringAttr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinderBroker::read_dynStringAttr(Tango::Attribute &attr) entering... " << endl;
	Tango::DevString	*att_value = get_dynStringAttr_data_ptr(attr.get_name());
	/*----- PROTECTED REGION ID(SFinderBroker::read_dynStringAttr) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(att_value);
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::read_dynStringAttr
}
//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinderBroker::add_dynamic_attributes()
{
	//	Example to add dynamic attribute:
	//	Copy inside the following protected area to create instance(s) at startup.
	//	add_dynStringAttr_dynamic_attribute("MydynStringAttrAttribute");
	
	/*----- PROTECTED REGION ID(SFinderBroker::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command RegisterWorker related method
 *	Description: Register device with input name in the list of workers
 *
 *	@param argin Worker device name to be registered
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SFinderBroker::register_worker(Tango::DevString argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SFinderBroker::RegisterWorker()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::register_worker) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	//Get worker name argument
	if(strcmp(argin,"")==0){
		WARN_LOG("Missing worker name argument!");
		ack= -1;
		reply= "Missing worker name argument!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string worker_name= std::string(argin);

	
	//Register worker in list
	INFO_LOG("Registering worker "<<worker_name<<" in broker...");
	if(m_workerManager->AddWorker(worker_name)<0){
		WARN_LOG("Worker registration failed!");
		ack= -1;
		reply= "Worker registration failed!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}


	//Return reply
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::register_worker
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ListWorkers related method
 *	Description: List all the workers registered for this broker
 *
 *	@returns List of worker devices registered
 */
//--------------------------------------------------------
Tango::DevVarStringArray *SFinderBroker::list_workers()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "SFinderBroker::ListWorkers()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::list_workers) ENABLED START -----*/
	
	//	Add your own code
	//Get worker names
	std::vector<std::string> worker_names;
	m_workerManager->GetWorkerNames(worker_names);

	//Reply	
	argout= new Tango::DevVarStringArray;
	argout->length(worker_names.size());
	for(unsigned int i=0;i<worker_names.size();i++){
		(*argout)[i]= CORBA::string_dup(worker_names[i].c_str());
	}
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::list_workers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ListFreeWorkers related method
 *	Description: List the free workers among those registered for this broker
 *
 *	@returns List of free workers
 */
//--------------------------------------------------------
Tango::DevVarStringArray *SFinderBroker::list_free_workers()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "SFinderBroker::ListFreeWorkers()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::list_free_workers) ENABLED START -----*/
	
	//	Add your own code
	//Get worker names
	std::vector<std::string> worker_names;
	m_workerManager->GetFreeWorkerNames(worker_names);

	//Reply	
	argout= new Tango::DevVarStringArray;
	argout->length(worker_names.size());
	for(unsigned int i=0;i<worker_names.size();i++){
		(*argout)[i]= CORBA::string_dup(worker_names[i].c_str());
	}

	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::list_free_workers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ListBusyWorkers related method
 *	Description: List the busy worker devices among the registered ones
 *
 *	@returns List busy workers
 */
//--------------------------------------------------------
Tango::DevVarStringArray *SFinderBroker::list_busy_workers()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "SFinderBroker::ListBusyWorkers()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::list_busy_workers) ENABLED START -----*/
	
	//	Add your own code
	//Get worker names
	std::vector<std::string> worker_names;
	m_workerManager->GetBusyWorkerNames(worker_names);

	//Reply	
	argout= new Tango::DevVarStringArray;
	argout->length(worker_names.size());
	for(unsigned int i=0;i<worker_names.size();i++){
		(*argout)[i]= CORBA::string_dup(worker_names[i].c_str());
	}
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::list_busy_workers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PingWorker related method
 *	Description: Ping a given worker
 *
 *	@param argin Worker name
 */
//--------------------------------------------------------
void SFinderBroker::ping_worker(Tango::DevString argin)
{
	DEBUG_STREAM << "SFinderBroker::PingWorker()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::ping_worker) ENABLED START -----*/
	
	//	Add your own code
	//Connect to device
	std::string worker_name= std::string(argin);
	 Tango::DeviceProxy* device_proxy= 0;
	try {
		device_proxy= new Tango::DeviceProxy(worker_name);
	}
	catch(Tango::DevFailed& e){
		WARN_LOG("Cannot connect to worker device "<<worker_name<<"...");
		return;
	}

	//Get current state
	Tango::DevState current_state= Tango::UNKNOWN;
	try {
		current_state= device_proxy->state();
		INFO_LOG("Current worker state: "<<current_state<<"...");
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		WARN_LOG("Cannot get worker device "<<device_name<<" state information...");
		return;
	}

	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::ping_worker
}
//--------------------------------------------------------
/**
 *	Command SubscribeWorkers related method
 *	Description: Subscribe to worker events
 *
 */
//--------------------------------------------------------
void SFinderBroker::subscribe_workers()
{
	DEBUG_STREAM << "SFinderBroker::SubscribeWorkers()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::subscribe_workers) ENABLED START -----*/
	
	//	Add your own code
	//Perform subscription to workers
	if(!m_workerManager) return;

	//--> State
	DEBUG_LOG("Subscribing to State Change event...");
	if(m_workerManager->SubscribeGroupToEvent("State",Tango::CHANGE_EVENT,m_workerStateCallBack)<0){
		WARN_LOG("Failed to subscribe to worker group State event!");
	}
	
	/*
	INFO_LOG("Subscribing to State Periodic event...");
	if(m_workerManager->SubscribeGroupToEvent("State",Tango::PERIODIC_EVENT,m_workerStateCallBack)<0){
		WARN_LOG("Failed to subscribe to worker group State event!");
	}
	*/

	//--> Source data
	DEBUG_LOG("Subscribing to sourceData Change event...");
	//if(m_workerManager->SubscribeGroupToEvent("sourceData",Tango::CHANGE_EVENT,m_workerSourceDataCallBack)<0){
	//	WARN_LOG("Failed to subscribe to worker group sourceData event!");
	//}
	if(m_workerManager->SubscribeGroupToEvent("encodedSourceData",Tango::CHANGE_EVENT,m_workerSourceDataCallBack)<0){
		WARN_LOG("Failed to subscribe to worker group sourceData event!");
	}
	return;
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::subscribe_workers
}
//--------------------------------------------------------
/**
 *	Command SubmitSourceFinderJob related method
 *	Description: Command source finder job
 *
 *	@param argin String arg
 *               [0]: input image filename
 *               [1]: config options
 *               
 *               Long arg
 *               [0]: Max number of workers to be allocated
 *	@returns Long arg
 *           [0]: ack code
 *           
 *           String arg
 *           [0]: err description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SFinderBroker::submit_source_finder_job(const Tango::DevVarLongStringArray *argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SFinderBroker::SubmitSourceFinderJob()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinderBroker::submit_source_finder_job) ENABLED START -----*/
	
	//	Add your own code
	//Init reply
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	//Validate args	
	long int nArgs_s= argin->svalue.length();
	long int nArgs_l= argin->lvalue.length();
	if(nArgs_s<2){
		WARN_LOG("Missing filename and/or configuration arguments!");
		ack= -1;
		reply= "Missing filename and/or configuration arguments!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	//Check filename arg
	if(strcmp(argin->svalue[0],"")==0){
		WARN_LOG("Empty filename argument given!");
		ack= -1;
		reply= "Invalid filename argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string inputFileName= std::string(argin->svalue[0]); 

	//Check config arg
	if(strcmp(argin->svalue[1],"")==0){
		WARN_LOG("Empty config argument given!");
		ack= -1;
		reply= "Invalid config argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string config= std::string(argin->svalue[1]); 


	//Get maximum number of workers
	if(nArgs_l<1){
		WARN_LOG("Missing maximum number of workers argument!");
		ack= -1;
		reply= "Missing maximum number of workers argument!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	Tango::DevLong maxNWorkers= argin->lvalue[0];



	//## Parse config and get options for tile distribution
	Json::Value optionList;
	if(ValidateConfigOptions(optionList,config)<0){
		WARN_LOG("Invalid config argument given (parsing failed or missing options)!");
		ack= -1;
		reply= "Invalid config argument given (parsing failed or missing options)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	//--> Get tile size X
	int optionIndex= -1;
	if(CodeUtils::FindJsonValue(optionIndex,optionList,"tileSizeX","name")<0){
		WARN_LOG("Missing tileSizeX option!");
		ack= -1;
		reply= "Missing tileSizeX option!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;		
	}
	long int tileSizeX= (optionList[optionIndex])["value"].asInt64();

	//--> Get tile size Y
	if(CodeUtils::FindJsonValue(optionIndex,optionList,"tileSizeY","name")<0){
		WARN_LOG("Missing tileSizeY option!");
		ack= -1;
		reply= "Missing tileSizeY option!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;		
	}
	long int tileSizeY= (optionList[optionIndex])["value"].asInt64();

	//--> Get useTileOverlap
	if(CodeUtils::FindJsonValue(optionIndex,optionList,"useTileOverlap","name")<0){
		WARN_LOG("Missing useTileOverlap option!");
		ack= -1;
		reply= "Missing useTileOverlap option!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;		
	}
	bool useTileOverlap= (optionList[optionIndex])["value"].asBool();

	//--> Get tileStepSizeX
	if(CodeUtils::FindJsonValue(optionIndex,optionList,"tileStepSizeX","name")<0){
		WARN_LOG("Missing tileStepSizeX option!");
		ack= -1;
		reply= "Missing tileStepSizeX option!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;		
	}
	float tileStepSizeX= (optionList[optionIndex])["value"].asFloat();	

	//--> Get tileStepSizeY
	if(CodeUtils::FindJsonValue(optionIndex,optionList,"tileStepSizeY","name")<0){
		WARN_LOG("Missing tileStepSizeY option!");
		ack= -1;
		reply= "Missing tileStepSizeY option!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;		
	}
	float tileStepSizeY= (optionList[optionIndex])["value"].asFloat();	
		
		
	DEBUG_LOG("Options: tileSizeX/tileSizeY="<<tileSizeX<<"/"<<tileSizeY<<", useTileOverlap? "<<useTileOverlap<<", tileStepSizeX/tileStepSizeY="<<tileStepSizeX<<"/"<<tileStepSizeY);

	//## Read input file and get image size
	long int Nx= -1;
	long int Ny= -1;
	if(SysUtils::GetFITSImageSize(inputFileName,Nx,Ny)<0){
		ERROR_LOG("Failed to open input file image "<<inputFileName<<" and get image size!");
		ack= -1;
		reply= "Failed to open input file image and get image size!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;	
	}
	INFO_LOG("Input image opened with success: size="<<Nx<<"x"<<Ny);

	//Check options
	if(tileSizeX<=0 || tileSizeY<=0) {
		WARN_LOG("Invalid tileSizeX/tileSizeY options!");
		ack= -1;
		reply= "Invalid tileSizeX/tileSizeY options!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;	
	}
	if(tileStepSizeX<=0 || tileStepSizeY<=0 || tileStepSizeX>1 || tileStepSizeY>1){
		WARN_LOG("Invalid tileStepSizeX/tileStepSizeY options!");
		ack= -1;
		reply= "Invalid tileStepSizeX/tileStepSizeY options!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	if(!useTileOverlap){
		tileStepSizeX= 1;
		tileStepSizeY= 1;	
	}
	
	//## Make the worker schedule
	//--> Compute the 2D grid 
	std::vector<long int> ix_min;
	std::vector<long int> ix_max;
	std::vector<long int> iy_min;
	std::vector<long int> iy_max;
	if(MathUtils::Compute2DGrid(ix_min,ix_max,iy_min,iy_max,Nx,Ny,tileSizeX,tileSizeY,tileStepSizeX,tileStepSizeY)<0){
		WARN_LOG("Failed to compute a 2D image partition!");
		ack= -1;
		reply= "Failed to compute a 2D image partition!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	int nExpectedTasks= ix_min.size()*iy_min.size();
	INFO_LOG("#"<<nExpectedTasks<<" expected number of tasks ("<<ix_min.size()<<"x"<<iy_min.size()<<")");

	//## Get number of free workers
	DEBUG_LOG("Getting free worker group (max="<<maxNWorkers<<")");
	Tango::Group* freeWorkers= new Tango::Group("jobWorkerGroup");
	bool requireExactly= false;
	if(m_workerManager->GetFreeWorkers(*freeWorkers,maxNWorkers,requireExactly)<0){
		WARN_LOG("Cannot find free workers!");

		if(freeWorkers){
			delete freeWorkers;
			freeWorkers= 0;
		}
		
		ack= -1;
		reply= "Cannot find free workers!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	long int nWorkers= freeWorkers->get_size();
	std::vector<std::string> worker_names= freeWorkers->get_device_list();
	INFO_LOG("#"<<nWorkers<<" free workers available...");
	
	//## Generate a uuid for this job
	std::string jobId= CodeUtils::GenerateUUID();
	DEBUG_LOG("Generated jobId: "<<jobId);
	
	//## Compute worker tasks (check max number of tasks per worker)
	DEBUG_LOG("Computing worker task list...");
	std::vector<WorkerTask*> workerTasks;
	std::vector< std::vector<WorkerTask*> > taskPerWorkers;
	for(int i=0;i<nWorkers;i++){
		taskPerWorkers.push_back( std::vector<WorkerTask*>() );
	}
	
	WorkerTask* aWorkerTask= 0;
	long int workerCounter= 0;
	for(unsigned int j=0;j<iy_min.size();j++){
		for(unsigned int i=0;i<ix_min.size();i++){
			//Assign worker
			DEBUG_LOG("Assign task ("<<i<<","<<j<<") to worker no. "<<workerCounter<<"...");
			std::string thisWorkerName= worker_names[workerCounter];
			
			aWorkerTask= new WorkerTask;
			aWorkerTask->filename= inputFileName;
			aWorkerTask->jobId= jobId;
			aWorkerTask->worker_name= thisWorkerName;
			aWorkerTask->broker_name= device_name;
			aWorkerTask->IdX= i;
			aWorkerTask->IdY= j;
			aWorkerTask->ix_min= ix_min[i];
			aWorkerTask->ix_max= ix_max[i];
			aWorkerTask->iy_min= iy_min[j];
			aWorkerTask->iy_max= iy_max[j];
			workerTasks.push_back(aWorkerTask);
			taskPerWorkers[workerCounter].push_back(aWorkerTask);

			if(workerCounter>=nWorkers-1) workerCounter= 0;
			else workerCounter++;
		}//end loop x
	}//end loop y
	
	bool hasTooManyTasks= false;
	for(int i=0;i<nWorkers;i++){
		long int nTasksPerWorker= (long int)taskPerWorkers[i].size();
		if(nTasksPerWorker>maxNTasksPerWorker_default){
			hasTooManyTasks= true;
			break;
		}
	}

	if(hasTooManyTasks){
		WARN_LOG("Number of tasks per worker exceeds the maximum allowed threshold ("<<maxNTasksPerWorker_default<<")!");
		
		//Clear worker group
		if(freeWorkers){
			delete freeWorkers;
			freeWorkers= 0;
		}
		
		//Clear tasks
		for(int i=0;i<nWorkers;i++) taskPerWorkers[i].clear();
		for(unsigned int i=0;i<workerTasks.size();i++){
			if(workerTasks[i]){
				delete workerTasks[i];
				workerTasks[i]= 0;
			}
		}
		workerTasks.clear();
		
		ack= -1;
		reply= "Number of tasks per worker exceeds the maximum allowed threshold!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	//## Convert task to group string arguments
	bool isSerializationFailed= false;
	std::vector<std::string> tasksArgList;
	for(int i=0;i<nWorkers;i++) {
		std::string thisTaskArg= "";
		if(Serializer::WorkerTasksToJsonString(thisTaskArg,taskPerWorkers[i])<0){
			isSerializationFailed= true;
			break;
		}
		tasksArgList.push_back(thisTaskArg);
		DEBUG_LOG("Task argin worker no. "<<i+1<<": "<<thisTaskArg);
	}//end loop workers
	
	if(isSerializationFailed){
		//Clear worker group
		if(freeWorkers){
			delete freeWorkers;
			freeWorkers= 0;
		}
		
		//Clear tasks
		for(int i=0;i<nWorkers;i++) taskPerWorkers[i].clear();
		for(unsigned int i=0;i<workerTasks.size();i++){
			if(workerTasks[i]){
				delete workerTasks[i];
				workerTasks[i]= 0;
			}
		}
		workerTasks.clear();
		
		WARN_LOG("Serialization of task argin failed!");
		ack= -1;
		reply= "Serialization of task argin failed!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	//## Create group command args and submit job to group
	std::vector<Tango::DeviceData> din_list;
	bool isArginCreationFailed= false;
	for(int i=0;i<nWorkers;i++){
		try {
			Tango::DeviceData din;
			Tango::DevVarStringArray* in = new Tango::DevVarStringArray(); 
    	in->length(4); 
			(*in)[0] = CORBA::string_dup(inputFileName.c_str());//filename
    	(*in)[1] = CORBA::string_dup(jobId.c_str());//jobId
			(*in)[2] = CORBA::string_dup(tasksArgList[i].c_str());//task config
			(*in)[3] = CORBA::string_dup(config.c_str());//config
    	din << in; 
			din_list.push_back(din);
		}
		catch(const Tango::DevFailed& e){
			WARN_LOG("Creation of command group input argument no. "<<i+1<<" failed!");
			isArginCreationFailed= true;
			break;
		}
	}//end loop

	if(isArginCreationFailed){
		WARN_LOG("Creation of command group input arguments failed!");

		//Clear worker group
		if(freeWorkers){
			delete freeWorkers;
			freeWorkers= 0;
		}
		
		//Clear tasks
		for(int i=0;i<nWorkers;i++) taskPerWorkers[i].clear();
		for(unsigned int i=0;i<workerTasks.size();i++){
			if(workerTasks[i]){
				delete workerTasks[i];
				workerTasks[i]= 0;
			}
		}
		workerTasks.clear();

		ack= -1;
		reply= "Creation of command group input arguments failed!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	} 

	
	//## Submit job to group
	Tango::GroupCmdReplyList crl;
	try {
		//Execute the command
		crl = freeWorkers->command_inout("ExtractSources", din_list, true);
		if (crl.has_failed()) {
			WARN_LOG("Failure occurred in command submission for some of the workers...");
		}
	}//close try
	catch (const Tango::DevFailed& e){
		ERROR_LOG("Command group submission failed!");
		crl.reset();
		
		//Clear worker group
		if(freeWorkers){
			delete freeWorkers;
			freeWorkers= 0;
		}
		
		//Clear tasks
		for(int i=0;i<nWorkers;i++) taskPerWorkers[i].clear();
		for(unsigned int i=0;i<workerTasks.size();i++){
			if(workerTasks[i]){
				delete workerTasks[i];
				workerTasks[i]= 0;
			}
		}
		workerTasks.clear();

		ack= -1;
		reply= "Command group submission failed!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;	
	}
	crl.reset();

	//## Create dynamic attribute for this job
	if(AddJobAttr(jobId)<0){
		WARN_LOG("Failed to add dynamic job attribute!");

		//Clear worker group
		if(freeWorkers){
			delete freeWorkers;
			freeWorkers= 0;
		}
		
		//Clear tasks
		for(int i=0;i<nWorkers;i++) taskPerWorkers[i].clear();
		for(unsigned int i=0;i<workerTasks.size();i++){
			if(workerTasks[i]){
				delete workerTasks[i];
				workerTasks[i]= 0;
			}
		}
		workerTasks.clear();

		ack= -1;
		reply= "Failed to add dynamic job attribute!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;			
	}

	//## Store job data in the list
	//...
	

	//## Return reply
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());

	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::submit_source_finder_job
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : SFinderBroker::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinderBroker::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(SFinderBroker::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinderBroker::add_dynamic_commands
}

/*----- PROTECTED REGION ID(SFinderBroker::namespace_ending) ENABLED START -----*/

//	Additional Methods
int SFinderBroker::ValidateConfigOptions(Json::Value& optionList,std::string& config){

	//## Parse config json options
	Json::Reader reader;
	Json::Value root;
  if(!reader.parse(config, root)) {
		ERROR_LOG("Failed to parse config JSON ("<<reader.getFormattedErrorMessages()<<")");
		return -1;
	}
	
	//## Check top json
	if(root.isNull() || root.empty()){
		ERROR_LOG("Failed to parse config JSON (null or empty)!");
		return -1;
	}

	//Get option array 
	optionList= root["options"];
	if(optionList.isNull() || optionList.empty() || !optionList.isArray() ){
		ERROR_LOG("Failed to parse config JSON option list (null/empty or not an array)!");
		return -1;
	}
	
	return 0;

}//close ValidateConfigOptions()


bool SFinderBroker::FindAttr(long int& index,std::string& attr_name){

	index= -1;

	bool hasAttr= false;
	try{
		//get_device_attr()->get_attr_by_name(attr_name.c_str());
		index= get_device_attr()->get_attr_ind_by_name(attr_name.c_str());
		hasAttr= true;
	}
	catch(Tango::DevFailed &e){//an exception is thrown if the attribute is not existing
		hasAttr= false;
		index= -1;
	}
	catch(...){//an exception is thrown if the attribute is not existing
		hasAttr= false;
		index= -1;
	}

	return hasAttr;

}//clos FindAttr()

int SFinderBroker::AddJobAttr(std::string& attr_name){

	//Check if attribute is already present in the attribute list
	long int attr_index= -1;
	bool hasAttr= FindAttr(attr_index,attr_name);	
	if(hasAttr){
		WARN_LOG("Attribute "<<attr_name<<" already exists, nothing to be done!");
		return 0;
	}
	DEBUG_LOG("Attribute "<<attr_name<<" is not present is the list, adding it!");

	//Create a new attr, init value and set change event
	try{
		add_dynStringAttr_dynamic_attribute(attr_name.c_str());
			
		Tango::DevString* attr_value = get_dynStringAttr_data_ptr(attr_name);
		*attr_value= CORBA::string_dup("");
	}//close try block
	catch(const Tango::DevFailed &e){
		Tango::Except::print_exception(e);
		WARN_LOG("Adding attr "<<attr_name<<" failed!");
		return -1;
	}
	catch(...){
		WARN_LOG("Unknown exception while adding "<<attr_name<<"!");
		return -1;
	}

	//Set change/data ready event
	try{
		set_change_event (attr_name, true, true);
		set_data_ready_event (attr_name, true);
	}
	catch(const Tango::DevFailed &e){
		Tango::Except::print_exception(e);
		WARN_LOG("Failed to set change/data ready event to attr "<<attr_name<<"!");
		return -1;
	}
	catch(...){
		WARN_LOG("Unknown exception while setting change/data ready event to attr "<<attr_name<<"!");
		return -1;
	}

	return 0;

}//close AddScalarAttr()

int SFinderBroker::RemoveJobAttr(std::string& attr_name){

	//## Check if attribute is present in attr list
	long int attr_index= -1;
	bool hasAttr= FindAttr(attr_index,attr_name);	
	if(!hasAttr){
		WARN_LOG("Attribute "<<attr_name<<" does not exists, nothing to be removed!");
		return 0;
	}
	
	//If attr is present remove it from device attribute_list
	try{
		remove_dynStringAttr_dynamic_attribute(attr_name.c_str());
	}
	catch(...){
		ERROR_LOG("Failed to remove attr "<<attr_name<<" from device attr_list!");
		return -1;
	}	
	
	return 0;

}//close RemoveJobAttr()

/*----- PROTECTED REGION END -----*/	//	SFinderBroker::namespace_ending
} //	namespace
